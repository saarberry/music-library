(self["webpackChunk"] = self["webpackChunk"] || []).push([["/js/app"],{

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "BASE_TRANSITION": () => (/* binding */ BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* binding */ CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* binding */ CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* binding */ CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* binding */ CREATE_COMMENT),
/* harmony export */   "CREATE_SLOTS": () => (/* binding */ CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* binding */ CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* binding */ CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* binding */ CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* binding */ FRAGMENT),
/* harmony export */   "IS_REF": () => (/* binding */ IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* binding */ KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* binding */ MERGE_PROPS),
/* harmony export */   "OPEN_BLOCK": () => (/* binding */ OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* binding */ RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* binding */ RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* binding */ SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* binding */ TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* binding */ TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* binding */ UNREF),
/* harmony export */   "WITH_CTX": () => (/* binding */ WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   "WITH_SCOPE_ID": () => (/* binding */ WITH_SCOPE_ID),
/* harmony export */   "advancePositionWithClone": () => (/* binding */ advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* binding */ advancePositionWithMutation),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "baseCompile": () => (/* binding */ baseCompile),
/* harmony export */   "baseParse": () => (/* binding */ baseParse),
/* harmony export */   "buildProps": () => (/* binding */ buildProps),
/* harmony export */   "buildSlots": () => (/* binding */ buildSlots),
/* harmony export */   "createArrayExpression": () => (/* binding */ createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* binding */ createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* binding */ createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* binding */ createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* binding */ createCallExpression),
/* harmony export */   "createCompilerError": () => (/* binding */ createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* binding */ createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* binding */ createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* binding */ createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* binding */ createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* binding */ createIfStatement),
/* harmony export */   "createInterpolation": () => (/* binding */ createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* binding */ createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* binding */ createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* binding */ createReturnStatement),
/* harmony export */   "createRoot": () => (/* binding */ createRoot),
/* harmony export */   "createSequenceExpression": () => (/* binding */ createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* binding */ createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* binding */ createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* binding */ createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* binding */ createVNodeCall),
/* harmony export */   "findDir": () => (/* binding */ findDir),
/* harmony export */   "findProp": () => (/* binding */ findProp),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "getBaseTransformPreset": () => (/* binding */ getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* binding */ getInnerRange),
/* harmony export */   "hasDynamicKeyVBind": () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* binding */ hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* binding */ helperNameMap),
/* harmony export */   "injectProp": () => (/* binding */ injectProp),
/* harmony export */   "isBindKey": () => (/* binding */ isBindKey),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* binding */ isCoreComponent),
/* harmony export */   "isMemberExpression": () => (/* binding */ isMemberExpression),
/* harmony export */   "isSimpleIdentifier": () => (/* binding */ isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* binding */ isSlotOutlet),
/* harmony export */   "isStaticExp": () => (/* binding */ isStaticExp),
/* harmony export */   "isTemplateNode": () => (/* binding */ isTemplateNode),
/* harmony export */   "isText": () => (/* binding */ isText),
/* harmony export */   "isVSlot": () => (/* binding */ isVSlot),
/* harmony export */   "locStub": () => (/* binding */ locStub),
/* harmony export */   "noopDirectiveTransform": () => (/* binding */ noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* binding */ processExpression),
/* harmony export */   "processFor": () => (/* binding */ processFor),
/* harmony export */   "processIf": () => (/* binding */ processIf),
/* harmony export */   "processSlotOutlet": () => (/* binding */ processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* binding */ resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* binding */ toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* binding */ trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* binding */ trackVForSlotScopes),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformBind": () => (/* binding */ transformBind),
/* harmony export */   "transformElement": () => (/* binding */ transformElement),
/* harmony export */   "transformExpression": () => (/* binding */ transformExpression),
/* harmony export */   "transformModel": () => (/* binding */ transformModel),
/* harmony export */   "transformOn": () => (/* binding */ transformOn),
/* harmony export */   "traverseNode": () => (/* binding */ traverseNode)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");



function defaultOnError(error) {
    throw error;
}
function createCompilerError(code, loc, messages, additionalMessage) {
    const msg =  true
        ? (messages || errorMessages)[code] + (additionalMessage || ``)
        : 0;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
}
const errorMessages = {
    // parse errors
    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
    [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
    [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
        'Note that dynamic directive argument cannot contain spaces.',
    // transform errors
    [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
    [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,
    [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
    [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
        `When there are multiple named slots, all slots should use <template> ` +
        `syntax to avoid scope ambiguity.`,
    [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
        `default slot. These children will be ignored.`,
    [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`
};

const FRAGMENT = Symbol(( true) ? `Fragment` : 0);
const TELEPORT = Symbol(( true) ? `Teleport` : 0);
const SUSPENSE = Symbol(( true) ? `Suspense` : 0);
const KEEP_ALIVE = Symbol(( true) ? `KeepAlive` : 0);
const BASE_TRANSITION = Symbol(( true) ? `BaseTransition` : 0);
const OPEN_BLOCK = Symbol(( true) ? `openBlock` : 0);
const CREATE_BLOCK = Symbol(( true) ? `createBlock` : 0);
const CREATE_VNODE = Symbol(( true) ? `createVNode` : 0);
const CREATE_COMMENT = Symbol(( true) ? `createCommentVNode` : 0);
const CREATE_TEXT = Symbol(( true) ? `createTextVNode` : 0);
const CREATE_STATIC = Symbol(( true) ? `createStaticVNode` : 0);
const RESOLVE_COMPONENT = Symbol(( true) ? `resolveComponent` : 0);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(( true) ? `resolveDynamicComponent` : 0);
const RESOLVE_DIRECTIVE = Symbol(( true) ? `resolveDirective` : 0);
const WITH_DIRECTIVES = Symbol(( true) ? `withDirectives` : 0);
const RENDER_LIST = Symbol(( true) ? `renderList` : 0);
const RENDER_SLOT = Symbol(( true) ? `renderSlot` : 0);
const CREATE_SLOTS = Symbol(( true) ? `createSlots` : 0);
const TO_DISPLAY_STRING = Symbol(( true) ? `toDisplayString` : 0);
const MERGE_PROPS = Symbol(( true) ? `mergeProps` : 0);
const TO_HANDLERS = Symbol(( true) ? `toHandlers` : 0);
const CAMELIZE = Symbol(( true) ? `camelize` : 0);
const CAPITALIZE = Symbol(( true) ? `capitalize` : 0);
const TO_HANDLER_KEY = Symbol(( true) ? `toHandlerKey` : 0);
const SET_BLOCK_TRACKING = Symbol(( true) ? `setBlockTracking` : 0);
const PUSH_SCOPE_ID = Symbol(( true) ? `pushScopeId` : 0);
const POP_SCOPE_ID = Symbol(( true) ? `popScopeId` : 0);
const WITH_SCOPE_ID = Symbol(( true) ? `withScopeId` : 0);
const WITH_CTX = Symbol(( true) ? `withCtx` : 0);
const UNREF = Symbol(( true) ? `unref` : 0);
const IS_REF = Symbol(( true) ? `isRef` : 0);
// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_SCOPE_ID]: `withScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`
};
function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach(s => {
        helperNameMap[s] = helpers[s];
    });
}

// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
const locStub = {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
    return {
        type: 0 /* ROOT */,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: undefined,
        loc
    };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {
    if (context) {
        if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(CREATE_BLOCK);
        }
        else {
            context.helper(CREATE_VNODE);
        }
        if (directives) {
            context.helper(WITH_DIRECTIVES);
        }
    }
    return {
        type: 13 /* VNODE_CALL */,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        loc
    };
}
function createArrayExpression(elements, loc = locStub) {
    return {
        type: 17 /* JS_ARRAY_EXPRESSION */,
        loc,
        elements
    };
}
function createObjectExpression(properties, loc = locStub) {
    return {
        type: 15 /* JS_OBJECT_EXPRESSION */,
        loc,
        properties
    };
}
function createObjectProperty(key, value) {
    return {
        type: 16 /* JS_PROPERTY */,
        loc: locStub,
        key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
        value
    };
}
function createSimpleExpression(content, isStatic, loc = locStub, constType = 0 /* NOT_CONSTANT */) {
    return {
        type: 4 /* SIMPLE_EXPRESSION */,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType
    };
}
function createInterpolation(content, loc) {
    return {
        type: 5 /* INTERPOLATION */,
        loc,
        content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content)
            ? createSimpleExpression(content, false, loc)
            : content
    };
}
function createCompoundExpression(children, loc = locStub) {
    return {
        type: 8 /* COMPOUND_EXPRESSION */,
        loc,
        children
    };
}
function createCallExpression(callee, args = [], loc = locStub) {
    return {
        type: 14 /* JS_CALL_EXPRESSION */,
        loc,
        callee,
        arguments: args
    };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
    return {
        type: 18 /* JS_FUNCTION_EXPRESSION */,
        params,
        returns,
        newline,
        isSlot,
        loc
    };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
        type: 19 /* JS_CONDITIONAL_EXPRESSION */,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
    };
}
function createCacheExpression(index, value, isVNode = false) {
    return {
        type: 20 /* JS_CACHE_EXPRESSION */,
        index,
        value,
        isVNode,
        loc: locStub
    };
}
function createBlockStatement(body) {
    return {
        type: 21 /* JS_BLOCK_STATEMENT */,
        body,
        loc: locStub
    };
}
function createTemplateLiteral(elements) {
    return {
        type: 22 /* JS_TEMPLATE_LITERAL */,
        elements,
        loc: locStub
    };
}
function createIfStatement(test, consequent, alternate) {
    return {
        type: 23 /* JS_IF_STATEMENT */,
        test,
        consequent,
        alternate,
        loc: locStub
    };
}
function createAssignmentExpression(left, right) {
    return {
        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,
        left,
        right,
        loc: locStub
    };
}
function createSequenceExpression(expressions) {
    return {
        type: 25 /* JS_SEQUENCE_EXPRESSION */,
        expressions,
        loc: locStub
    };
}
function createReturnStatement(returns) {
    return {
        type: 26 /* JS_RETURN_STATEMENT */,
        returns,
        loc: locStub
    };
}

const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
function isCoreComponent(tag) {
    if (isBuiltInType(tag, 'Teleport')) {
        return TELEPORT;
    }
    else if (isBuiltInType(tag, 'Suspense')) {
        return SUSPENSE;
    }
    else if (isBuiltInType(tag, 'KeepAlive')) {
        return KEEP_ALIVE;
    }
    else if (isBuiltInType(tag, 'BaseTransition')) {
        return BASE_TRANSITION;
    }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const memberExpRE = /^[A-Za-z_$][\w$]*(?:\s*\.\s*[A-Za-z_$][\w$]*|\[[^\]]+\])*$/;
const isMemberExpression = (path) => {
    if (!path)
        return false;
    return memberExpRE.test(path.trim());
};
function getInnerRange(loc, offset, length) {
    const source = loc.source.substr(offset, length);
    const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
    };
    if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
    }
}
function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 /* DIRECTIVE */ &&
            (allowEmpty || p.exp) &&
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
            return p;
        }
    }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (dynamicOnly)
                continue;
            if (p.name === name && (p.value || allowEmpty)) {
                return p;
            }
        }
        else if (p.name === 'bind' &&
            (p.exp || allowEmpty) &&
            isBindKey(p.arg, name)) {
            return p;
        }
    }
}
function isBindKey(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
        p.name === 'bind' &&
        (!p.arg || // v-bind="obj"
            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
            !p.arg.isStatic) // v-bind:[foo]
    );
}
function isText(node) {
    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
}
function isVSlot(p) {
    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
}
function isTemplateNode(node) {
    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
}
function isSlotOutlet(node) {
    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
}
function injectProp(node, prop, context) {
    let propsWithInjection;
    const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
    if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
        propsWithInjection = createObjectExpression([prop]);
    }
    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
        // merged props... add ours
        // only inject key to object literal if it's the first argument so that
        // if doesn't override user provided keys
        const first = props.arguments[0];
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
            first.properties.unshift(prop);
        }
        else {
            if (props.callee === TO_HANDLERS) {
                // #2366
                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                    createObjectExpression([prop]),
                    props
                ]);
            }
            else {
                props.arguments.unshift(createObjectExpression([prop]));
            }
        }
        !propsWithInjection && (propsWithInjection = props);
    }
    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        let alreadyExists = false;
        // check existing key to avoid overriding user provided keys
        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
            const propKeyName = prop.key.content;
            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                p.key.content === propKeyName);
        }
        if (!alreadyExists) {
            props.properties.unshift(prop);
        }
        propsWithInjection = props;
    }
    else {
        // single v-bind with expression, return a merged replacement
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
        ]);
    }
    if (node.type === 13 /* VNODE_CALL */) {
        node.props = propsWithInjection;
    }
    else {
        node.arguments[2] = propsWithInjection;
    }
}
function toValidAssetId(name, type) {
    return `_${type}_${name.replace(/[^\w]/g, '_')}`;
}
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
        return false;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
            for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 /* DIRECTIVE */ &&
                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                    return true;
                }
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 11 /* FOR */:
            if (hasScopeRef(node.source, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 9 /* IF */:
            return node.branches.some(b => hasScopeRef(b, ids));
        case 10 /* IF_BRANCH */:
            if (hasScopeRef(node.condition, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 4 /* SIMPLE_EXPRESSION */:
            return (!node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]);
        case 8 /* COMPOUND_EXPRESSION */:
            return node.children.some(c => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return hasScopeRef(node.content, ids);
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return false;
        default:
            if ((true)) ;
            return false;
    }
}

// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* HTML */,
    getTextMode: () => 0 /* DATA */,
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    comments: false
};
function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
    const options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
    for (const key in rawOptions) {
        // @ts-ignore
        options[key] = rawOptions[key] || defaultParserOptions[key];
    }
    return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false
    };
}
function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* HTML */;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = undefined;
        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                // '{{'
                node = parseInterpolation(context, mode);
            }
            else if (mode === 0 /* DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                }
                else if (s[1] === '!') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                    if (startsWith(s, '<!--')) {
                        node = parseComment(context);
                    }
                    else if (startsWith(s, '<!DOCTYPE')) {
                        // Ignore DOCTYPE by a limitation.
                        node = parseBogusComment(context);
                    }
                    else if (startsWith(s, '<![CDATA[')) {
                        if (ns !== 0 /* HTML */) {
                            node = parseCDATA(context, ancestors);
                        }
                        else {
                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else {
                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                        node = parseBogusComment(context);
                    }
                }
                else if (s[1] === '/') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                    if (s.length === 2) {
                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                    }
                    else if (s[2] === '>') {
                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                        advanceBy(context, 3);
                        continue;
                    }
                    else if (/[a-z]/i.test(s[2])) {
                        emitError(context, 23 /* X_INVALID_END_TAG */);
                        parseTag(context, 1 /* End */, parent);
                        continue;
                    }
                    else {
                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                        node = parseBogusComment(context);
                    }
                }
                else if (/[a-z]/i.test(s[1])) {
                    node = parseElement(context, ancestors);
                }
                else if (s[1] === '?') {
                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                    node = parseBogusComment(context);
                }
                else {
                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                }
            }
        }
        if (!node) {
            node = parseText(context, mode);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
            }
        }
        else {
            pushNode(nodes, node);
        }
    }
    // Whitespace management for more efficient output
    // (same as v2 whitespace: 'condense')
    let removedWhitespace = false;
    if (mode !== 2 /* RAWTEXT */) {
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (!context.inPre && node.type === 2 /* TEXT */) {
                if (!/[^\t\r\n\f ]/.test(node.content)) {
                    const prev = nodes[i - 1];
                    const next = nodes[i + 1];
                    // If:
                    // - the whitespace is the first or last node, or:
                    // - the whitespace is adjacent to a comment, or:
                    // - the whitespace is between two elements AND contains newline
                    // Then the whitespace is ignored.
                    if (!prev ||
                        !next ||
                        prev.type === 3 /* COMMENT */ ||
                        next.type === 3 /* COMMENT */ ||
                        (prev.type === 1 /* ELEMENT */ &&
                            next.type === 1 /* ELEMENT */ &&
                            /[\r\n]/.test(node.content))) {
                        removedWhitespace = true;
                        nodes[i] = null;
                    }
                    else {
                        // Otherwise, condensed consecutive whitespace inside the text
                        // down to a single space
                        node.content = ' ';
                    }
                }
                else {
                    node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                }
            }
            // also remove comment nodes in prod by default
            if (false) {}
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            // remove leading newline per html spec
            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
            const first = nodes[0];
            if (first && first.type === 2 /* TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
            }
        }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
    if (node.type === 2 /* TEXT */) {
        const prev = last(nodes);
        // Merge if both this and the previous node are text and those are
        // consecutive. This happens for cases like "a < b".
        if (prev &&
            prev.type === 2 /* TEXT */ &&
            prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
        }
    }
    nodes.push(node);
}
function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
    if (context.source.length === 0) {
        emitError(context, 6 /* EOF_IN_CDATA */);
    }
    else {
        advanceBy(context, 3);
    }
    return nodes;
}
function parseComment(context) {
    const start = getCursor(context);
    let content;
    // Regular comment.
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7 /* EOF_IN_COMMENT */);
    }
    else {
        if (match.index <= 3) {
            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
        }
        if (match[1]) {
            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
        }
        content = context.source.slice(4, match.index);
        // Advancing with reporting nested comments.
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* NESTED_COMMENT */);
            }
            prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === '?' ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf('>');
    if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
    }
    else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseElement(context, ancestors) {
    // Start tag.
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0 /* Start */, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        return element;
    }
    // Children.
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    element.children = children;
    // End tag.
    if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1 /* End */, parent);
    }
    else {
        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
            const first = children[0];
            if (first && startsWith(first.loc.source, '<!--')) {
                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
            }
        }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
        context.inPre = false;
    }
    if (isVPreBoundary) {
        context.inVPre = false;
    }
    return element;
}
const isSpecialTemplateDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`if,else,else-if,for,slot`);
/**
 * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).
 */
function parseTag(context, type, parent) {
    // Tag open.
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // save current state in case we need to re-parse attributes with v-pre
    const cursor = getCursor(context);
    const currentSource = context.source;
    // Attributes.
    let props = parseAttributes(context, type);
    // check <pre> tag
    if (context.options.isPreTag(tag)) {
        context.inPre = true;
    }
    // check v-pre
    if (!context.inVPre &&
        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
        context.inVPre = true;
        // reset context
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
        context.source = currentSource;
        // re-parse attrs and filter out v-pre itself
        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
    }
    // Tag close.
    let isSelfClosing = false;
    if (context.source.length === 0) {
        emitError(context, 9 /* EOF_IN_TAG */);
    }
    else {
        isSelfClosing = startsWith(context.source, '/>');
        if (type === 1 /* End */ && isSelfClosing) {
            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
    }
    let tagType = 0 /* ELEMENT */;
    const options = context.options;
    if (!context.inVPre && !options.isCustomElement(tag)) {
        const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'is');
        if (options.isNativeTag && !hasVIs) {
            if (!options.isNativeTag(tag))
                tagType = 1 /* COMPONENT */;
        }
        else if (hasVIs ||
            isCoreComponent(tag) ||
            (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
            /^[A-Z]/.test(tag) ||
            tag === 'component') {
            tagType = 1 /* COMPONENT */;
        }
        if (tag === 'slot') {
            tagType = 2 /* SLOT */;
        }
        else if (tag === 'template' &&
            props.some(p => {
                return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));
            })) {
            tagType = 3 /* TEMPLATE */;
        }
    }
    return {
        type: 1 /* ELEMENT */,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: undefined // to be created during transform phase
    };
}
function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 &&
        !startsWith(context.source, '>') &&
        !startsWith(context.source, '/>')) {
        if (startsWith(context.source, '/')) {
            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
        }
        if (type === 1 /* End */) {
            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
        }
        const attr = parseAttribute(context, attributeNames);
        if (type === 0 /* Start */) {
            props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
        }
        advanceSpaces(context);
    }
    return props;
}
function parseAttribute(context, nameSet) {
    // Name.
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === '=') {
        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
        const pattern = /["'<]/g;
        let m;
        while ((m = pattern.exec(name))) {
            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
        }
    }
    advanceBy(context, name.length);
    // Value
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
        }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        const dirName = match[1] ||
            (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');
        let arg;
        if (match[2]) {
            const isSlot = dirName === 'slot';
            const startOffset = name.indexOf(match[2]);
            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
            let content = match[2];
            let isStatic = true;
            if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                    emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                }
                content = content.substr(1, content.length - 2);
            }
            else if (isSlot) {
                // #1241 special case for v-slot: vuetify relies extensively on slot
                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                // supports such usage so we are keeping it consistent with 2.x.
                content += match[3] || '';
            }
            arg = {
                type: 4 /* SIMPLE_EXPRESSION */,
                content,
                isStatic,
                constType: isStatic
                    ? 3 /* CAN_STRINGIFY */
                    : 0 /* NOT_CONSTANT */,
                loc
            };
        }
        if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
        }
        return {
            type: 7 /* DIRECTIVE */,
            name: dirName,
            exp: value && {
                type: 4 /* SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // other values by `transformExpression` to make it eligible for hoisting.
                constType: 0 /* NOT_CONSTANT */,
                loc: value.loc
            },
            arg,
            modifiers: match[3] ? match[3].substr(1).split('.') : [],
            loc
        };
    }
    return {
        type: 6 /* ATTRIBUTE */,
        name,
        value: value && {
            type: 2 /* TEXT */,
            content: value.content,
            loc: value.loc
        },
        loc
    };
}
function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
        // Quoted value.
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
        }
        else {
            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
            advanceBy(context, 1);
        }
    }
    else {
        // Unquoted
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
            return undefined;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while ((m = unexpectedChars.exec(match[0]))) {
            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
        }
        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
        return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
        type: 5 /* INTERPOLATION */,
        content: {
            type: 4 /* SIMPLE_EXPRESSION */,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0 /* NOT_CONSTANT */,
            content,
            loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
    };
}
function parseText(context, mode) {
    const endTokens = ['<', context.options.delimiters[0]];
    if (mode === 3 /* CDATA */) {
        endTokens.push(']]>');
    }
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
            endIndex = index;
        }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
        type: 2 /* TEXT */,
        content,
        loc: getSelection(context, start)
    };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */
function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 /* RAWTEXT */ ||
        mode === 3 /* CDATA */ ||
        rawText.indexOf('&') === -1) {
        return rawText;
    }
    else {
        // DATA or RCDATA containing "&"". Entity decoding required.
        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
    }
}
function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
}
function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
    };
}
function last(xs) {
    return xs[xs.length - 1];
}
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
        loc.offset += offset;
        loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ''
    }));
}
function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
        case 0 /* DATA */:
            if (startsWith(s, '</')) {
                // TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                        return true;
                    }
                }
            }
            break;
        case 1 /* RCDATA */:
        case 2 /* RAWTEXT */: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
            }
            break;
        }
        case 3 /* CDATA */:
            if (startsWith(s, ']]>')) {
                return true;
            }
            break;
    }
    return !s;
}
function startsWithEndTagOpen(source, tag) {
    return (startsWith(source, '</') &&
        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
}

function hoistStatic(root, context) {
    walk(root, context, 
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
    const { children } = root;
    return (children.length === 1 &&
        child.type === 1 /* ELEMENT */ &&
        !isSlotOutlet(child));
}
function walk(node, context, doNotHoistNode = false) {
    let hasHoistedNode = false;
    // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces
    // static bindings with expressions. These expressions are guaranteed to be
    // constant so they are still eligible for hoisting, but they are only
    // available at runtime and therefore cannot be evaluated ahead of time.
    // This is only a concern for pre-stringification (via transformHoist by
    // @vue/compiler-dom), but doing it here allows us to perform only one full
    // walk of the AST and allow `stringifyStatic` to stop walking as soon as its
    // stringficiation threshold is met.
    let canStringify = true;
    const { children } = node;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // only plain elements & text calls are eligible for hoisting.
        if (child.type === 1 /* ELEMENT */ &&
            child.tagType === 0 /* ELEMENT */) {
            const constantType = doNotHoistNode
                ? 0 /* NOT_CONSTANT */
                : getConstantType(child, context);
            if (constantType > 0 /* NOT_CONSTANT */) {
                if (constantType < 3 /* CAN_STRINGIFY */) {
                    canStringify = false;
                }
                if (constantType >= 2 /* CAN_HOIST */) {
                    child.codegenNode.patchFlag =
                        -1 /* HOISTED */ + (( true) ? ` /* HOISTED */` : 0);
                    child.codegenNode = context.hoist(child.codegenNode);
                    hasHoistedNode = true;
                    continue;
                }
            }
            else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* VNODE_CALL */) {
                    const flag = getPatchFlag(codegenNode);
                    if ((!flag ||
                        flag === 512 /* NEED_PATCH */ ||
                        flag === 1 /* TEXT */) &&
                        getGeneratedPropsConstantType(child, context) >=
                            2 /* CAN_HOIST */) {
                        const props = getNodeProps(child);
                        if (props) {
                            codegenNode.props = context.hoist(props);
                        }
                    }
                }
            }
        }
        else if (child.type === 12 /* TEXT_CALL */) {
            const contentType = getConstantType(child.content, context);
            if (contentType > 0) {
                if (contentType < 3 /* CAN_STRINGIFY */) {
                    canStringify = false;
                }
                if (contentType >= 2 /* CAN_HOIST */) {
                    child.codegenNode = context.hoist(child.codegenNode);
                    hasHoistedNode = true;
                }
            }
        }
        // walk further
        if (child.type === 1 /* ELEMENT */) {
            walk(child, context);
        }
        else if (child.type === 11 /* FOR */) {
            // Do not hoist v-for single child because it has to be a block
            walk(child, context, child.children.length === 1);
        }
        else if (child.type === 9 /* IF */) {
            for (let i = 0; i < child.branches.length; i++) {
                // Do not hoist v-if single child because it has to be a block
                walk(child.branches[i], context, child.branches[i].children.length === 1);
            }
        }
    }
    if (canStringify && hasHoistedNode && context.transformHoist) {
        context.transformHoist(children, context, node);
    }
}
function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
        case 1 /* ELEMENT */:
            if (node.tagType !== 0 /* ELEMENT */) {
                return 0 /* NOT_CONSTANT */;
            }
            const cached = constantCache.get(node);
            if (cached !== undefined) {
                return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13 /* VNODE_CALL */) {
                return 0 /* NOT_CONSTANT */;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
                let returnType = 3 /* CAN_STRINGIFY */;
                // Element itself has no patch flag. However we still need to check:
                // 1. Even for a node with no patch flag, it is possible for it to contain
                // non-hoistable expressions that refers to scope variables, e.g. compiler
                // injected keys or cached event handlers. Therefore we need to always
                // check the codegenNode's props to be sure.
                const generatedPropsType = getGeneratedPropsConstantType(node, context);
                if (generatedPropsType === 0 /* NOT_CONSTANT */) {
                    constantCache.set(node, 0 /* NOT_CONSTANT */);
                    return 0 /* NOT_CONSTANT */;
                }
                if (generatedPropsType < returnType) {
                    returnType = generatedPropsType;
                }
                // 2. its children.
                for (let i = 0; i < node.children.length; i++) {
                    const childType = getConstantType(node.children[i], context);
                    if (childType === 0 /* NOT_CONSTANT */) {
                        constantCache.set(node, 0 /* NOT_CONSTANT */);
                        return 0 /* NOT_CONSTANT */;
                    }
                    if (childType < returnType) {
                        returnType = childType;
                    }
                }
                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                // type, check if any of the props can cause the type to be lowered
                // we can skip can_patch because it's guaranteed by the absence of a
                // patchFlag.
                if (returnType > 1 /* CAN_SKIP_PATCH */) {
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {
                            const expType = getConstantType(p.exp, context);
                            if (expType === 0 /* NOT_CONSTANT */) {
                                constantCache.set(node, 0 /* NOT_CONSTANT */);
                                return 0 /* NOT_CONSTANT */;
                            }
                            if (expType < returnType) {
                                returnType = expType;
                            }
                        }
                    }
                }
                // only svg/foreignObject could be block here, however if they are
                // static then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                    codegenNode.isBlock = false;
                    context.helper(CREATE_VNODE);
                }
                constantCache.set(node, returnType);
                return returnType;
            }
            else {
                constantCache.set(node, 0 /* NOT_CONSTANT */);
                return 0 /* NOT_CONSTANT */;
            }
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return 3 /* CAN_STRINGIFY */;
        case 9 /* IF */:
        case 11 /* FOR */:
        case 10 /* IF_BRANCH */:
            return 0 /* NOT_CONSTANT */;
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return getConstantType(node.content, context);
        case 4 /* SIMPLE_EXPRESSION */:
            return node.constType;
        case 8 /* COMPOUND_EXPRESSION */:
            let returnType = 3 /* CAN_STRINGIFY */;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
                    continue;
                }
                const childType = getConstantType(child, context);
                if (childType === 0 /* NOT_CONSTANT */) {
                    return 0 /* NOT_CONSTANT */;
                }
                else if (childType < returnType) {
                    returnType = childType;
                }
            }
            return returnType;
        default:
            if ((true)) ;
            return 0 /* NOT_CONSTANT */;
    }
}
function getGeneratedPropsConstantType(node, context) {
    let returnType = 3 /* CAN_STRINGIFY */;
    const props = getNodeProps(node);
    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            const keyType = getConstantType(key, context);
            if (keyType === 0 /* NOT_CONSTANT */) {
                return keyType;
            }
            if (keyType < returnType) {
                returnType = keyType;
            }
            if (value.type !== 4 /* SIMPLE_EXPRESSION */) {
                return 0 /* NOT_CONSTANT */;
            }
            const valueType = getConstantType(value, context);
            if (valueType === 0 /* NOT_CONSTANT */) {
                return valueType;
            }
            if (valueType < returnType) {
                returnType = valueType;
            }
        }
    }
    return returnType;
}
function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13 /* VNODE_CALL */) {
        return codegenNode.props;
    }
}
function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, expressionPlugins = [], scopeId = null, ssr = false, ssrCssVars = ``, bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError }) {
    const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
    const context = {
        // options
        selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        ssr,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        // state
        root,
        helpers: new Set(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        // methods
        helper(name) {
            context.helpers.add(name);
            return name;
        },
        helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
            /* istanbul ignore if */
            if ((true)) {
                if (!context.currentNode) {
                    throw new Error(`Node being replaced is already removed.`);
                }
                if (!context.parent) {
                    throw new Error(`Cannot replace root node.`);
                }
            }
            context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
            if (( true) && !context.parent) {
                throw new Error(`Cannot remove root node.`);
            }
            const list = context.parent.children;
            const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                    ? context.childIndex
                    : -1;
            /* istanbul ignore if */
            if (( true) && removalIndex < 0) {
                throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
            }
            else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                    context.childIndex--;
                    context.onNodeRemoved();
                }
            }
            context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => { },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
            context.hoists.push(exp);
            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);
            identifier.hoisted = exp;
            return identifier;
        },
        cache(exp, isVNode = false) {
            return createCacheExpression(++context.cached, exp, isVNode);
        }
    };
    return context;
}
function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
        hoistStatic(root, context);
    }
    if (!options.ssr) {
        createRootCodegen(root, context);
    }
    // finalize meta information
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
}
function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
        const child = children[0];
        // if the single child is an element, turn it into a block.
        if (isSingleElementRoot(root, child) && child.codegenNode) {
            // single element root is never hoisted so codegenNode will never be
            // SimpleExpressionNode
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13 /* VNODE_CALL */) {
                codegenNode.isBlock = true;
                helper(OPEN_BLOCK);
                helper(CREATE_BLOCK);
            }
            root.codegenNode = codegenNode;
        }
        else {
            // - single <slot/>, IfNode, ForNode: already blocks.
            // - single text node: always patched.
            // root codegen falls through via genNode()
            root.codegenNode = child;
        }
    }
    else if (children.length > 1) {
        // root has multiple nodes - return a fragment block.
        let patchFlag = 64 /* STABLE_FRAGMENT */;
        let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];
        // check if the fragment actually contains a single valid child with
        // the rest being comments
        if (( true) &&
            children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
            patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
            patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true);
    }
    else ;
}
function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
        i--;
    };
    for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child))
            continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
    }
}
function traverseNode(node, context) {
    context.currentNode = node;
    // apply transform plugins
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
        const onExit = nodeTransforms[i](node, context);
        if (onExit) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
                exitFns.push(...onExit);
            }
            else {
                exitFns.push(onExit);
            }
        }
        if (!context.currentNode) {
            // node was removed
            return;
        }
        else {
            // node may have been replaced
            node = context.currentNode;
        }
    }
    switch (node.type) {
        case 3 /* COMMENT */:
            if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
            }
            break;
        case 5 /* INTERPOLATION */:
            // no need to traverse, but we need to inject toString helper
            if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
            }
            break;
        // for container types, further traverse downwards
        case 9 /* IF */:
            for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
            }
            break;
        case 10 /* IF_BRANCH */:
        case 11 /* FOR */:
        case 1 /* ELEMENT */:
        case 0 /* ROOT */:
            traverseChildren(node, context);
            break;
    }
    // exit transforms
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
        exitFns[i]();
    }
}
function createStructuralDirectiveTransform(name, fn) {
    const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)
        ? (n) => n === name
        : (n) => name.test(n);
    return (node, context) => {
        if (node.type === 1 /* ELEMENT */) {
            const { props } = node;
            // structural directive transforms are not concerned with slots
            // as they are handled separately in vSlot.ts
            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                    // structural directives are removed to avoid infinite recursion
                    // also we remove them *before* applying so that it can further
                    // traverse itself in case it moves the node around
                    props.splice(i, 1);
                    i--;
                    const onExit = fn(node, prop, context);
                    if (onExit)
                        exitFns.push(onExit);
                }
            }
            return exitFns;
        }
    };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {
    const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssr,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: undefined,
        helper(key) {
            return `_${helperNameMap[key]}`;
        },
        push(code, node) {
            context.code += code;
        },
        indent() {
            newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
            if (withoutNewLine) {
                --context.indentLevel;
            }
            else {
                newline(--context.indentLevel);
            }
        },
        newline() {
            newline(context.indentLevel);
        }
    };
    function newline(n) {
        context.push('\n' + `  `.repeat(n));
    }
    return context;
}
function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
        options.onContextCreated(context);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== 'module';
    // preambles
    // in setup() inline mode, the preamble is generated in a sub context
    // and returned separately.
    const preambleContext = context;
    {
        genFunctionPreamble(ast, preambleContext);
    }
    // enter render function
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
    const signature = args.join(', ');
    {
        push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        // function mode const declarations should be inside with block
        // also they should be renamed to avoid collision with user properties
        if (hasHelpers) {
            push(`const { ${ast.helpers
                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                .join(', ')} } = _Vue`);
            push(`\n`);
            newline();
        }
    }
    // generate asset resolution statements
    if (ast.components.length) {
        genAssets(ast.components, 'component', context);
        if (ast.directives.length || ast.temps > 0) {
            newline();
        }
    }
    if (ast.directives.length) {
        genAssets(ast.directives, 'directive', context);
        if (ast.temps > 0) {
            newline();
        }
    }
    if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
        push(`\n`);
        newline();
    }
    // generate the VNode tree expression
    if (!ssr) {
        push(`return `);
    }
    if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
    }
    else {
        push(`null`);
    }
    if (useWithBlock) {
        deindent();
        push(`}`);
    }
    deindent();
    push(`}`);
    return {
        ast,
        code: context.code,
        preamble: ``,
        // SourceMapGenerator does have toJSON() method but it's not in the types
        map: context.map ? context.map.toJSON() : undefined
    };
}
function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;
    const VueBinding = runtimeGlobalName;
    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    if (ast.helpers.length > 0) {
        {
            // "with" mode.
            // save Vue in a separate variable to avoid collision
            push(`const _Vue = ${VueBinding}\n`);
            // in "with" mode, helpers are declared inside the with block to avoid
            // has check cost, but hoists are lifted out of the function - we need
            // to provide the helper here.
            if (ast.hoists.length) {
                const staticHelpers = [
                    CREATE_VNODE,
                    CREATE_COMMENT,
                    CREATE_TEXT,
                    CREATE_STATIC
                ]
                    .filter(helper => ast.helpers.includes(helper))
                    .map(aliasHelper)
                    .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
            }
        }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
}
function genAssets(assets, type, { helper, push, newline }) {
    const resolver = helper(type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
        const id = assets[i];
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);
        if (i < assets.length - 1) {
            newline();
        }
    }
}
function genHoists(hoists, context) {
    if (!hoists.length) {
        return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    hoists.forEach((exp, i) => {
        if (exp) {
            push(`const _hoisted_${i + 1} = `);
            genNode(exp, context);
            newline();
        }
    });
    context.pure = false;
}
function isText$1(n) {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) ||
        n.type === 4 /* SIMPLE_EXPRESSION */ ||
        n.type === 2 /* TEXT */ ||
        n.type === 5 /* INTERPOLATION */ ||
        n.type === 8 /* COMPOUND_EXPRESSION */);
}
function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 ||
        ((( true)) && nodes.some(n => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n)));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
            push(node);
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
            genNodeListAsArray(node, context);
        }
        else {
            genNode(node, context);
        }
        if (i < nodes.length - 1) {
            if (multilines) {
                comma && push(',');
                newline();
            }
            else {
                comma && push(', ');
            }
        }
    }
}
function genNode(node, context) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
        context.push(node);
        return;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
        context.push(context.helper(node));
        return;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
        case 9 /* IF */:
        case 11 /* FOR */:
            ( true) &&
                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`);
            genNode(node.codegenNode, context);
            break;
        case 2 /* TEXT */:
            genText(node, context);
            break;
        case 4 /* SIMPLE_EXPRESSION */:
            genExpression(node, context);
            break;
        case 5 /* INTERPOLATION */:
            genInterpolation(node, context);
            break;
        case 12 /* TEXT_CALL */:
            genNode(node.codegenNode, context);
            break;
        case 8 /* COMPOUND_EXPRESSION */:
            genCompoundExpression(node, context);
            break;
        case 3 /* COMMENT */:
            genComment(node, context);
            break;
        case 13 /* VNODE_CALL */:
            genVNodeCall(node, context);
            break;
        case 14 /* JS_CALL_EXPRESSION */:
            genCallExpression(node, context);
            break;
        case 15 /* JS_OBJECT_EXPRESSION */:
            genObjectExpression(node, context);
            break;
        case 17 /* JS_ARRAY_EXPRESSION */:
            genArrayExpression(node, context);
            break;
        case 18 /* JS_FUNCTION_EXPRESSION */:
            genFunctionExpression(node, context);
            break;
        case 19 /* JS_CONDITIONAL_EXPRESSION */:
            genConditionalExpression(node, context);
            break;
        case 20 /* JS_CACHE_EXPRESSION */:
            genCacheExpression(node, context);
            break;
        // SSR only types
        case 21 /* JS_BLOCK_STATEMENT */:
            break;
        case 22 /* JS_TEMPLATE_LITERAL */:
            break;
        case 23 /* JS_IF_STATEMENT */:
            break;
        case 24 /* JS_ASSIGNMENT_EXPRESSION */:
            break;
        case 25 /* JS_SEQUENCE_EXPRESSION */:
            break;
        case 26 /* JS_RETURN_STATEMENT */:
            break;
        /* istanbul ignore next */
        case 10 /* IF_BRANCH */:
            // noop
            break;
        default:
            if ((true)) {
                assert(false, `unhandled codegen node type: ${node.type}`);
                // make sure we exhaust all possible types
                const exhaustiveCheck = node;
                return exhaustiveCheck;
            }
    }
}
function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
        push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
}
function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
            context.push(child);
        }
        else {
            genNode(child, context);
        }
    }
}
function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8 /* COMPOUND_EXPRESSION */) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
    }
    else if (node.isStatic) {
        // only quote keys if necessary
        const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);
        push(text, node);
    }
    else {
        push(`[${node.content}]`, node);
    }
}
function genComment(node, context) {
    if ((true)) {
        const { push, helper, pure } = context;
        if (pure) {
            push(PURE_ANNOTATION);
        }
        push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
    }
}
function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node;
    if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
        push(`)`);
    }
    if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
    }
}
function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
        if (args[i] != null)
            break;
    }
    return args.slice(0, i + 1).map(arg => arg || `null`);
}
// JavaScript
function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
}
function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
        push(`{}`, node);
        return;
    }
    const multilines = properties.length > 1 ||
        ((( true)) &&
            properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        // key
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        // value
        genNode(value, context);
        if (i < properties.length - 1) {
            // will only reach this if it's multilines
            push(`,`);
            newline();
        }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
    const { push, indent, deindent, scopeId, mode } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
        push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
        genNodeList(params, context);
    }
    else if (params) {
        genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
        push(`{`);
        indent();
    }
    if (returns) {
        if (newline) {
            push(`return `);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
    }
    else if (body) {
        genNode(body, context);
    }
    if (newline || body) {
        deindent();
        push(`}`);
    }
    if (isSlot) {
        push(`)`);
    }
}
function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4 /* SIMPLE_EXPRESSION */) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
    }
    else {
        push(`(`);
        genNode(test, context);
        push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
    if (!isNested) {
        context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
        context.indentLevel--;
    }
    needNewline && deindent(true /* without newline */);
}
function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
    }
    push(`)`);
}

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
const prohibitedKeywordRE = new RegExp('\\b' +
    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments,typeof,void')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    // empty expressions are validated per-directive since some directives
    // do allow empty expressions.
    if (!exp.trim()) {
        return;
    }
    try {
        new Function(asRawStatements
            ? ` ${exp} `
            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    }
    catch (e) {
        let message = e.message;
        const keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context.onError(createCompilerError(43 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));
    }
}

const transformExpression = (node, context) => {
    if (node.type === 5 /* INTERPOLATION */) {
        node.content = processExpression(node.content, context);
    }
    else if (node.type === 1 /* ELEMENT */) {
        // handle directives on element
        for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            // do not process for v-on & v-for since they are special handled
            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (exp &&
                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                    !(dir.name === 'on' && arg)) {
                    dir.exp = processExpression(exp, context, 
                    // slot args must be processed as function params
                    dir.name === 'slot');
                }
                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
                    dir.arg = processExpression(arg, context);
                }
            }
        }
    }
};
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node, context, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false) {
    {
        if ((true)) {
            // simple in-browser validation (same logic in 2.x)
            validateBrowserExpression(node, context, asParams, asRawStatements);
        }
        return node;
    }
}

const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // #1587: We need to dynamically increment the key based on the current
        // node's sibling nodes, since chained v-if/else branches are
        // rendered at the same depth
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9 /* IF */) {
                key += sibling.branches.length;
            }
        }
        // Exit callback. Complete the codegenNode when all children have been
        // transformed.
        return () => {
            if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
            }
            else {
                // attach this branch's codegen node to the v-if root.
                const parentCondition = getParentCondition(ifNode.codegenNode);
                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processIf(node, dir, context, processCodegen) {
    if (dir.name !== 'else' &&
        (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if ( true && dir.exp) {
        validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === 'if') {
        const branch = createIfBranch(node, dir);
        const ifNode = {
            type: 9 /* IF */,
            loc: node.loc,
            branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
            return processCodegen(ifNode, branch, true);
        }
    }
    else {
        // locate the adjacent v-if
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
            const sibling = siblings[i];
            if (( true) && sibling && sibling.type === 3 /* COMMENT */) {
                context.removeNode(sibling);
                comments.unshift(sibling);
                continue;
            }
            if (sibling &&
                sibling.type === 2 /* TEXT */ &&
                !sibling.content.trim().length) {
                context.removeNode(sibling);
                continue;
            }
            if (sibling && sibling.type === 9 /* IF */) {
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (( true) && comments.length) {
                    branch.children = [...comments, ...branch.children];
                }
                // check if user is forcing same key on different branches
                if (true) {
                    const key = branch.userKey;
                    if (key) {
                        sibling.branches.forEach(({ userKey }) => {
                            if (isSameKey(userKey, key)) {
                                context.onError(createCompilerError(28 /* X_V_IF_SAME_KEY */, branch.userKey.loc));
                            }
                        });
                    }
                }
                sibling.branches.push(branch);
                const onExit = processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit)
                    onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
            }
            else {
                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
            }
            break;
        }
    }
}
function createIfBranch(node, dir) {
    return {
        type: 10 /* IF_BRANCH */,
        loc: node.loc,
        condition: dir.name === 'else' ? undefined : dir.exp,
        children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')
            ? node.children
            : [node],
        userKey: findProp(node, `key`)
    };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
            ( true) ? '"v-if"' : 0,
            'true'
        ]));
    }
    else {
        return createChildrenCodegenNode(branch, keyIndex, context);
    }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
    if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11 /* FOR */) {
            // optimize away nested fragments when child is a ForNode
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
        }
        else {
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, 64 /* STABLE_FRAGMENT */ +
                (( true)
                    ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`
                    : 0), undefined, undefined, true, false, branch.loc);
        }
    }
    else {
        const vnodeCall = firstChild
            .codegenNode;
        // Change createVNode to createBlock.
        if (vnodeCall.type === 13 /* VNODE_CALL */) {
            vnodeCall.isBlock = true;
            helper(OPEN_BLOCK);
            helper(CREATE_BLOCK);
        }
        // inject branch key
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
    }
}
function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
        return false;
    }
    if (a.type === 6 /* ATTRIBUTE */) {
        if (a.value.content !== b.value.content) {
            return false;
        }
    }
    else {
        // directive
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
            return false;
        }
        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
            (exp.isStatic !== branchExp.isStatic ||
                exp.content !== branchExp.content)) {
            return false;
        }
    }
    return true;
}
function getParentCondition(node) {
    while (true) {
        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                node = node.alternate;
            }
            else {
                return node;
            }
        }
        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {
            node = node.value;
        }
    }
}

const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
    const { helper } = context;
    return processFor(node, dir, context, forNode => {
        // create the loop render function expression now, and add the
        // iterator on exit after all children have been traversed
        const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
        ]);
        const keyProp = findProp(node, `key`);
        const keyProperty = keyProp
            ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */
                ? createSimpleExpression(keyProp.value.content, true)
                : keyProp.exp)
            : null;
        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
            forNode.source.constType > 0 /* NOT_CONSTANT */;
        const fragmentFlag = isStableFragment
            ? 64 /* STABLE_FRAGMENT */
            : keyProp
                ? 128 /* KEYED_FRAGMENT */
                : 256 /* UNKEYED_FRAGMENT */;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag]} */` : 0), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, node.loc);
        return () => {
            // finish the codegen now that all children have been traversed
            let childBlock;
            const isTemplate = isTemplateNode(node);
            const { children } = forNode;
            // check <template v-for> key placement
            if (( true) && isTemplate) {
                node.children.some(c => {
                    if (c.type === 1 /* ELEMENT */) {
                        const key = findProp(c, 'key');
                        if (key) {
                            context.onError(createCompilerError(32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                            return true;
                        }
                    }
                });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;
            const slotOutlet = isSlotOutlet(node)
                ? node
                : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                    ? node.children[0] // api-extractor somehow fails to infer this
                    : null;
            if (slotOutlet) {
                // <slot v-for="..."> or <template v-for="..."><slot/></template>
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                }
            }
            else if (needFragmentWrapper) {
                // <template v-for="..."> with text or multi-elements
                // should generate a fragment block for each loop
                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +
                    (( true)
                        ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`
                        : 0), undefined, undefined, true);
            }
            else {
                // Normal element v-for. Directly use the child's codegenNode
                // but mark it as a block.
                childBlock = children[0]
                    .codegenNode;
                if (isTemplate && keyProperty) {
                    injectProp(childBlock, keyProperty, context);
                }
                childBlock.isBlock = !isStableFragment;
                if (childBlock.isBlock) {
                    helper(OPEN_BLOCK);
                    helper(CREATE_BLOCK);
                }
                else {
                    helper(CREATE_VNODE);
                }
            }
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
        context.onError(createCompilerError(30 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
        return;
    }
    const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp, context);
    if (!parseResult) {
        context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
        return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
        type: 11 /* FOR */,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    // bookkeeping
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
        scopes.vFor--;
        if (onExit)
            onExit();
    };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const [, LHS, RHS] = inMatch;
    const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: undefined,
        key: undefined,
        index: undefined
    };
    if (true) {
        validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim()
        .replace(stripParensRE, '')
        .trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, '').trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            if (true) {
                validateBrowserExpression(result.key, context, true);
            }
        }
        if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                    ? keyOffset + keyContent.length
                    : trimmedOffset + valueContent.length));
                if (true) {
                    validateBrowserExpression(result.index, context, true);
                }
            }
        }
    }
    if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (true) {
            validateBrowserExpression(result.value, context, true);
        }
    }
    return result;
}
function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }) {
    const params = [];
    if (value) {
        params.push(value);
    }
    if (key) {
        if (!value) {
            params.push(createSimpleExpression(`_`, false));
        }
        params.push(key);
    }
    if (index) {
        if (!key) {
            if (!value) {
                params.push(createSimpleExpression(`_`, false));
            }
            params.push(createSimpleExpression(`__`, false));
        }
        params.push(index);
    }
    return params;
}

const defaultFallback = createSimpleExpression(`undefined`, false);
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        (node.tagType === 1 /* COMPONENT */ ||
            node.tagType === 3 /* TEMPLATE */)) {
        // We are only checking non-empty v-slot here
        // since we only care about slots that introduce scope variables.
        const vSlot = findDir(node, 'slot');
        if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
                context.scopes.vSlot--;
            };
        }
    }
};
// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, 'for'))) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
        if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
            };
        }
    }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));
    // If the slot is inside a v-for or another v-slot, force it to be dynamic
    // since it likely uses a scope variable.
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    // 1. Check for slot with slotProps on component itself.
    //    <Comp v-slot="{ prop }"/>
    const onComponentSlot = findDir(node, 'slot', true);
    if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
    }
    // 2. Iterate through children and check for template slots
    //    <template v-slot:foo="{ prop }">
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) ||
            !(slotDir = findDir(slotElement, 'slot', true))) {
            // not a <template v-slot>, skip.
            if (slotElement.type !== 3 /* COMMENT */) {
                implicitDefaultChildren.push(slotElement);
            }
            continue;
        }
        if (onComponentSlot) {
            // already has on-component slot - this is incorrect usage.
            context.onError(createCompilerError(36 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
            break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        // check if name is dynamic.
        let staticSlotName;
        if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
        }
        else {
            hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        // check if this slot is conditional (v-if/v-for)
        let vIf;
        let vElse;
        let vFor;
        if ((vIf = findDir(slotElement, 'if'))) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        }
        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
            // find adjacent v-if
            let j = i;
            let prev;
            while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* COMMENT */) {
                    break;
                }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                    conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                    : buildDynamicSlot(slotName, slotFunction);
            }
            else {
                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
            }
        }
        else if ((vFor = findDir(slotElement, 'for'))) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult ||
                parseForExpression(vFor.exp, context);
            if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                ]));
            }
            else {
                context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
            }
        }
        else {
            // check duplicate static names
            if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                    context.onError(createCompilerError(37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                    continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                    hasNamedDefaultSlot = true;
                }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
    }
    if (!onComponentSlot) {
        if (!hasTemplateSlots) {
            // implicit default slot (on component)
            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
        }
        else if (implicitDefaultChildren.length) {
            // implicit default slot (mixed with named slots)
            if (hasNamedDefaultSlot) {
                context.onError(createCompilerError(38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
            }
            else {
                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
            }
        }
    }
    const slotFlag = hasDynamicSlots
        ? 2 /* DYNAMIC */
        : hasForwardedSlots(node.children)
            ? 3 /* FORWARDED */
            : 1 /* STABLE */;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
    // 2 = compiled but dynamic = can skip normalization, but must run diff
    // 1 = compiled and static = can skip normalization AND diff as optimized
    createSimpleExpression(slotFlag + (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0), false))), loc);
    if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
        ]);
    }
    return {
        slots,
        hasDynamicSlots
    };
}
function buildDynamicSlot(name, fn) {
    return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
    ]);
}
function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.type === 1 /* ELEMENT */) {
            if (child.tagType === 2 /* SLOT */ ||
                (child.tagType === 0 /* ELEMENT */ &&
                    hasForwardedSlots(child.children))) {
                return true;
            }
        }
    }
    return false;
}

// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap();
// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
    if (!(node.type === 1 /* ELEMENT */ &&
        (node.tagType === 0 /* ELEMENT */ ||
            node.tagType === 1 /* COMPONENT */))) {
        return;
    }
    // perform the work on exit, after all child expressions have been
    // processed and merged.
    return function postTransformElement() {
        const { tag, props } = node;
        const isComponent = node.tagType === 1 /* COMPONENT */;
        // The goal of the transform is to create a codegenNode implementing the
        // VNodeCall interface.
        const vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;
        const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = 
        // dynamic component may resolve to plain elements
        isDynamicComponent ||
            vnodeTag === TELEPORT ||
            vnodeTag === SUSPENSE ||
            (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' ||
                    tag === 'foreignObject' ||
                    // #938: elements with dynamic keys should be forced into blocks
                    findProp(node, 'key', true)));
        // props
        if (props.length > 0) {
            const propsBuildResult = buildProps(node, context);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives =
                directives && directives.length
                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                    : undefined;
        }
        // children
        if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                if (( true) && node.children.length > 1) {
                    context.onError(createCompilerError(44 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            }
            const shouldBuildAsSlots = isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                    type === 8 /* COMPOUND_EXPRESSION */;
                if (hasDynamicTextChild &&
                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                    patchFlag |= 1 /* TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* TEXT */) {
                    vnodeChildren = child;
                }
                else {
                    vnodeChildren = node.children;
                }
            }
            else {
                vnodeChildren = node.children;
            }
        }
        // patchFlag & dynamicPropNames
        if (patchFlag !== 0) {
            if ((true)) {
                if (patchFlag < 0) {
                    // special flags (negative and mutually exclusive)
                    vnodePatchFlag = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
                }
                else {
                    // bitwise flags
                    const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames)
                        .map(Number)
                        .filter(n => n > 0 && patchFlag & n)
                        .map(n => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n])
                        .join(`, `);
                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                }
            }
            else {}
            if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc);
    };
};
function resolveComponentType(node, context, ssr = false) {
    const { tag } = node;
    // 1. dynamic component
    const isProp = node.tag === 'component' ? findProp(node, 'is') : findDir(node, 'is');
    if (isProp) {
        const exp = isProp.type === 6 /* ATTRIBUTE */
            ? isProp.value && createSimpleExpression(isProp.value.content, true)
            : isProp.exp;
        if (exp) {
            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                exp
            ]);
        }
    }
    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
        // built-ins are simply fallthroughs / have special handling during ssr
        // so we don't need to import their runtime equivalents
        if (!ssr)
            context.helper(builtIn);
        return builtIn;
    }
    // 5. user component (resolve)
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
    const { tag, loc: elementLoc } = node;
    const isComponent = node.tagType === 1 /* COMPONENT */;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    // patchFlag analysis
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
            if (!isComponent &&
                isEventHandler &&
                // omit the flag for click handlers because hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue' &&
                // omit onVnodeXXX hooks
                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasHydrationEventBinding = true;
            }
            if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
                hasVnodeHook = true;
            }
            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                    value.type === 8 /* COMPOUND_EXPRESSION */) &&
                    getConstantType(value, context) > 0)) {
                // skip if the prop is a cached handler or has constant value
                return;
            }
            if (name === 'ref') {
                hasRef = true;
            }
            else if (name === 'class' && !isComponent) {
                hasClassBinding = true;
            }
            else if (name === 'style' && !isComponent) {
                hasStyleBinding = true;
            }
            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
        }
        else {
            hasDynamicKeys = true;
        }
    };
    for (let i = 0; i < props.length; i++) {
        // static attribute
        const prop = props[i];
        if (prop.type === 6 /* ATTRIBUTE */) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === 'ref') {
                hasRef = true;
            }
            // skip :is on <component>
            if (name === 'is' && tag === 'component') {
                continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
        }
        else {
            // directives
            const { name, arg, exp, loc } = prop;
            const isBind = name === 'bind';
            const isOn = name === 'on';
            // skip v-slot - it is handled by its dedicated transform.
            if (name === 'slot') {
                if (!isComponent) {
                    context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, loc));
                }
                continue;
            }
            // skip v-once - it is handled by its dedicated transform.
            if (name === 'once') {
                continue;
            }
            // skip v-is and :is on <component>
            if (name === 'is' ||
                (isBind && tag === 'component' && isBindKey(arg, 'is'))) {
                continue;
            }
            // skip v-on in SSR compilation
            if (isOn && ssr) {
                continue;
            }
            // special case for v-bind and v-on with no argument
            if (!arg && (isBind || isOn)) {
                hasDynamicKeys = true;
                if (exp) {
                    if (properties.length) {
                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                        properties = [];
                    }
                    if (isBind) {
                        mergeArgs.push(exp);
                    }
                    else {
                        // v-on="obj" -> toHandlers(obj)
                        mergeArgs.push({
                            type: 14 /* JS_CALL_EXPRESSION */,
                            loc,
                            callee: context.helper(TO_HANDLERS),
                            arguments: [exp]
                        });
                    }
                }
                else {
                    context.onError(createCompilerError(isBind
                        ? 33 /* X_V_BIND_NO_EXPRESSION */
                        : 34 /* X_V_ON_NO_EXPRESSION */, loc));
                }
                continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(prop, node, context);
                !ssr && props.forEach(analyzePatchFlag);
                properties.push(...props);
                if (needRuntime) {
                    runtimeDirectives.push(prop);
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
                        directiveImportMap.set(prop, needRuntime);
                    }
                }
            }
            else {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
            }
        }
    }
    let propsExpression = undefined;
    // has v-bind="object" or v-on="object", wrap with mergeProps
    if (mergeArgs.length) {
        if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        }
        else {
            // single v-bind with nothing else - no need for a mergeProps call
            propsExpression = mergeArgs[0];
        }
    }
    else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    // patchFlag analysis
    if (hasDynamicKeys) {
        patchFlag |= 16 /* FULL_PROPS */;
    }
    else {
        if (hasClassBinding) {
            patchFlag |= 2 /* CLASS */;
        }
        if (hasStyleBinding) {
            patchFlag |= 4 /* STYLE */;
        }
        if (dynamicPropNames.length) {
            patchFlag |= 8 /* PROPS */;
        }
        if (hasHydrationEventBinding) {
            patchFlag |= 32 /* HYDRATE_EVENTS */;
        }
    }
    if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512 /* NEED_PATCH */;
    }
    return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames
    };
}
// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        // dynamic keys are always allowed
        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
            if (name === 'style' || name === 'class' || name.startsWith('on')) {
                mergeAsArray(existing, prop);
            }
            // unexpected duplicate, should have emitted error during parse
        }
        else {
            knownProps.set(name, prop);
            deduped.push(prop);
        }
    }
    return deduped;
}
function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
        existing.value.elements.push(incoming.value);
    }
    else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
}
function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
        // built-in directive with runtime
        dirArgs.push(context.helperString(runtime));
    }
    else {
        {
            // inject statement for resolving directive
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
    }
    const { loc } = dir;
    if (dir.exp)
        dirArgs.push(dir.exp);
    if (dir.arg) {
        if (!dir.exp) {
            dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
            propsNamesString += ', ';
    }
    return propsNamesString + `]`;
}

( true)
    ? Object.freeze({})
    : 0;
( true) ? Object.freeze([]) : 0;
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});

const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName
        ];
        if (slotProps) {
            slotArgs.push(slotProps);
        }
        if (children.length) {
            if (!slotProps) {
                slotArgs.push(`{}`);
            }
            slotArgs.push(createFunctionExpression([], children, false, false, loc));
        }
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
};
function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = undefined;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.value) {
                if (p.name === 'name') {
                    slotName = JSON.stringify(p.value.content);
                }
                else {
                    p.name = camelize(p.name);
                    nonNameProps.push(p);
                }
            }
        }
        else {
            if (p.name === 'bind' && isBindKey(p.arg, 'name')) {
                if (p.exp)
                    slotName = p.exp;
            }
            else {
                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                    p.arg.content = camelize(p.arg.content);
                }
                nonNameProps.push(p);
            }
        }
    }
    if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps);
        slotProps = props;
        if (directives.length) {
            context.onError(createCompilerError(35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
        }
    }
    return {
        slotName,
        slotProps
    };
}

const fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;
const transformOn = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(34 /* X_V_ON_NO_EXPRESSION */, loc));
    }
    let eventName;
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            const rawName = arg.content;
            // for all event listeners, auto convert it to camelCase. See issue #2249
            eventName = createSimpleExpression((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)), true, arg.loc);
        }
        else {
            // #2388
            eventName = createCompoundExpression([
                `${context.helperString(TO_HANDLER_KEY)}(`,
                arg,
                `)`
            ]);
        }
    }
    else {
        // already a compound expression.
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
    }
    // handler processing
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
        exp = undefined;
    }
    let shouldCache = context.cacheHandlers && !exp;
    if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
            validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || (shouldCache && isMemberExp)) {
            // wrap inline statement in a function expression
            exp = createCompoundExpression([
                `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                exp,
                hasMultipleStatements ? `}` : `)`
            ]);
        }
    }
    let ret = {
        props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
    };
    // apply extended compiler augmentor
    if (augmentor) {
        ret = augmentor(ret);
    }
    if (shouldCache) {
        // cache handlers so that it's always the same handler being passed down.
        // this avoids unnecessary re-renders when users use inline handlers on
        // components.
        ret.props[0].value = context.cache(ret.props[0].value);
    }
    return ret;
};

// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, node, context) => {
    const { exp, modifiers, loc } = dir;
    const arg = dir.arg;
    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
    }
    else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
    }
    // .prop is no longer necessary due to new patch behavior
    // .sync is replaced by v-model:arg
    if (modifiers.includes('camel')) {
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
                arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
            }
            else {
                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
        }
        else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
        }
    }
    if (!exp ||
        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {
        context.onError(createCompilerError(33 /* X_V_BIND_NO_EXPRESSION */, loc));
        return {
            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
        };
    }
    return {
        props: [createObjectProperty(arg, exp)]
    };
};

// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
    if (node.type === 0 /* ROOT */ ||
        node.type === 1 /* ELEMENT */ ||
        node.type === 11 /* FOR */ ||
        node.type === 10 /* IF_BRANCH */) {
        // perform the transform on node exit so that all expressions have already
        // been processed.
        return () => {
            const children = node.children;
            let currentContainer = undefined;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child)) {
                    hasText = true;
                    for (let j = i + 1; j < children.length; j++) {
                        const next = children[j];
                        if (isText(next)) {
                            if (!currentContainer) {
                                currentContainer = children[i] = {
                                    type: 8 /* COMPOUND_EXPRESSION */,
                                    loc: child.loc,
                                    children: [child]
                                };
                            }
                            // merge adjacent text node into current
                            currentContainer.children.push(` + `, next);
                            children.splice(j, 1);
                            j--;
                        }
                        else {
                            currentContainer = undefined;
                            break;
                        }
                    }
                }
            }
            if (!hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                    (node.type === 0 /* ROOT */ ||
                        (node.type === 1 /* ELEMENT */ &&
                            node.tagType === 0 /* ELEMENT */)))) {
                return;
            }
            // pre-convert text nodes into createTextVNode(text) calls to avoid
            // runtime normalization.
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                    const callArgs = [];
                    // createTextVNode defaults to single whitespace, so if it is a
                    // single space the code could be an empty call to save bytes.
                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                        callArgs.push(child);
                    }
                    // mark dynamic text with flag so it gets patched inside a block
                    if (!context.ssr &&
                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                        callArgs.push(1 /* TEXT */ +
                            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0));
                    }
                    children[i] = {
                        type: 12 /* TEXT_CALL */,
                        content: child,
                        loc: child.loc,
                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                    };
                }
            }
        };
    }
};

const seen = new WeakSet();
const transformOnce = (node, context) => {
    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
        if (seen.has(node)) {
            return;
        }
        seen.add(node);
        context.helper(SET_BLOCK_TRACKING);
        return () => {
            const cur = context.currentNode;
            if (cur.codegenNode) {
                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
            }
        };
    }
};

const transformModel = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
        context.onError(createCompilerError(40 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
        return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;
    // im SFC <script setup> inline mode, the exp may have been transformed into
    // _unref(exp)
    context.bindingMetadata[rawExp];
    const maybeRef = !true    /* SETUP_CONST */;
    if (!isMemberExpression(expString) && !maybeRef) {
        context.onError(createCompilerError(41 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
        return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression('modelValue', true);
    const eventName = arg
        ? isStaticExp(arg)
            ? `onUpdate:${arg.content}`
            : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
        assignmentExp = createCompoundExpression([
            `${eventArg} => (`,
            exp,
            ` = $event)`
        ]);
    }
    const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
    ];
    // modelModifiers: { foo: true, "bar-baz": true }
    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
        const modifiers = dir.modifiers
            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
            .join(`, `);
        const modifiersKey = arg
            ? isStaticExp(arg)
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
            : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));
    }
    return createTransformProps(props);
};
function createTransformProps(props = []) {
    return { props };
}

function getBaseTransformPreset(prefixIdentifiers) {
    return [
        [
            transformOnce,
            transformIf,
            transformFor,
            ...(( true)
                    ? [transformExpression]
                    : 0),
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
        ],
        {
            on: transformOn,
            bind: transformBind,
            model: transformModel
        }
    ];
}
// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === 'module';
    /* istanbul ignore if */
    {
        if (options.prefixIdentifiers === true) {
            onError(createCompilerError(45 /* X_PREFIX_ID_NOT_SUPPORTED */));
        }
        else if (isModuleMode) {
            onError(createCompilerError(46 /* X_MODULE_MODE_NOT_SUPPORTED */));
        }
    }
    const prefixIdentifiers = !true ;
    if (options.cacheHandlers) {
        onError(createCompilerError(47 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
    }
    if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(48 /* X_SCOPE_ID_NOT_SUPPORTED */));
    }
    const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) // user transforms
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
        )
    }));
    return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        prefixIdentifiers
    }));
}

const noopDirectiveTransform = () => ({ props: [] });




/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   "CREATE_SLOTS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   "IS_REF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   "OPEN_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   "WITH_CTX": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   "WITH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_SCOPE_ID),
/* harmony export */   "advancePositionWithClone": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   "assert": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   "baseCompile": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   "baseParse": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   "buildProps": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   "buildSlots": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   "createArrayExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   "createCompilerError": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   "createInterpolation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   "createRoot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   "createSequenceExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   "findDir": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   "findProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   "generate": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),
/* harmony export */   "hasDynamicKeyVBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   "injectProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   "isBindKey": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBindKey),
/* harmony export */   "isBuiltInType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   "isMemberExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   "isSimpleIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   "isStaticExp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   "isTemplateNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   "isText": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   "isVSlot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   "locStub": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   "noopDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   "processFor": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   "processIf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   "processSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   "transform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   "transformElement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   "transformExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   "transformModel": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   "transformOn": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   "traverseNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   "DOMDirectiveTransforms": () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   "DOMNodeTransforms": () => (/* binding */ DOMNodeTransforms),
/* harmony export */   "TRANSITION": () => (/* binding */ TRANSITION),
/* harmony export */   "TRANSITION_GROUP": () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   "V_MODEL_CHECKBOX": () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   "V_MODEL_DYNAMIC": () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   "V_MODEL_RADIO": () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   "V_MODEL_SELECT": () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   "V_MODEL_TEXT": () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   "V_ON_WITH_KEYS": () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   "V_ON_WITH_MODIFIERS": () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   "V_SHOW": () => (/* binding */ V_SHOW),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "createDOMCompilerError": () => (/* binding */ createDOMCompilerError),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parserOptions": () => (/* binding */ parserOptions),
/* harmony export */   "transformStyle": () => (/* binding */ transformStyle)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");




const V_MODEL_RADIO = Symbol(( true) ? `vModelRadio` : 0);
const V_MODEL_CHECKBOX = Symbol(( true) ? `vModelCheckbox` : 0);
const V_MODEL_TEXT = Symbol(( true) ? `vModelText` : 0);
const V_MODEL_SELECT = Symbol(( true) ? `vModelSelect` : 0);
const V_MODEL_DYNAMIC = Symbol(( true) ? `vModelDynamic` : 0);
const V_ON_WITH_MODIFIERS = Symbol(( true) ? `vOnModifiersGuard` : 0);
const V_ON_WITH_KEYS = Symbol(( true) ? `vOnKeysGuard` : 0);
const V_SHOW = Symbol(( true) ? `vShow` : 0);
const TRANSITION = Symbol(( true) ? `Transition` : 0);
const TRANSITION_GROUP = Symbol(( true) ? `TransitionGroup` : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

/* eslint-disable no-restricted-globals */
let decoder;
function decodeHtmlBrowser(raw) {
    (decoder || (decoder = document.createElement('div'))).innerHTML = raw;
    return decoder.textContent;
}

const isRawTextContainer = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
    isNativeTag: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `Transition`)) {
            return TRANSITION;
        }
        else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* HTML */;
        if (parent && ns === 2 /* MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* HTML */;
            }
        }
        else if (parent && ns === 1 /* SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* HTML */;
            }
        }
        if (ns === 0 /* HTML */) {
            if (tag === 'svg') {
                return 1 /* SVG */;
            }
            if (tag === 'math') {
                return 2 /* MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* RAWTEXT */;
            }
        }
        return 0 /* DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* DIRECTIVE */,
                    name: `bind`,
                    arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}
const DOMErrorMessages = {
    [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true), exp
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);
            if (type) {
                if (type.type === 7 /* DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            ( true) && checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                ( true) && checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            ( true) && checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
const isKeyboardEvent = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true)
        : key.type !== 4 /* SIMPLE_EXPRESSION */
            ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
            key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)
                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true)
                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const warnTransitionChildren = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 1 /* COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (node.children.length && hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* FOR */ ||
        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        node.tagType === 0 /* ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...(( true) ? [warnTransitionChildren] : 0)
];
const DOMDirectiveTransforms = {
    cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: null 
    }));
}
function parse(template, options = {}) {
    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}




/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");


const targetMap = new WeakMap();
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);
function isEffect(fn) {
    return fn && fn._isEffect === true;
}
function effect(fn, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ) {
    if (isEffect(fn)) {
        fn = fn.raw;
    }
    const effect = createReactiveEffect(fn, options);
    if (!options.lazy) {
        effect();
    }
    return effect;
}
function stop(effect) {
    if (effect.active) {
        cleanup(effect);
        if (effect.options.onStop) {
            effect.options.onStop();
        }
        effect.active = false;
    }
}
let uid = 0;
function createReactiveEffect(fn, options) {
    const effect = function reactiveEffect() {
        if (!effect.active) {
            return options.scheduler ? undefined : fn();
        }
        if (!effectStack.includes(effect)) {
            cleanup(effect);
            try {
                enableTracking();
                effectStack.push(effect);
                activeEffect = effect;
                return fn();
            }
            finally {
                effectStack.pop();
                resetTracking();
                activeEffect = effectStack[effectStack.length - 1];
            }
        }
    };
    effect.id = uid++;
    effect.allowRecurse = !!options.allowRecurse;
    effect._isEffect = true;
    effect.active = true;
    effect.raw = fn;
    effect.deps = [];
    effect.options = options;
    return effect;
}
function cleanup(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (!shouldTrack || activeEffect === undefined) {
        return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
        depsMap.set(key, (dep = new Set()));
    }
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (( true) && activeEffect.options.onTrack) {
            activeEffect.options.onTrack({
                effect: activeEffect,
                target,
                type,
                key
            });
        }
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    const effects = new Set();
    const add = (effectsToAdd) => {
        if (effectsToAdd) {
            effectsToAdd.forEach(effect => {
                if (effect !== activeEffect || effect.allowRecurse) {
                    effects.add(effect);
                }
            });
        }
    };
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        depsMap.forEach(add);
    }
    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                add(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            add(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* ADD */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    add(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        add(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
                    // new index added to array -> length changes
                    add(depsMap.get('length'));
                }
                break;
            case "delete" /* DELETE */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    add(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        add(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* SET */:
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                    add(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const run = (effect) => {
        if (( true) && effect.options.onTrigger) {
            effect.options.onTrigger({
                effect,
                target,
                key,
                type,
                newValue,
                oldValue,
                oldTarget
            });
        }
        if (effect.options.scheduler) {
            effect.options.scheduler(effect);
        }
        else {
            effect();
        }
    };
    effects.forEach(run);
}

const isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = {};
['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function (...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get" /* GET */, i + '');
        }
        // we run the method using the original args first (which may be reactive)
        const res = method.apply(arr, args);
        if (res === -1 || res === false) {
            // if that didn't work, run it again using raw values.
            return method.apply(arr, args.map(toRaw));
        }
        else {
            return res;
        }
    };
});
['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function (...args) {
        pauseTracking();
        const res = method.apply(this, args);
        resetTracking();
        return res;
    };
});
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */ &&
            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key)
            ? builtInSymbols.has(key)
            : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (isRef(res)) {
            // ref unwrapping - does not apply for Array + integer key.
            const shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
            return shouldUnwrap ? res.value : res;
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        const oldValue = target[key];
        if (!shallow) {
            value = toRaw(value);
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)
            ? Number(key) < target.length
            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((true)) {
            console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    },
    deleteProperty(target, key) {
        if ((true)) {
            console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    }
};
const shallowReactiveHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "get" /* GET */, key);
    }
    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);
    const { has } = getProto(rawTarget);
    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "has" /* HAS */, key);
    }
    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* RAW */];
    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( true)
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
            ? new Map(target)
            : new Set(target)
        : 0;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((true)) {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* DELETE */ ? false : this;
    };
}
const mutableInstrumentations = {
    get(key) {
        return get$1(this, key);
    },
    get size() {
        return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
};
const shallowInstrumentations = {
    get(key) {
        return get$1(this, key, false, true);
    },
    get size() {
        return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
};
const readonlyInstrumentations = {
    get(key) {
        return get$1(this, key, true);
    },
    get size() {
        return size(this, true);
    },
    has(key) {
        return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add" /* ADD */),
    set: createReadonlyMethod("set" /* SET */),
    delete: createReadonlyMethod("delete" /* DELETE */),
    clear: createReadonlyMethod("clear" /* CLEAR */),
    forEach: createForEach(true, false)
};
const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
iteratorMethods.forEach(method => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
});
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */) {
            return target;
        }
        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */;
        default:
            return 0 /* INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
        ? 0 /* INVALID */
        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (target && target["__v_isReadonly" /* IS_READONLY */]) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        if ((true)) {
            console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const proxyMap = isReadonly ? readonlyMap : reactiveMap;
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only a whitelist of value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* RAW */]);
    }
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    return ((observed && toRaw(observed["__v_raw" /* RAW */])) || observed);
}
function markRaw(value) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip" /* SKIP */, true);
    return value;
}

const convert = (val) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) ? reactive(val) : val;
function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value);
}
function shallowRef(value) {
    return createRef(value, true);
}
class RefImpl {
    constructor(_rawValue, _shallow = false) {
        this._rawValue = _rawValue;
        this._shallow = _shallow;
        this.__v_isRef = true;
        this._value = _shallow ? _rawValue : convert(_rawValue);
    }
    get value() {
        track(toRaw(this), "get" /* GET */, 'value');
        return this._value;
    }
    set value(newVal) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(toRaw(newVal), this._rawValue)) {
            this._rawValue = newVal;
            this._value = this._shallow ? newVal : convert(newVal);
            trigger(toRaw(this), "set" /* SET */, 'value', newVal);
        }
    }
}
function createRef(rawValue, shallow = false) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
function triggerRef(ref) {
    trigger(toRaw(ref), "set" /* SET */, 'value', ( true) ? ref.value : 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.__v_isRef = true;
        const { get, set } = factory(() => track(this, "get" /* GET */, 'value'), () => trigger(this, "set" /* SET */, 'value'));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (( true) && !isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key) {
        this._object = _object;
        this._key = _key;
        this.__v_isRef = true;
    }
    get value() {
        return this._object[this._key];
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key) {
    return isRef(object[key])
        ? object[key]
        : new ObjectRefImpl(object, key);
}

class ComputedRefImpl {
    constructor(getter, _setter, isReadonly) {
        this._setter = _setter;
        this._dirty = true;
        this.__v_isRef = true;
        this.effect = effect(getter, {
            lazy: true,
            scheduler: () => {
                if (!this._dirty) {
                    this._dirty = true;
                    trigger(toRaw(this), "set" /* SET */, 'value');
                }
            }
        });
        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
    }
    get value() {
        if (this._dirty) {
            this._value = this.effect();
            this._dirty = false;
        }
        track(toRaw(this), "get" /* GET */, 'value');
        return this._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions) {
    let getter;
    let setter;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
        getter = getterOrOptions;
        setter = ( true)
            ? () => {
                console.warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    return new ComputedRefImpl(getter, setter, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions) || !getterOrOptions.set);
}




/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmit": () => (/* binding */ defineEmit),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "useContext": () => (/* binding */ useContext),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");





const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((true)) {
        const info = ErrorTypeStrings[type];
        if (contextVNode) {
            pushWarningContext(contextVNode);
        }
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
            popWarningContext();
        }
        // crash in dev by default so it's more noticeable
        if (throwInDev) {
            throw err;
        }
        else {
            console.error(err);
        }
    }
    else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(job) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    const jobId = getId(job);
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < jobId ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!queue.length ||
        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        job !== currentPreFlushParentJob) {
        const pos = findInsertionIndex(job);
        if (pos > -1) {
            queue.splice(pos, 0, job);
        }
        else {
            queue.push(job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > -1) {
        queue.splice(i, 1);
    }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
        if (!activeQueue ||
            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
            pendingQueue.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingQueue.push(...cb);
    }
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        if ((true)) {
            seen = seen || new Map();
        }
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if ((true)) {
                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);
            }
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((true)) {
            seen = seen || new Map();
        }
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if ((true)) {
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);
            }
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((true)) {
        seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort((a, b) => getId(a) - getId(b));
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job) {
                if ((true)) {
                    checkRecursiveUpdates(seen, job);
                }
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length || pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            throw new Error(`Maximum recursive updates exceeded. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((true)) {
    const globalObject = typeof __webpack_require__.g !== 'undefined'
        ? __webpack_require__.g
        : typeof self !== 'undefined'
            ? self
            : typeof window !== 'undefined'
                ? window
                : {};
    globalObject.__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
    };
}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, component) {
    if (!component) {
        warn(`HMR API usage is out of date.\n` +
            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +
            `dependency that handles Vue SFC compilation.`);
        component = {};
    }
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        component: isClassComponent(component) ? component.__vccOpts : component,
        instances: new Set()
    });
    return true;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record)
        return;
    if (newRender)
        record.component.render = newRender;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    Array.from(record.instances).forEach(instance => {
        if (newRender) {
            instance.render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    const { component, instances } = record;
    if (!hmrDirtyComponents.has(component)) {
        // 1. Update existing comp definition to match new one
        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(component, newComp);
        for (const key in component) {
            if (!(key in newComp)) {
                delete component[key];
            }
        }
        // 2. Mark component dirty. This forces the renderer to replace the component
        // on patch.
        hmrDirtyComponents.add(component);
        // 3. Make sure to unmark the component after the reload.
        queuePostFlushCb(() => {
            hmrDirtyComponents.delete(component);
        });
    }
    Array.from(instances).forEach(instance => {
        if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    });
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
function setDevtoolsHook(hook) {
    devtools = hook;
}
function devtoolsInitApp(app, version) {
    // TODO queue if devtools is undefined
    if (!devtools)
        return;
    devtools.emit("app:init" /* APP_INIT */, app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    if (!devtools)
        return;
    devtools.emit("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
function createDevtoolsComponentHook(hook) {
    return (component) => {
        if (!devtools)
            return;
        devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
function devtoolsComponentEmit(component, event, params) {
    if (!devtools)
        return;
    devtools.emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

function emit(instance, event, ...rawArgs) {
    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if ((true)) {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions)) {
                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
                    warn(`Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
                }
            }
            else {
                const validator = emitsOptions[event];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) {
                        warn(`Invalid event arguments: event validation failed for event "${event}".`);
                    }
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => a.trim());
        }
        else if (number) {
            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
        }
    }
    if (true) {
        devtoolsComponentEmit(instance, event, args);
    }
    if ((true)) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
            warn(`Event "${lowerCaseEvent}" is emitted in component ` +
                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                `Note that HTML attributes are case-insensitive and you cannot use ` +
                `v-on to listen to camelCase events when using in-DOM templates. ` +
                `You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
        }
    }
    // convert handler name to camelCase. See issue #2249
    let handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event));
    let handler = props[handlerName];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event));
        handler = props[handlerName];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            (instance.emitted = {})[handlerName] = true;
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    if (!appContext.deopt && comp.__emits !== undefined) {
        return comp.__emits;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendEmits = (raw) => {
            hasExtends = true;
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizeEmitsOptions(raw, appContext, true));
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        return (comp.__emits = null);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
    }
    return (comp.__emits = normalized);
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, '');
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
function setCurrentRenderingInstance(instance) {
    currentRenderingInstance = instance;
}
/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx } = instance;
    let result;
    currentRenderingInstance = instance;
    if ((true)) {
        accessedAttrs = false;
    }
    try {
        let fallthroughAttrs;
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (( true) && attrs === props) {
                markAttrsAccessed();
            }
            result = normalizeVNode(render.length > 1
                ? render(props, ( true)
                    ? {
                        get attrs() {
                            markAttrsAccessed();
                            return attrs;
                        },
                        slots,
                        emit
                    }
                    : 0)
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
        // attr merging
        // in dev mode, comments are preserved, and it's possible for a template
        // to have comments along side the root element which makes it a fragment
        let root = result;
        let setRoot = undefined;
        if (( true) &&
            result.patchFlag > 0 &&
            result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
            ;
            [root, setRoot] = getChildRoot(result);
        }
        if (Component.inheritAttrs !== false && fallthroughAttrs) {
            const keys = Object.keys(fallthroughAttrs);
            const { shapeFlag } = root;
            if (keys.length) {
                if (shapeFlag & 1 /* ELEMENT */ ||
                    shapeFlag & 6 /* COMPONENT */) {
                    if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
                        // If a v-model listener (onUpdate:xxx) has a corresponding declared
                        // prop, it indicates this component expects to handle v-model and
                        // it should not fallthrough.
                        // related: #1543, #1643, #1989
                        fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                    }
                    root = cloneVNode(root, fallthroughAttrs);
                }
                else if (( true) && !accessedAttrs && root.type !== Comment) {
                    const allAttrs = Object.keys(attrs);
                    const eventAttrs = [];
                    const extraAttrs = [];
                    for (let i = 0, l = allAttrs.length; i < l; i++) {
                        const key = allAttrs[i];
                        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                            // ignore v-model handlers when they fail to fallthrough
                            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                                // remove `on`, lowercase first letter to reflect event casing
                                // accurately
                                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                            }
                        }
                        else {
                            extraAttrs.push(key);
                        }
                    }
                    if (extraAttrs.length) {
                        warn(`Extraneous non-props attributes (` +
                            `${extraAttrs.join(', ')}) ` +
                            `were passed to component but could not be automatically inherited ` +
                            `because component renders fragment or text root nodes.`);
                    }
                    if (eventAttrs.length) {
                        warn(`Extraneous non-emits event listeners (` +
                            `${eventAttrs.join(', ')}) ` +
                            `were passed to component but could not be automatically inherited ` +
                            `because component renders fragment or text root nodes. ` +
                            `If the listener is intended to be a component custom event listener only, ` +
                            `declare it using the "emits" option.`);
                    }
                }
            }
        }
        // inherit directives
        if (vnode.dirs) {
            if (( true) && !isElementRoot(root)) {
                warn(`Runtime directive used on component with non-element root node. ` +
                    `The directives will not function as intended.`);
            }
            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        // inherit transition data
        if (vnode.transition) {
            if (( true) && !isElementRoot(root)) {
                warn(`Component inside <Transition> renders non-element root node ` +
                    `that cannot be animated.`);
            }
            root.transition = vnode.transition;
        }
        if (( true) && setRoot) {
            setRoot(root);
        }
        else {
            result = root;
        }
    }
    catch (err) {
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    currentRenderingInstance = null;
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & 6 /* COMPONENT */ ||
        vnode.shapeFlag & 1 /* ELEMENT */ ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {
        return true;
    }
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary
};
// Force-casted public typing for h and TSX props inference
const Suspense = (SuspenseImpl
    );
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            const onPending = n2.props && n2.props.onPending;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onPending)) {
                onPending();
            }
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if ( true && !hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((true)) {
                if (!resume && !suspense.pendingBranch) {
                    throw new Error(`suspense.resolve() is called without a pending branch.`);
                }
                if (suspense.isUnmounted) {
                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                }
            }
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            const onResolve = vnode.props && vnode.props.onResolve;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onResolve)) {
                onResolve();
            }
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            const onFallback = vnode.props && vnode.props.onFallback;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onFallback)) {
                onFallback();
            }
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            suspense.isInFallback = true;
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((true)) {
                    pushWarningContext(vnode);
                }
                handleSetupResult(instance, asyncSetupResult);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((true)) {
                    popWarningContext();
                }
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    let content;
    let fallback;
    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {
        content = normalizeSuspenseSlot(children.default);
        fallback = normalizeSuspenseSlot(children.fallback);
    }
    else {
        content = normalizeSuspenseSlot(children);
        fallback = normalizeVNode(null);
    }
    return {
        content,
        fallback
    };
}
function normalizeSuspenseSlot(s) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        s = s();
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (( true) && !singleChild) {
            warn(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
    }
    return normalizeVNode(s);
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

let isRenderingCompiledSlot = 0;
const setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);
/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback) {
    let slot = slots[name];
    if (( true) && slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
            `function. You need to mark this component with $dynamic-slots in the ` +
            `parent template.`);
        slot = () => [];
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    isRenderingCompiledSlot++;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
        ? 64 /* STABLE_FRAGMENT */
        : -2 /* BAIL */);
    isRenderingCompiledSlot--;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment)
            return false;
        if (child.type === Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * Wrap a slot function to memoize current rendering instance
 * @private
 */
function withCtx(fn, ctx = currentRenderingInstance) {
    if (!ctx)
        return fn;
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we need to push a null block to
        // avoid that. This isn't necessary if rendering a compiled `<slot>`.
        if (!isRenderingCompiledSlot) {
            openBlock(true /* null block that disables tracking */);
        }
        const owner = currentRenderingInstance;
        setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(owner);
        if (!isRenderingCompiledSlot) {
            closeBlock();
        }
        return res;
    };
    renderFnWithContext._c = true;
    return renderFnWithContext;
}

// SFC scoped style ID management.
let currentScopeId = null;
const scopeIdStack = [];
/**
 * @private
 */
function pushScopeId(id) {
    scopeIdStack.push((currentScopeId = id));
}
/**
 * @private
 */
function popScopeId() {
    scopeIdStack.pop();
    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;
}
/**
 * @private
 */
function withScopeId(id) {
    return ((fn) => withCtx(function () {
        pushScopeId(id);
        const res = fn.apply(this, arguments);
        popScopeId();
        return res;
    }));
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
    setFullProps(instance, rawProps, props, attrs);
    // validation
    if ((true)) {
        validateProps(props, instance);
    }
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const [options] = instance.propsOptions;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(( true) &&
        (instance.type.__hmrId ||
            (instance.parent && instance.parent.type.__hmrId))) &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
                        attrs[key] = value;
                    }
                    else {
                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);
                    }
                }
                else {
                    attrs[key] = value;
                }
            }
        }
    }
    else {
        // full props update.
        setFullProps(instance, rawProps, props, attrs);
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawProps || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ, key, undefined, instance);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key)) {
                    delete attrs[key];
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set" /* SET */, '$attrs');
    if (( true) && rawProps) {
        validateProps(props, instance);
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    if (rawProps) {
        for (const key in rawProps) {
            const value = rawProps[key];
            // key, ref are reserved and never passed down
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                continue;
            }
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {
                props[camelKey] = value;
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                // Any non-declared (either as a prop or an emitted event) props are put
                // into a separate `attrs` object for spreading. Make sure to preserve
                // original key casing
                attrs[key] = value;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);
        }
    }
}
function resolvePropValue(options, props, key, value, instance) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
                setCurrentInstance(instance);
                value = defaultValue(props);
                setCurrentInstance(null);
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(props, key) && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    if (!appContext.deopt && comp.__props) {
        return comp.__props;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendProps = (raw) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
            if (keys)
                needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        return (comp.__props = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
                warn(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
            warn(`invalid props options`, raw);
        }
        for (const key in raw) {
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    return (comp.__props = [normalized, needCastKeys]);
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((true)) {
        warn(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
        for (let i = 0, len = expectedTypes.length; i < len; i++) {
            if (isSameType(expectedTypes[i], type)) {
                return i;
            }
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(props, instance) {
    const rawValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, rawValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawValues, key));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
    }
    else if (expectedType === 'Array') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(', ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                setCurrentInstance(null);
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((true)) {
        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn(`${apiName} is called when there is no active component instance to be ` +
            `associated with. ` +
            `Lifecycle injection APIs can only be used during execution of setup().` +
            (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`
                ));
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR
!isInSSRComponentSetup && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
const onErrorCaptured = (hook, target = currentInstance) => {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
};

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ, instance = currentInstance) {
    if (( true) && !cb) {
        if (immediate !== undefined) {
            warn(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    let getter;
    let forceTrigger = false;
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
        getter = () => source.value;
        forceTrigger = !!source._shallow;
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
        getter = () => source;
        deep = true;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
        getter = () => source.map(s => {
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
                return s.value;
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
                return traverse(s);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */, [
                    instance && instance.proxy
                ]);
            }
            else {
                ( true) && warnInvalidSource(s);
            }
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */, [
                instance && instance.proxy
            ]);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);
            };
        }
    }
    else {
        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        ( true) && warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    const onInvalidate = (fn) => {
        cleanup = runner.options.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    let oldValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!runner.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = runner();
            if (deep || forceTrigger || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onInvalidate
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            runner();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job;
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        scheduler = () => {
            if (!instance || instance.isMounted) {
                queuePreFlushCb(job);
            }
            else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
            }
        };
    }
    const runner = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(getter, {
        lazy: true,
        onTrack,
        onTrigger,
        scheduler
    });
    recordInstanceBoundEffect(runner, instance);
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = runner();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(runner, instance && instance.suspense);
    }
    else {
        runner();
    }
    return () => {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(runner);
        if (instance) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.effects, runner);
        }
    };
}
// this.$watch
function instanceWatch(source, cb, options) {
    const publicThis = this.proxy;
    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)
        ? () => publicThis[source]
        : source.bind(publicThis);
    return doWatch(getter, cb.bind(publicThis), options, this);
}
function traverse(value, seen = new Set()) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || seen.has(value)) {
        return value;
    }
    seen.add(value);
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        traverse(value.value, seen);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            // warn multiple elements
            if (( true) && children.length > 1) {
                warn('<transition> can only be used on a single element or component. Use ' +
                    '<transition-group> for lists.');
            }
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
            const { mode } = rawProps;
            // check mode
            if (( true) && mode && !['in-out', 'out-in', 'default'].includes(mode)) {
                warn(`invalid <transition> mode: ${mode}`);
            }
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out') {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                hook(el, done);
                if (hook.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                onLeave(el, done);
                if (onLeave.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment) {
            ret.push(child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* BAIL */;
        }
    }
    return ret;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const cache = new Map();
        const keys = new Set();
        let current = null;
        const instance = getCurrentInstance();
        const parentSuspense = instance.suspense;
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((true)) {
                    warn(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return rawVNode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
    }
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
    }
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {
    if (( true) && currentInstance) {
        warn(`Slot "${key}" invoked outside of the render function: ` +
            `this will not track dependencies used in the slot. ` +
            `Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(props));
}, ctx);
const normalizeObjectSlots = (rawSlots, slots) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if ((true)) {
                warn(`Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (( true) && !isKeepAlive(instance.vnode)) {
        warn(`Non-function value encountered for default slot. ` +
            `Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            instance.slots = children;
            // make compiler marker non-enumerable
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (( true) && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
            }
            else if (type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
const isBuiltInDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');
function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
        warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( true) && warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        const hook = binding.dir[name];
        if (hook) {
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
        }
    }
}

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
            errorHandler: undefined,
            warnHandler: undefined
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null)
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
            ( true) && warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((true)) {
                    warn(`app.config cannot be replaced. Modify individual options instead.`);
                }
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( true) && warn(`Plugin has already been applied to target app.`);
                }
                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((true)) {
                    warn(`A plugin must either be a function or an object with an "install" ` +
                        `function.`);
                }
                return app;
            },
            mixin(mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                        // global mixin with props/emits de-optimizes props/emits
                        // normalization caching.
                        if (mixin.props || mixin.emits) {
                            context.deopt = true;
                        }
                    }
                    else if ((true)) {
                        warn('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                }
                else if ((true)) {
                    warn('Mixins are only available in builds supporting Options API');
                }
                return app;
            },
            component(name, component) {
                if ((true)) {
                    validateComponentName(name, context.config);
                }
                if (!component) {
                    return context.components[name];
                }
                if (( true) && context.components[name]) {
                    warn(`Component "${name}" has already been registered in target app.`);
                }
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((true)) {
                    validateDirectiveName(name);
                }
                if (!directive) {
                    return context.directives[name];
                }
                if (( true) && context.directives[name]) {
                    warn(`Directive "${name}" has already been registered in target app.`);
                }
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((true)) {
                        context.reload = () => {
                            render(cloneVNode(vnode), rootContainer);
                        };
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (true) {
                        devtoolsInitApp(app, version);
                    }
                    return vnode.component.proxy;
                }
                else if ((true)) {
                    warn(`App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (true) {
                        devtoolsUnmountApp(app);
                    }
                    delete app._container.__vue_app__;
                }
                else if ((true)) {
                    warn(`Cannot unmount an app that is not mounted.`);
                }
            },
            provide(key, value) {
                if (( true) && key in context.provides) {
                    warn(`App already provides property with key "${String(key)}". ` +
                        `It will be overwritten with the new value.`);
                }
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        });
        return app;
    };
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (( true) && !container.hasChildNodes()) {
            warn(`Attempting to hydrate existing markup but container is empty. ` +
                `Performing full mount instead.`);
            patch(null, vnode, container);
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, isFragmentStart);
        const { type, ref, shapeFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    nextNode = onMismatch();
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( true) &&
                            warn(`Hydration text mismatch:` +
                                `\n- Client: ${JSON.stringify(node.data)}` +
                                `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case Static:
                if (domType !== 1 /* ELEMENT */) {
                    nextNode = onMismatch();
                }
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children += nextNode.outerHTML;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type !== node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);
                    }
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    const container = parentNode(node);
                    const hydrateComponent = () => {
                        mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    };
                    // async component
                    const loadAsync = vnode.type.__asyncLoader;
                    if (loadAsync) {
                        loadAsync().then(hydrateComponent);
                    }
                    else {
                        hydrateComponent();
                    }
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);
                }
                else if ((true)) {
                    warn('Invalid HostVNode type:', type, `(${typeof type})`);
                }
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { props, patchFlag, shapeFlag, dirs } = vnode;
        // skip props & children if this is hoisted static nodes
        if (patchFlag !== -1 /* HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (!optimized ||
                    (patchFlag & 16 /* FULL_PROPS */ ||
                        patchFlag & 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                            patchProp(el, key, null, props[key]);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (( true) && !hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: ` +
                            `server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( true) &&
                        warn(`Hydration text content mismatch in <${vnode.type}>:\n` +
                            `- Client: ${el.textContent}\n` +
                            `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);
            }
            else {
                hasMismatch = true;
                if (( true) && !hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, isFragment) => {
        hasMismatch = true;
        ( true) &&
            warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
                ? `(text)`
                : isComment(node) && node.data === '['
                    ? `(start of fragment)`
                    : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    /* eslint-disable no-restricted-globals */
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    /* eslint-enable no-restricted-globals */
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    let needWarn = false;
    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {
        needWarn = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {
        needWarn = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (( true) && needWarn) {
        console.warn(`You are running the esm-bundler build of Vue. It is recommended to ` +
            `configure your bundler to explicitly replace feature flag globals ` +
            `with boolean literals to get proper tree-shaking in the final bundle. ` +
            `See http://link.vuejs.org/feature-flags for more details.`);
    }
}

// implementation, close to no-op
function defineComponent(options) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest = loader()
                .catch(err => {
                err = err instanceof Error ? err : new Error(String(err));
                if (userOnError) {
                    return new Promise((resolve, reject) => {
                        const userRetry = () => resolve(retry());
                        const userFail = () => reject(err);
                        userOnError(err, userRetry, userFail, retries + 1);
                    });
                }
                else {
                    throw err;
                }
            })
                .then((comp) => {
                if (thisRequest !== pendingRequest && pendingRequest) {
                    return pendingRequest;
                }
                if (( true) && !comp) {
                    warn(`Async component loader resolved to undefined. ` +
                        `If you are using retry(), make sure to return its return value.`);
                }
                // interop module default
                if (comp &&
                    (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                    comp = comp.default;
                }
                if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
                    throw new Error(`Invalid async component load result: ${comp}`);
                }
                resolvedComp = comp;
                return comp;
            })));
    };
    return defineComponent({
        __asyncLoader: load,
        name: 'AsyncComponentWrapper',
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (false )) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref, props, children } }) {
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}

const prodEffectOptions = {
    scheduler: queueJob,
    // #1801, #2043 component render effects should allow recursive updates
    allowRecurse: true
};
function createDevEffectOptions(instance) {
    return {
        scheduler: queueJob,
        allowRecurse: true,
        onTrack: instance.rtc ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e) : void 0,
        onTrigger: instance.rtg ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e) : void 0
    };
}
const queuePostRenderEffect = queueEffectWithSuspense
    ;
const setRef = (rawRef, oldRawRef, parentSuspense, vnode) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode));
        return;
    }
    let value;
    if (!vnode || isAsyncWrapper(vnode)) {
        value = null;
    }
    else {
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            value = vnode.component.exposed || vnode.component.proxy;
        }
        else {
            value = vnode.el;
        }
    }
    const { i: owner, r: ref } = rawRef;
    if (( true) && !owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
            `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // unset old ref
    if (oldRef != null && oldRef !== ref) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
            oldRef.value = null;
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref)) {
        const doSet = () => {
            refs[ref] = value;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                setupState[ref] = value;
            }
        };
        // #1789: for non-null values, set them after render
        // null values means this is unmount and it should not overwrite another
        // ref with the same key
        if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
        }
        else {
            doSet();
        }
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
        const doSet = () => {
            ref.value = value;
        };
        if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
        }
        else {
            doSet();
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
    }
    else if ((true)) {
        warn('Invalid template ref type:', value, `(${typeof value})`);
    }
};
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    if (true) {
        const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
        target.__VUE__ = true;
        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((true)) {
                    patchStaticNode(n1, n2, container, isSVG);
                }
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                }
                else if ((true)) {
                    warn('Invalid VNode type:', type, `(${typeof type})`);
                }
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;
        if (false /* HOISTED */) {}
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);
            // mount children first, since some props may rely on child content
            // being already rendered, e.g. `<select value>`
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || !!vnode.dynamicChildren);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                for (const key in props) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            // scopeId
            setScopeId(el, scopeId, vnode, parentComponent);
        }
        if (true) {
            Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false
            });
            Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false
            });
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, scopeId, vnode, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (parentComponent) {
            const treeOwnerId = parentComponent.type.__scopeId;
            // vnode's own scopeId and the current patched component's scopeId is
            // different - this is a slot content node.
            if (treeOwnerId && treeOwnerId !== scopeId) {
                hostSetScopeId(el, treeOwnerId + '-s');
            }
            let subTree = parentComponent.subTree;
            if (( true) && subTree.type === Fragment) {
                subTree =
                    filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
                setScopeId(el, parentComponent.vnode.scopeId, parentComponent.vnode, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        let vnodeHook;
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev ||
                            (hostForcePatchProp && hostForcePatchProp(el, key))) {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);
            if (( true) && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
            }
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            oldVNode.type === Fragment ||
                // - In the case of different nodes, there is going to be a replacement
                // which also requires the correct parent container
                !isSameVNodeType(oldVNode, newVNode) ||
                // - In the case of a component, it could contain anything.
                oldVNode.shapeFlag & 6 /* COMPONENT */ ||
                oldVNode.shapeFlag & 64 /* TELEPORT */
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                // empty string is not valid prop
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev ||
                    (hostForcePatchProp && hostForcePatchProp(el, key))) {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren } = n2;
        if (patchFlag > 0) {
            optimized = true;
        }
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);
                if (( true) && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2);
                }
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (( true) && instance.type.__hmrId) {
            registerHMR(instance);
        }
        if ((true)) {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
        }
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        if ((true)) {
            startMeasure(instance, `init`);
        }
        setupComponent(instance);
        if ((true)) {
            endMeasure(instance, `init`);
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((true)) {
            popWarningContext();
            endMeasure(instance, `mount`);
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((true)) {
                    pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if ((true)) {
                    popWarningContext();
                }
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect runner.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        // create reactive effect for rendering
        instance.update = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(function componentEffect() {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                // beforeMount hook
                if (bm) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
                }
                // onVnodeBeforeMount
                if ((vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const subTree = (instance.subTree = renderComponentRoot(instance));
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                if (el && hydrateNode) {
                    if ((true)) {
                        startMeasure(instance, `hydrate`);
                    }
                    // vnode has adopted host node - perform hydration instead of mount.
                    hydrateNode(initialVNode.el, subTree, instance, parentSuspense);
                    if ((true)) {
                        endMeasure(instance, `hydrate`);
                    }
                }
                else {
                    if ((true)) {
                        startMeasure(instance, `patch`);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((true)) {
                        endMeasure(instance, `patch`);
                    }
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if ((vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => {
                        invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
                    }, parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                const { a } = instance;
                if (a &&
                    initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    queuePostRenderEffect(a, parentSuspense);
                }
                instance.isMounted = true;
                if (true) {
                    devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((true)) {
                    pushWarningContext(next || instance.vnode);
                }
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((true)) {
                    startMeasure(instance, `patch`);
                }
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((true)) {
                    endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => {
                        invokeVNodeHook(vnodeHook, parent, next, vnode);
                    }, parentSuspense);
                }
                if (true) {
                    devtoolsComponentUpdated(instance);
                }
                if ((true)) {
                    popWarningContext();
                }
            }
        }, ( true) ? createDevEffectOptions(instance) : 0);
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children);
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {
                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    }
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, null);
        }
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        let vnodeHook;
        if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === Fragment &&
                (patchFlag & 128 /* KEYED_FRAGMENT */ ||
                    patchFlag & 256 /* UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            // an unmounted teleport should always remove its children if not disabled
            if (shapeFlag & 64 /* TELEPORT */ &&
                (doRemove || !isTeleportDisabled(vnode.props))) {
                vnode.type.remove(vnode, internals);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (( true) && instance.type.__hmrId) {
            unregisterHMR(instance);
        }
        const { bum, effects, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
        }
        if (effects) {
            for (let i = 0; i < effects.length; i++) {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(effects[i]);
            }
        }
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(update);
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (true) {
            devtoolsComponentRemoved(instance);
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always moved so that need inherit el form previous nodes
 * to ensure correct moved position.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (( true) && c2.type === Comment && !c2.el) {
                c2.el = c1.el;
            }
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = ((u + v) / 2) | 0;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
        if (!select) {
            ( true) &&
                warn(`Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`);
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( true) &&
                    warn(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`);
            }
            return target;
        }
    }
    else {
        if (( true) && !targetSelector && !isTeleportDisabled(props)) {
            warn(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        const { shapeFlag, children } = n2;
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( true)
                ? createComment('teleport start')
                : 0);
            const mainAnchor = (n2.anchor = ( true)
                ? createComment('teleport end')
                : 0);
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (( true) && !disabled) {
                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
            }
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (n2.dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((true)) {
                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);
                    }
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, { r: remove, o: { remove: hostRemove } }) {
        const { shapeFlag, children, anchor } = vnode;
        hostRemove(anchor);
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                remove(children[i]);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);
            }
            target._lpa =
                vnode.targetAnchor && nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */
function resolveComponent(name) {
    return resolveAsset(COMPONENTS, name) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // self name has highest priority
        if (type === COMPONENTS) {
            // special self referencing call generated by compiler
            // inferred from SFC filename
            if (name === `_self`) {
                return Component;
            }
            const selfName = getComponentName(Component);
            if (selfName &&
                (selfName === name ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first for components with mixin or extends.
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (( true) && warnMissing && !res) {
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);
        }
        return res;
    }
    else if ((true)) {
        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +
            `can only be used in render() or setup().`);
    }
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));
}

const Fragment = Symbol(( true) ? 'Fragment' : 0);
const Text = Symbol(( true) ? 'Text' : 0);
const Comment = Symbol(( true) ? 'Comment' : 0);
const Static = Symbol(( true) ? 'Static' : 0);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let shouldTrack = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    shouldTrack += value;
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);
    // save current block children on the block vnode
    vnode.dynamicChildren = currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (shouldTrack > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (( true) &&
        n2.shapeFlag & 6 /* COMPONENT */ &&
        hmrDirtyComponents.has(n2.type)) {
        // HMR only: if the component has been hot-updated, force a reload.
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref }) => {
    return (ref != null
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)
            ? { i: currentRenderingInstance, r: ref }
            : ref
        : null);
};
const createVNode = (( true)
    ? createVNodeWithArgsTransform
    : 0);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (( true) && !type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props) {
            props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props);
        }
        let { class: klass, style } = props;
        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
            }
            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)
        ? 1 /* ELEMENT */
        : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (( true) && shapeFlag & 4 /* STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can ` +
            `lead to unnecessary performance overhead, and should be avoided by ` +
            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    const vnode = {
        __v_isVNode: true,
        ["__v_skip" /* SKIP */]: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        children: null,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    // validate key
    if (( true) && vnode.key !== vnode.key) {
        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    normalizeChildren(vnode, children);
    // normalize suspense children
    if (shapeFlag & 128 /* SUSPENSE */) {
        const { content, fallback } = normalizeSuspenseChildren(vnode);
        vnode.ssContent = content;
        vnode.ssFallback = fallback;
    }
    if (shouldTrack > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        patchFlag !== 32 /* HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    return {
        __v_isVNode: true,
        ["__v_skip" /* SKIP */]: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        children: ( true) && patchFlag === -1 /* HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
            ? children.map(deepCloneVNode)
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: perserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* FULL_PROPS */
                : patchFlag | 16 /* FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
        // fragment
        return createVNode(Fragment, null, child);
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return child.el === null ? child : cloneVNode(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && setCompiledSlotRendering(1);
                normalizeChildren(vnode, slot());
                slot._c && setCompiledSlotRendering(-1);
            }
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {
                    children._ = 2 /* DYNAMIC */;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
                else {
                    children._ = 1 /* STABLE */;
                }
            }
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, args[0]);
    for (let i = 1; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (existing !== incoming) {
                    ret[key] = existing
                        ? [].concat(existing, toMerge[key])
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}

function provide(key, value) {
    if (!currentInstance) {
        if ((true)) {
            warn(`provide() can only be used inside setup().`);
        }
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the intance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)
                ? defaultValue()
                : defaultValue;
        }
        else if ((true)) {
            warn(`injection "${String(key)}" not found.`);
        }
    }
    else if ((true)) {
        warn(`inject() can only be used inside setup() or functional components.`);
    }
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let isInBeforeCreate = false;
function applyOptions(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {
    const { 
    // composition
    mixins, extends: extendsOptions, 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // assets
    components, directives, 
    // lifecycle
    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, 
    // public API
    expose } = options;
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    const globalMixins = instance.appContext.mixins;
    if (asMixin && render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        instance.render = render;
    }
    // applyOptions is called non-as-mixin once per instance
    if (!asMixin) {
        isInBeforeCreate = true;
        callSyncHook('beforeCreate', "bc" /* BEFORE_CREATE */, options, instance, globalMixins);
        isInBeforeCreate = false;
        // global mixins are applied first
        applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);
    }
    // extending a base component...
    if (extendsOptions) {
        applyOptions(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);
    }
    // local mixins
    if (mixins) {
        applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);
    }
    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;
    if ((true)) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* PROPS */, key);
            }
        }
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
            for (let i = 0; i < injectOptions.length; i++) {
                const key = injectOptions[i];
                ctx[key] = inject(key);
                if ((true)) {
                    checkDuplicateProperties("Inject" /* INJECT */, key);
                }
            }
        }
        else {
            for (const key in injectOptions) {
                const opt = injectOptions[key];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
                    ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);
                }
                else {
                    ctx[key] = inject(opt);
                }
                if ((true)) {
                    checkDuplicateProperties("Inject" /* INJECT */, key);
                }
            }
        }
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
                // and those are read-only but reconfigurable, so it needs to be redefined here
                if ((true)) {
                    Object.defineProperty(ctx, key, {
                        value: methodHandler.bind(publicThis),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    });
                }
                else {}
                if ((true)) {
                    checkDuplicateProperties("Methods" /* METHODS */, key);
                }
            }
            else if ((true)) {
                warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`);
            }
        }
    }
    if (!asMixin) {
        if (deferredData.length) {
            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));
        }
        if (dataOptions) {
            // @ts-ignore dataOptions is not fully type safe
            resolveData(instance, dataOptions, publicThis);
        }
        if ((true)) {
            const rawData = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data);
            for (const key in rawData) {
                checkDuplicateProperties("Data" /* DATA */, key);
                // expose data on ctx during dev
                if (key[0] !== '$' && key[0] !== '_') {
                    Object.defineProperty(ctx, key, {
                        configurable: true,
                        enumerable: true,
                        get: () => rawData[key],
                        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
                    });
                }
            }
        }
    }
    else if (dataOptions) {
        deferredData.push(dataOptions);
    }
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                ? opt.bind(publicThis, publicThis)
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
                warn(`Computed property "${key}" has no getter.`);
            }
            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)
                ? opt.set.bind(publicThis)
                : ( true)
                    ? () => {
                        warn(`Write operation failed: computed property "${key}" is readonly.`);
                    }
                    : 0;
            const c = computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((true)) {
                checkDuplicateProperties("Computed" /* COMPUTED */, key);
            }
        }
    }
    if (watchOptions) {
        deferredWatch.push(watchOptions);
    }
    if (!asMixin && deferredWatch.length) {
        deferredWatch.forEach(watchOptions => {
            for (const key in watchOptions) {
                createWatcher(watchOptions[key], ctx, publicThis, key);
            }
        });
    }
    if (provideOptions) {
        deferredProvide.push(provideOptions);
    }
    if (!asMixin && deferredProvide.length) {
        deferredProvide.forEach(provideOptions => {
            const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)
                ? provideOptions.call(publicThis)
                : provideOptions;
            Reflect.ownKeys(provides).forEach(key => {
                provide(key, provides[key]);
            });
        });
    }
    // asset options.
    // To reduce memory usage, only components with mixins or extends will have
    // resolved asset registry attached to instance.
    if (asMixin) {
        if (components) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(instance.components ||
                (instance.components = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, instance.type.components)), components);
        }
        if (directives) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(instance.directives ||
                (instance.directives = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, instance.type.directives)), directives);
        }
    }
    // lifecycle options
    if (!asMixin) {
        callSyncHook('created', "c" /* CREATED */, options, instance, globalMixins);
    }
    if (beforeMount) {
        onBeforeMount(beforeMount.bind(publicThis));
    }
    if (mounted) {
        onMounted(mounted.bind(publicThis));
    }
    if (beforeUpdate) {
        onBeforeUpdate(beforeUpdate.bind(publicThis));
    }
    if (updated) {
        onUpdated(updated.bind(publicThis));
    }
    if (activated) {
        onActivated(activated.bind(publicThis));
    }
    if (deactivated) {
        onDeactivated(deactivated.bind(publicThis));
    }
    if (errorCaptured) {
        onErrorCaptured(errorCaptured.bind(publicThis));
    }
    if (renderTracked) {
        onRenderTracked(renderTracked.bind(publicThis));
    }
    if (renderTriggered) {
        onRenderTriggered(renderTriggered.bind(publicThis));
    }
    if (( true) && beforeDestroy) {
        warn(`\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`);
    }
    if (beforeUnmount) {
        onBeforeUnmount(beforeUnmount.bind(publicThis));
    }
    if (( true) && destroyed) {
        warn(`\`destroyed\` has been renamed to \`unmounted\`.`);
    }
    if (unmounted) {
        onUnmounted(unmounted.bind(publicThis));
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
        if (!asMixin) {
            if (expose.length) {
                const exposed = instance.exposed || (instance.exposed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)({}));
                expose.forEach(key => {
                    exposed[key] = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(publicThis, key);
                });
            }
            else if (!instance.exposed) {
                instance.exposed = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
        }
        else if ((true)) {
            warn(`The \`expose\` option is ignored when used in mixins.`);
        }
    }
}
function callSyncHook(name, type, options, instance, globalMixins) {
    callHookFromMixins(name, type, globalMixins, instance);
    const { extends: base, mixins } = options;
    if (base) {
        callHookFromExtends(name, type, base, instance);
    }
    if (mixins) {
        callHookFromMixins(name, type, mixins, instance);
    }
    const selfHook = options[name];
    if (selfHook) {
        callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);
    }
}
function callHookFromExtends(name, type, base, instance) {
    if (base.extends) {
        callHookFromExtends(name, type, base.extends, instance);
    }
    const baseHook = base[name];
    if (baseHook) {
        callWithAsyncErrorHandling(baseHook.bind(instance.proxy), instance, type);
    }
}
function callHookFromMixins(name, type, mixins, instance) {
    for (let i = 0; i < mixins.length; i++) {
        const chainedMixins = mixins[i].mixins;
        if (chainedMixins) {
            callHookFromMixins(name, type, chainedMixins, instance);
        }
        const fn = mixins[i][name];
        if (fn) {
            callWithAsyncErrorHandling(fn.bind(instance.proxy), instance, type);
        }
    }
}
function applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {
    for (let i = 0; i < mixins.length; i++) {
        applyOptions(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);
    }
}
function resolveData(instance, dataFn, publicThis) {
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataFn)) {
        warn(`The data option must be a function. ` +
            `Plain object usage is no longer supported.`);
    }
    const data = dataFn.call(publicThis, publicThis);
    if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
        warn(`data() returned a Promise - note data() cannot be async; If you ` +
            `intend to perform data fetching before component renders, use ` +
            `async setup() + <Suspense>.`);
    }
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
        ( true) && warn(`data() should return an object.`);
    }
    else if (instance.data === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
    }
    else {
        // existing data: this is a mixin or extends.
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(instance.data, data);
    }
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
        const handler = ctx[raw];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
            watch(getter, handler);
        }
        else if ((true)) {
            warn(`Invalid watch handler specified by key "${raw}"`, handler);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
                watch(getter, handler, raw);
            }
            else if ((true)) {
                warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
        }
    }
    else if ((true)) {
        warn(`Invalid watch option: "${key}"`, raw);
    }
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function resolveMergedOptions(instance) {
    const raw = instance.type;
    const { __merged, mixins, extends: extendsOptions } = raw;
    if (__merged)
        return __merged;
    const globalMixins = instance.appContext.mixins;
    if (!globalMixins.length && !mixins && !extendsOptions)
        return raw;
    const options = {};
    globalMixins.forEach(m => mergeOptions(options, m, instance));
    mergeOptions(options, raw, instance);
    return (raw.__merged = options);
}
function mergeOptions(to, from, instance) {
    const strats = instance.appContext.config.optionMergeStrategies;
    const { mixins, extends: extendsOptions } = from;
    extendsOptions && mergeOptions(to, extendsOptions, instance);
    mixins &&
        mixins.forEach((m) => mergeOptions(to, m, instance));
    for (const key in from) {
        if (strats && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(strats, key)) {
            to[key] = strats[key](to[key], from[key], instance.proxy, key);
        }
        else {
            to[key] = from[key];
        }
    }
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return i.exposed ? i.exposed : i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),
    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),
    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),
    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),
    $forceUpdate: i => () => queueJob(i.update),
    $nextTick: i => nextTick.bind(i.proxy),
    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP)
});
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // let @vue/reactivity know it should never observe Vue public instances.
        if (key === "__v_skip" /* SKIP */) {
            return true;
        }
        // for internal formatters to know that this is a Vue instance
        if (( true) && key === '__isVue') {
            return true;
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 0 /* SETUP */:
                        return setupState[key];
                    case 1 /* DATA */:
                        return data[key];
                    case 3 /* CONTEXT */:
                        return ctx[key];
                    case 2 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
                accessCache[key] = 0 /* SETUP */;
                return setupState[key];
            }
            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                accessCache[key] = 1 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 2 /* PROPS */;
                return props[key];
            }
            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
                accessCache[key] = 3 /* CONTEXT */;
                return ctx[key];
            }
            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {
                accessCache[key] = 4 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, key);
                ( true) && markAttrsAccessed();
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 3 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {
            return globalProperties[key];
        }
        else if (( true) &&
            currentRenderingInstance &&
            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)) {
            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (key[0] === '$' || key[0] === '_') &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`);
            }
            else if (instance === currentRenderingInstance) {
                warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                    `but is not defined on instance.`);
            }
        }
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            setupState[key] = value;
        }
        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
            data[key] = value;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
            ( true) &&
                warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( true) &&
                warn(`Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`, instance);
            return false;
        }
        else {
            if (( true) && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                });
            }
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (accessCache[key] !== undefined ||
            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||
            (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) ||
            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));
    }
};
if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
            `The keys will be empty in production mode to avoid performance overhead.`);
        return Reflect.ownKeys(target);
    };
}
const RuntimeCompiledPublicInstanceProxyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);
        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {
            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        }
        return has;
    }
});
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
    // expose global properties
    const { globalProperties } = instance.appContext.config;
    Object.keys(globalProperties).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => globalProperties[key],
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
        if (key[0] === '$' || key[0] === '_') {
            warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                `which are reserved prefixes for Vue internals.`);
            return;
        }
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        update: null,
        render: null,
        proxy: null,
        exposed: null,
        withProxy: null,
        effects: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resovled assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // state
        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null
    };
    if ((true)) {
        instance.ctx = createRenderContext(instance);
    }
    else {}
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
};
const isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if ((true)) {
        if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
            }
        }
        if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
            }
        }
    }
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    if ((true)) {
        exposePropsOnRenderContext(instance);
    }
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        currentInstance = instance;
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        currentInstance = null;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult.then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
            }
        }
        else {
            handleSetupResult(instance, setupResult);
        }
    }
    else {
        finishComponentSetup(instance);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
        // setup returned an inline render function
        {
            instance.render = setupResult;
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
        if (( true) && isVNode(setupResult)) {
            warn(`setup() should not return VNodes directly - ` +
                `return a render function instead.`);
        }
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (true) {
            instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
        if ((true)) {
            exposeSetupStateOnRenderContext(instance);
        }
    }
    else if (( true) && setupResult !== undefined) {
        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    }
    finishComponentSetup(instance);
}
let compile;
// dev only
const isRuntimeOnly = () => !compile;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
}
function finishComponentSetup(instance, isSSR) {
    const Component = instance.type;
    // template / render function normalization
    if (!instance.render) {
        // could be set from setup()
        if (compile && Component.template && !Component.render) {
            if ((true)) {
                startMeasure(instance, `compile`);
            }
            Component.render = compile(Component.template, {
                isCustomElement: instance.appContext.config.isCustomElement,
                delimiters: Component.delimiters
            });
            if ((true)) {
                endMeasure(instance, `compile`);
            }
        }
        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (instance.render._rc) {
            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    }
    // support for 2.x options
    if (__VUE_OPTIONS_API__) {
        currentInstance = instance;
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        applyOptions(instance, Component);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        currentInstance = null;
    }
    // warn missing template/render
    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        /* istanbul ignore if */
        if (!compile && Component.template) {
            warn(`Component provided template option but ` +
                `runtime compilation is not supported in this build of Vue.` +
                (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                    ) /* should not happen */);
        }
        else {
            warn(`Component is missing template or render function.`);
        }
    }
}
const attrHandlers = {
    get: (target, key) => {
        if ((true)) {
            markAttrsAccessed();
        }
        return target[key];
    },
    set: () => {
        warn(`setupContext.attrs is readonly.`);
        return false;
    },
    deleteProperty: () => {
        warn(`setupContext.attrs is readonly.`);
        return false;
    }
};
function createSetupContext(instance) {
    const expose = exposed => {
        if (( true) && instance.exposed) {
            warn(`expose() should be called only once per setup().`);
        }
        instance.exposed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(exposed);
    };
    if ((true)) {
        // We use getters in dev in case libs like test-utils overwrite instance
        // properties (overwrites should not be done in prod)
        return Object.freeze({
            get props() {
                return instance.props;
            },
            get attrs() {
                return new Proxy(instance.attrs, attrHandlers);
            },
            get slots() {
                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
            },
            get emit() {
                return (event, ...args) => instance.emit(event, ...args);
            },
            expose
        });
    }
    else {}
}
// record effects created during a component's setup() so that they can be
// stopped when the component unmounts
function recordInstanceBoundEffect(effect, instance = currentInstance) {
    if (instance) {
        (instance.effects || (instance.effects = [])).push(effect);
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)
        ? Component.displayName || Component.name
        : Component.name;
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

function computed(getterOrOptions) {
    const c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions);
    recordInstanceBoundEffect(c.effect);
    return c;
}

// implementation
function defineProps() {
    if ((true)) {
        warn(`defineProps() is a compiler-hint helper that is only usable inside ` +
            `<script setup> of a single file component. Its arguments should be ` +
            `compiled away and passing it at runtime has no effect.`);
    }
    return null;
}
// implementation
function defineEmit() {
    if ((true)) {
        warn(`defineEmit() is a compiler-hint helper that is only usable inside ` +
            `<script setup> of a single file component. Its arguments should be ` +
            `compiled away and passing it at runtime has no effect.`);
    }
    return null;
}
function useContext() {
    const i = getCurrentInstance();
    if (( true) && !i) {
        warn(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( true) ? `ssrContext` : 0);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            warn(`Server rendering context not provided. Make sure to only call ` +
                `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if ( false || typeof window === 'undefined') {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
        }
        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (v._shallow) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

/**
 * Actual implementation
 */
function renderList(source, renderItem) {
    let ret;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i);
        }
    }
    else if (typeof source === 'number') {
        if (( true) && !Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
            return [];
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, renderItem);
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i);
            }
        }
    }
    else {
        ret = [];
    }
    return ret;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj) {
    const ret = {};
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for (const key in obj) {
        ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

// Core API ------------------------------------------------------------------
const version = "3.0.7";
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = (null);




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
let tempContainer;
let tempSVGContainer;
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is) => isSVG
        ? doc.createElementNS(svgNS, tag)
        : doc.createElement(tag, is ? { is } : undefined),
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        return el.cloneNode(true);
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG) {
        const temp = isSVG
            ? tempSVGContainer ||
                (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))
            : tempContainer || (tempContainer = doc.createElement('div'));
        temp.innerHTML = content;
        const first = temp.firstChild;
        let node = first;
        let last = node;
        while (node) {
            last = node;
            nodeOps.insert(node, parent, anchor);
            node = temp.firstChild;
        }
        return [first, last];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    if (value == null) {
        value = '';
    }
    if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        // directly setting className should be faster than setAttribute in theory
        // if this is an element during a transition, take the temporary transition
        // classes into account.
        const transitionClasses = el._vtc;
        if (transitionClasses) {
            value = (value
                ? [value, ...transitionClasses]
                : [...transitionClasses]).join(' ');
        }
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    if (!next) {
        el.removeAttribute('style');
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next)) {
        if (prev !== next) {
            const current = style.display;
            style.cssText = next;
            // indicates that the `display` of the element is controlled by `v-show`,
            // so we always keep the current `display` value regardless of the `style` value,
            // thus handing over control to `v-show`.
            if ('_vod' in el) {
                style.display = current;
            }
        }
    }
    else {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
        if (value == null || (isBoolean && value === false)) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' && el.tagName !== 'PROGRESS') {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
        return;
    }
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (value === '' && type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            el[key] = true;
            return;
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            el[key] = '';
            el.removeAttribute(key);
            return;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            el[key] = 0;
            el.removeAttribute(key);
            return;
        }
    }
    // some properties perform value validation and throw
    try {
        el[key] = value;
    }
    catch (e) {
        if ((true)) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                `value ${value} is invalid.`, e);
        }
    }
}

// Async edge case fix requires storing an event listener's attach timestamp.
let _getNow = Date.now;
// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
if (typeof document !== 'undefined' &&
    _getNow() > document.createEvent('Event').timeStamp) {
    // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    _getNow = () => performance.now();
}
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = Promise.resolve();
const reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (timeStamp >= invoker.attached - 1) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const forcePatchProp = (_, key) => key === 'value';
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    switch (key) {
        // special
        case 'class':
            patchClass(el, nextValue, isSVG);
            break;
        case 'style':
            patchStyle(el, prevValue, nextValue);
            break;
        default:
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                // ignore v-model listeners
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                    patchEvent(el, key, prevValue, nextValue, parentComponent);
                }
            }
            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
            }
            else {
                // special case for <input v-model type="checkbox"> with
                // :true-value & :false-value
                // store value as dom properties since non-string values will be
                // stringified.
                if (key === 'true-value') {
                    el._trueValue = nextValue;
                }
                else if (key === 'false-value') {
                    el._falseValue = nextValue;
                }
                patchAttr(el, key, nextValue, isSVG);
            }
            break;
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML
        if (key === 'innerHTML') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            return true;
        }
        return false;
    }
    // spellcheck and draggable are numerated attrs, however their
    // corresponding DOM properties are actually booleans - this leads to
    // setting it with a string "false" value leading it to be coerced to
    // `true`, so we need to always treat them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        return false;
    }
    return key in el;
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (!instance) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( true) &&
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    /* istanbul ignore next */
    if (!instance) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(setVars, { flush: 'post' }));
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(setVars);
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
        const style = vnode.el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));
function resolveTransitionProps(rawProps) {
    let { name = 'v', type, css = true, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (!css) {
        return baseProps;
    }
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            hook && hook(el, resolve);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!(hook && hook.length > 1)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
        onBeforeEnter(el) {
            onBeforeEnter && onBeforeEnter(el);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            onBeforeAppear && onBeforeAppear(el);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!(onLeave && onLeave.length > 1)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            onLeave && onLeave(el, resolve);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            onEnterCancelled && onEnterCancelled(el);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            onAppearCancelled && onAppearCancelled(el);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            onLeaveCancelled && onLeaveCancelled(el);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
    if ((true))
        validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
        let prevChildren;
        let children;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            const tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
            prevChildren = children;
            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                }
                else if ((true)) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1
        ? root
        : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'];
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        trigger(target, 'input');
    }
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || el.type === 'number';
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            else if (castToNumber) {
                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el) {
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
                el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch (el.tagName) {
        case 'SELECT':
            modelToUse = vModelSelect;
            break;
        case 'TEXTAREA':
            modelToUse = vModelText;
            break;
        default:
            switch (vnode.props && vnode.props.type) {
                case 'checkbox':
                    modelToUse = vModelCheckbox;
                    break;
                case 'radio':
                    modelToUse = vModelRadio;
                    break;
                default:
                    modelToUse = vModelText;
            }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event))
            return;
        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
        if (
        // None of the provided key modifiers match the current event key
        !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return;
        }
        return fn(event);
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}

const rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp, forcePatchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCustomElementCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCustomElementCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
        writable: false
    });
}
// dev only
function injectCustomElementCheck(app) {
    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
        const value = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return value;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is only respected when using the runtime compiler.` +
                    `If you are using the runtime-only build, \`isCustomElement\` must be passed to \`@vue/compiler-dom\` in the build setup instead` +
                    `- for example, via the \`compilerOptions\` option in vue-loader: https://vue-loader.vuejs.org/options.html#compileroptions.`);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
        const res = document.querySelector(container);
        if (( true) && !res) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        }
        return res;
    }
    if (( true) &&
        container instanceof window.ShadowRoot &&
        container.mode === 'closed') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
}




/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "babelParserDefaultPlugins": () => (/* binding */ babelParserDefaultPlugins),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownAttr": () => (/* binding */ isKnownAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return val == null
        ? ''
        : isObject(val)
            ? JSON.stringify(val, replacer, 2)
            : String(val);
};
const replacer = (_key, val) => {
    if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

/**
 * List of @babel/parser plugins that are used for template expression
 * transforms and SFC script transforms. By default we enable proposals slated
 * for ES2020. This will need to be updated as the spec moves forward.
 * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins
 */
const babelParserDefaultPlugins = [
    'bigInt',
    'optionalChaining',
    'nullishCoalescingOperator'
];
const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/App.vue?vue&type=script&lang=js":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/App.vue?vue&type=script&lang=js ***!
  \*********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Search_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Search.vue */ "./resources/js/components/Search.vue");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  components: {
    Search: _Search_vue__WEBPACK_IMPORTED_MODULE_0__.default
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Search.vue?vue&type=script&lang=js":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Search.vue?vue&type=script&lang=js ***!
  \************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debounce */ "./node_modules/debounce/index.js");
/* harmony import */ var debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debounce__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_3__);


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setup: function setup() {
    var query = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)("");
    var albums = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)([]);

    function search(_x) {
      return _search.apply(this, arguments);
    }

    function _search() {
      _search = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee2(query) {
        var response;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return axios__WEBPACK_IMPORTED_MODULE_3___default().get("/api/albums", {
                  params: {
                    query: query
                  }
                });

              case 2:
                response = _context2.sent;
                return _context2.abrupt("return", response.data);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _search.apply(this, arguments);
    }

    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(function () {
      return query.value;
    }, (0,debounce__WEBPACK_IMPORTED_MODULE_2__.debounce)( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(query) {
        var result;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return search(query);

              case 3:
                result = _context.sent;
                albums.value = _toConsumableArray(result.data);
                _context.next = 9;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](0);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 7]]);
      }));

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }(), 250));
    return {
      query: query,
      albums: albums
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/App.vue?vue&type=template&id=332fccf4":
/*!*************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/App.vue?vue&type=template&id=332fccf4 ***!
  \*************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_search = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("search");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_search);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Search.vue?vue&type=template&id=5026ffd3":
/*!****************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Search.vue?vue&type=template&id=5026ffd3 ***!
  \****************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");

var _hoisted_1 = {
  "class": "Search"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)("div", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("input", {
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
      return $setup.query = $event;
    })
  }, null, 512
  /* NEED_PATCH */
  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $setup.query]]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("ul", null, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($setup.albums, function (album, i) {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)("li", {
      key: i
    }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(album.title) + " by " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(album.artist), 1
    /* TEXT */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))])]);
}

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bootstrap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bootstrap.js */ "./resources/js/bootstrap.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _components_App_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/App.vue */ "./resources/js/components/App.vue");



(0,vue__WEBPACK_IMPORTED_MODULE_1__.createApp)({}).component('app', _components_App_vue__WEBPACK_IMPORTED_MODULE_2__.default).mount('#app');

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);

/**
 * We'll load the axios HTTP library which allows us to easily issue requests
 * to our Laravel back-end. This library automatically handles sending the
 * CSRF token as a header based on the value of the "XSRF" token cookie.
 */

(axios__WEBPACK_IMPORTED_MODULE_0___default().defaults.headers.common["X-Requested-With"]) = 'XMLHttpRequest';

/***/ }),

/***/ "./node_modules/debounce/index.js":
/*!****************************************!*\
  !*** ./node_modules/debounce/index.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */
function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };

  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
};

// Adds compatibility for ES modules
debounce.debounce = debounce;

module.exports = debounce;


/***/ }),

/***/ "./resources/scss/app.scss":
/*!*********************************!*\
  !*** ./resources/scss/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./resources/js/components/App.vue":
/*!*****************************************!*\
  !*** ./resources/js/components/App.vue ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _App_vue_vue_type_template_id_332fccf4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=332fccf4 */ "./resources/js/components/App.vue?vue&type=template&id=332fccf4");
/* harmony import */ var _App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js */ "./resources/js/components/App.vue?vue&type=script&lang=js");



_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.render = _App_vue_vue_type_template_id_332fccf4__WEBPACK_IMPORTED_MODULE_0__.render
/* hot reload */
if (false) {}

_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.__file = "resources/js/components/App.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./resources/js/components/Search.vue":
/*!********************************************!*\
  !*** ./resources/js/components/Search.vue ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Search_vue_vue_type_template_id_5026ffd3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Search.vue?vue&type=template&id=5026ffd3 */ "./resources/js/components/Search.vue?vue&type=template&id=5026ffd3");
/* harmony import */ var _Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Search.vue?vue&type=script&lang=js */ "./resources/js/components/Search.vue?vue&type=script&lang=js");



_Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.render = _Search_vue_vue_type_template_id_5026ffd3__WEBPACK_IMPORTED_MODULE_0__.render
/* hot reload */
if (false) {}

_Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.__file = "resources/js/components/Search.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./resources/js/components/App.vue?vue&type=script&lang=js":
/*!*****************************************************************!*\
  !*** ./resources/js/components/App.vue?vue&type=script&lang=js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./App.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/App.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/Search.vue?vue&type=script&lang=js":
/*!********************************************************************!*\
  !*** ./resources/js/components/Search.vue?vue&type=script&lang=js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Search_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Search.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Search.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/App.vue?vue&type=template&id=332fccf4":
/*!***********************************************************************!*\
  !*** ./resources/js/components/App.vue?vue&type=template&id=332fccf4 ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_template_id_332fccf4__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_App_vue_vue_type_template_id_332fccf4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./App.vue?vue&type=template&id=332fccf4 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/App.vue?vue&type=template&id=332fccf4");


/***/ }),

/***/ "./resources/js/components/Search.vue?vue&type=template&id=5026ffd3":
/*!**************************************************************************!*\
  !*** ./resources/js/components/Search.vue?vue&type=template&id=5026ffd3 ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Search_vue_vue_type_template_id_5026ffd3__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Search_vue_vue_type_template_id_5026ffd3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Search.vue?vue&type=template&id=5026ffd3 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Search.vue?vue&type=template&id=5026ffd3");


/***/ })

},
0,[["./resources/js/app.js","/js/manifest","/js/vendor"],["./resources/scss/app.scss","/js/manifest","/js/vendor"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItY29yZS9kaXN0L2NvbXBpbGVyLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItZG9tL2Rpc3QvY29tcGlsZXItZG9tLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9BcHAudnVlIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1NlYXJjaC52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9hcHAuc2NzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQXBwLnZ1ZT81YmFkIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL1NlYXJjaC52dWU/ZTgyOCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9BcHAudnVlPzIxMTIiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvU2VhcmNoLnZ1ZT83MTIwIl0sIm5hbWVzIjpbImNyZWF0ZUFwcCIsImNvbXBvbmVudCIsIkFwcCIsIm1vdW50IiwiYXhpb3MiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsZ0hBQStDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBNks7QUFDNUs7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQWdEO0FBQ2hFO0FBQ0EsVUFBVSxDQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLEtBQXFDLGlCQUFpQixDQUFFO0FBQ2pGLHlCQUF5QixLQUFxQyxpQkFBaUIsQ0FBRTtBQUNqRix5QkFBeUIsS0FBcUMsaUJBQWlCLENBQUU7QUFDakYsMkJBQTJCLEtBQXFDLGtCQUFrQixDQUFFO0FBQ3BGLGdDQUFnQyxLQUFxQyx1QkFBdUIsQ0FBRTtBQUM5RiwyQkFBMkIsS0FBcUMsa0JBQWtCLENBQUU7QUFDcEYsNkJBQTZCLEtBQXFDLG9CQUFvQixDQUFFO0FBQ3hGLDZCQUE2QixLQUFxQyxvQkFBb0IsQ0FBRTtBQUN4RiwrQkFBK0IsS0FBcUMsMkJBQTJCLENBQUU7QUFDakcsNEJBQTRCLEtBQXFDLHdCQUF3QixDQUFFO0FBQzNGLDhCQUE4QixLQUFxQywwQkFBMEIsQ0FBRTtBQUMvRixrQ0FBa0MsS0FBcUMseUJBQXlCLENBQUU7QUFDbEcsMENBQTBDLEtBQXFDLGdDQUFnQyxDQUFFO0FBQ2pILGtDQUFrQyxLQUFxQyx5QkFBeUIsQ0FBRTtBQUNsRyxnQ0FBZ0MsS0FBcUMsdUJBQXVCLENBQUU7QUFDOUYsNEJBQTRCLEtBQXFDLG1CQUFtQixDQUFFO0FBQ3RGLDRCQUE0QixLQUFxQyxtQkFBbUIsQ0FBRTtBQUN0Riw2QkFBNkIsS0FBcUMsb0JBQW9CLENBQUU7QUFDeEYsa0NBQWtDLEtBQXFDLHdCQUF3QixDQUFFO0FBQ2pHLDRCQUE0QixLQUFxQyxtQkFBbUIsQ0FBRTtBQUN0Riw0QkFBNEIsS0FBcUMsbUJBQW1CLENBQUU7QUFDdEYseUJBQXlCLEtBQXFDLGlCQUFpQixDQUFFO0FBQ2pGLDJCQUEyQixLQUFxQyxtQkFBbUIsQ0FBRTtBQUNyRiwrQkFBK0IsS0FBcUMscUJBQXFCLENBQUU7QUFDM0YsbUNBQW1DLEtBQXFDLHlCQUF5QixDQUFFO0FBQ25HLDhCQUE4QixLQUFxQyxvQkFBb0IsQ0FBRTtBQUN6Riw2QkFBNkIsS0FBcUMsbUJBQW1CLENBQUU7QUFDdkYsOEJBQThCLEtBQXFDLG9CQUFvQixDQUFFO0FBQ3pGLHlCQUF5QixLQUFxQyxnQkFBZ0IsQ0FBRTtBQUNoRixzQkFBc0IsS0FBcUMsY0FBYyxDQUFFO0FBQzNFLHVCQUF1QixLQUFxQyxjQUFjLENBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxzREFBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1EQUFNLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0RBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFD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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQXFDO0FBQzFDLGdDQUFnQyxxQkFBTTtBQUN0QyxVQUFVLHFCQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGtEQUFTO0FBQ25ELFNBQVMs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFPO0FBQ2Y7QUFDQTtBQUNBLGFBQWEscURBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2RUFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQUk7QUFDcEI7QUFDQSxxQkFBcUIsNERBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVEQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxREFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTs7QUFFQUMsMEZBQUEsR0FBb0QsZ0JBQXBELEM7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNyRUE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLG9CQUFvQixDQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM3VCZ0U7QUFDVjtBQUNMO0FBQ2pELDRFQUFhLEdBQUcsMEVBQU07QUFDdEI7QUFDQSxJQUFJLEtBQVUsRUFBRSxFQVlmOztBQUVELDRFQUFhOztBQUViLGlFQUFlLHFFOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCb0Q7QUFDVjtBQUNMO0FBQ3BELCtFQUFhLEdBQUcsNkVBQU07QUFDdEI7QUFDQSxJQUFJLEtBQVUsRUFBRSxFQVlmOztBQUVELCtFQUFhOztBQUViLGlFQUFlLHdFOzs7Ozs7Ozs7Ozs7Ozs7O0FDckJ5TCxDOzs7Ozs7Ozs7Ozs7Ozs7O0FDQUcsQyIsImZpbGUiOiIvanMvYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsImltcG9ydCB7IGlzU3RyaW5nLCBoeXBoZW5hdGUsIGV4dGVuZCwgaXNPYmplY3QsIGlzQXJyYXksIE5PLCBtYWtlTWFwLCBpc1N5bWJvbCwgTk9PUCwgRU1QVFlfT0JKLCBjYXBpdGFsaXplLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBQYXRjaEZsYWdOYW1lcywgc2xvdEZsYWdzVGV4dCwgaXNPbiwgaXNSZXNlcnZlZFByb3AsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGdlbmVyYXRlQ29kZUZyYW1lIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIG1lc3NhZ2VzLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xyXG4gICAgY29uc3QgbXNnID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlXHJcbiAgICAgICAgPyAobWVzc2FnZXMgfHwgZXJyb3JNZXNzYWdlcylbY29kZV0gKyAoYWRkaXRpb25hbE1lc3NhZ2UgfHwgYGApXHJcbiAgICAgICAgOiBjb2RlO1xyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoU3RyaW5nKG1zZykpO1xyXG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XHJcbiAgICBlcnJvci5sb2MgPSBsb2M7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIC8vIHBhcnNlIGVycm9yc1xyXG4gICAgWzAgLyogQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVCAqL106ICdJbGxlZ2FsIGNvbW1lbnQuJyxcclxuICAgIFsxIC8qIENEQVRBX0lOX0hUTUxfQ09OVEVOVCAqL106ICdDREFUQSBzZWN0aW9uIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC4nLFxyXG4gICAgWzIgLyogRFVQTElDQVRFX0FUVFJJQlVURSAqL106ICdEdXBsaWNhdGUgYXR0cmlidXRlLicsXHJcbiAgICBbMyAvKiBFTkRfVEFHX1dJVEhfQVRUUklCVVRFUyAqL106ICdFbmQgdGFnIGNhbm5vdCBoYXZlIGF0dHJpYnV0ZXMuJyxcclxuICAgIFs0IC8qIEVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gICAgWzUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiB0YWcuJyxcclxuICAgIFs2IC8qIEVPRl9JTl9DREFUQSAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBDREFUQSBzZWN0aW9uLicsXHJcbiAgICBbNyAvKiBFT0ZfSU5fQ09NTUVOVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBjb21tZW50LicsXHJcbiAgICBbOCAvKiBFT0ZfSU5fU0NSSVBUX0hUTUxfQ09NTUVOVF9MSUtFX1RFWFQgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gc2NyaXB0LicsXHJcbiAgICBbOSAvKiBFT0ZfSU5fVEFHICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxyXG4gICAgWzEwIC8qIElOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UICovXTogJ0luY29ycmVjdGx5IGNsb3NlZCBjb21tZW50LicsXHJcbiAgICBbMTEgLyogSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgb3BlbmVkIGNvbW1lbnQuJyxcclxuICAgIFsxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqL106IFwiSWxsZWdhbCB0YWcgbmFtZS4gVXNlICcmbHQ7JyB0byBwcmludCAnPCcuXCIsXHJcbiAgICBbMTMgLyogTUlTU0lOR19BVFRSSUJVVEVfVkFMVUUgKi9dOiAnQXR0cmlidXRlIHZhbHVlIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE0IC8qIE1JU1NJTkdfRU5EX1RBR19OQU1FICovXTogJ0VuZCB0YWcgbmFtZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNSAvKiBNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTICovXTogJ1doaXRlc3BhY2Ugd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTYgLyogTkVTVEVEX0NPTU1FTlQgKi9dOiBcIlVuZXhwZWN0ZWQgJzwhLS0nIGluIGNvbW1lbnQuXCIsXHJcbiAgICBbMTcgLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fQVRUUklCVVRFX05BTUUgKi9dOiAnQXR0cmlidXRlIG5hbWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgYW5kIFUrMDAzQyAoPCkuJyxcclxuICAgIFsxOCAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9VTlFVT1RFRF9BVFRSSUJVVEVfVkFMVUUgKi9dOiAnVW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXCIpLCBVKzAwMjcgKFxcJyksIFUrMDAzQyAoPCksIFUrMDAzRCAoPSksIGFuZCBVKzAwNjAgKGApLicsXHJcbiAgICBbMTkgLyogVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi9dOiBcIkF0dHJpYnV0ZSBuYW1lIGNhbm5vdCBzdGFydCB3aXRoICc9Jy5cIixcclxuICAgIFsyMSAvKiBVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRSAqL106IFwiJzw/JyBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuXCIsXHJcbiAgICBbMjIgLyogVU5FWFBFQ1RFRF9TT0xJRFVTX0lOX1RBRyAqL106IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcclxuICAgIC8vIFZ1ZS1zcGVjaWZpYyBwYXJzZSBlcnJvcnNcclxuICAgIFsyMyAvKiBYX0lOVkFMSURfRU5EX1RBRyAqL106ICdJbnZhbGlkIGVuZCB0YWcuJyxcclxuICAgIFsyNCAvKiBYX01JU1NJTkdfRU5EX1RBRyAqL106ICdFbGVtZW50IGlzIG1pc3NpbmcgZW5kIHRhZy4nLFxyXG4gICAgWzI1IC8qIFhfTUlTU0lOR19JTlRFUlBPTEFUSU9OX0VORCAqL106ICdJbnRlcnBvbGF0aW9uIGVuZCBzaWduIHdhcyBub3QgZm91bmQuJyxcclxuICAgIFsyNiAvKiBYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovXTogJ0VuZCBicmFja2V0IGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCB3YXMgbm90IGZvdW5kLiAnICtcclxuICAgICAgICAnTm90ZSB0aGF0IGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IGNhbm5vdCBjb250YWluIHNwYWNlcy4nLFxyXG4gICAgLy8gdHJhbnNmb3JtIGVycm9yc1xyXG4gICAgWzI3IC8qIFhfVl9JRl9OT19FWFBSRVNTSU9OICovXTogYHYtaWYvdi1lbHNlLWlmIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzI4IC8qIFhfVl9JRl9TQU1FX0tFWSAqL106IGB2LWlmL2Vsc2UgYnJhbmNoZXMgbXVzdCB1c2UgdW5pcXVlIGtleXMuYCxcclxuICAgIFsyOSAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqL106IGB2LWVsc2Uvdi1lbHNlLWlmIGhhcyBubyBhZGphY2VudCB2LWlmLmAsXHJcbiAgICBbMzAgLyogWF9WX0ZPUl9OT19FWFBSRVNTSU9OICovXTogYHYtZm9yIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzMxIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1mb3IgaGFzIGludmFsaWQgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzMyIC8qIFhfVl9GT1JfVEVNUExBVEVfS0VZX1BMQUNFTUVOVCAqL106IGA8dGVtcGxhdGUgdi1mb3I+IGtleSBzaG91bGQgYmUgcGxhY2VkIG9uIHRoZSA8dGVtcGxhdGU+IHRhZy5gLFxyXG4gICAgWzMzIC8qIFhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi9dOiBgdi1iaW5kIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzM0IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovXTogYHYtb24gaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzUgLyogWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVQgKi9dOiBgVW5leHBlY3RlZCBjdXN0b20gZGlyZWN0aXZlIG9uIDxzbG90PiBvdXRsZXQuYCxcclxuICAgIFszNiAvKiBYX1ZfU0xPVF9NSVhFRF9TTE9UX1VTQUdFICovXTogYE1peGVkIHYtc2xvdCB1c2FnZSBvbiBib3RoIHRoZSBjb21wb25lbnQgYW5kIG5lc3RlZCA8dGVtcGxhdGU+LmAgK1xyXG4gICAgICAgIGBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBuYW1lZCBzbG90cywgYWxsIHNsb3RzIHNob3VsZCB1c2UgPHRlbXBsYXRlPiBgICtcclxuICAgICAgICBgc3ludGF4IHRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eS5gLFxyXG4gICAgWzM3IC8qIFhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTICovXTogYER1cGxpY2F0ZSBzbG90IG5hbWVzIGZvdW5kLiBgLFxyXG4gICAgWzM4IC8qIFhfVl9TTE9UX0VYVFJBTkVPVVNfREVGQVVMVF9TTE9UX0NISUxEUkVOICovXTogYEV4dHJhbmVvdXMgY2hpbGRyZW4gZm91bmQgd2hlbiBjb21wb25lbnQgYWxyZWFkeSBoYXMgZXhwbGljaXRseSBuYW1lZCBgICtcclxuICAgICAgICBgZGVmYXVsdCBzbG90LiBUaGVzZSBjaGlsZHJlbiB3aWxsIGJlIGlnbm9yZWQuYCxcclxuICAgIFszOSAvKiBYX1ZfU0xPVF9NSVNQTEFDRUQgKi9dOiBgdi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+IHRhZ3MuYCxcclxuICAgIFs0MCAvKiBYX1ZfTU9ERUxfTk9fRVhQUkVTU0lPTiAqL106IGB2LW1vZGVsIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzQxIC8qIFhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTiAqL106IGB2LW1vZGVsIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IG1lbWJlciBleHByZXNzaW9uLmAsXHJcbiAgICBbNDIgLyogWF9WX01PREVMX09OX1NDT1BFX1ZBUklBQkxFICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gdi1mb3Igb3Igdi1zbG90IHNjb3BlIHZhcmlhYmxlcyBiZWNhdXNlIHRoZXkgYXJlIG5vdCB3cml0YWJsZS5gLFxyXG4gICAgWzQzIC8qIFhfSU5WQUxJRF9FWFBSRVNTSU9OICovXTogYEVycm9yIHBhcnNpbmcgSmF2YVNjcmlwdCBleHByZXNzaW9uOiBgLFxyXG4gICAgWzQ0IC8qIFhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOICovXTogYDxLZWVwQWxpdmU+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgY29tcG9uZW50LmAsXHJcbiAgICAvLyBnZW5lcmljIGVycm9yc1xyXG4gICAgWzQ1IC8qIFhfUFJFRklYX0lEX05PVF9TVVBQT1JURUQgKi9dOiBgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcclxuICAgIFs0NiAvKiBYX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURUQgKi9dOiBgRVMgbW9kdWxlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXHJcbiAgICBbNDcgLyogWF9DQUNIRV9IQU5ETEVSX05PVF9TVVBQT1JURUQgKi9dOiBgXCJjYWNoZUhhbmRsZXJzXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdGhlIFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgZW5hYmxlZC5gLFxyXG4gICAgWzQ4IC8qIFhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRCAqL106IGBcInNjb3BlSWRcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gbW9kdWxlIG1vZGUuYFxyXG59O1xuXG5jb25zdCBGUkFHTUVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgRnJhZ21lbnRgIDogYGApO1xyXG5jb25zdCBURUxFUE9SVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVGVsZXBvcnRgIDogYGApO1xyXG5jb25zdCBTVVNQRU5TRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgU3VzcGVuc2VgIDogYGApO1xyXG5jb25zdCBLRUVQX0FMSVZFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBLZWVwQWxpdmVgIDogYGApO1xyXG5jb25zdCBCQVNFX1RSQU5TSVRJT04gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEJhc2VUcmFuc2l0aW9uYCA6IGBgKTtcclxuY29uc3QgT1BFTl9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgb3BlbkJsb2NrYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX0JMT0NLID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVCbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9WTk9ERSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlVk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfQ09NTUVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQ29tbWVudFZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVRleHRWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9TVEFUSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVN0YXRpY1ZOb2RlYCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9DT01QT05FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVDb21wb25lbnRgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRHluYW1pY0NvbXBvbmVudGAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfRElSRUNUSVZFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRGlyZWN0aXZlYCA6IGBgKTtcclxuY29uc3QgV0lUSF9ESVJFQ1RJVkVTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoRGlyZWN0aXZlc2AgOiBgYCk7XHJcbmNvbnN0IFJFTkRFUl9MSVNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZW5kZXJMaXN0YCA6IGBgKTtcclxuY29uc3QgUkVOREVSX1NMT1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlclNsb3RgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfU0xPVFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVNsb3RzYCA6IGBgKTtcclxuY29uc3QgVE9fRElTUExBWV9TVFJJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvRGlzcGxheVN0cmluZ2AgOiBgYCk7XHJcbmNvbnN0IE1FUkdFX1BST1BTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBtZXJnZVByb3BzYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcnNgIDogYGApO1xyXG5jb25zdCBDQU1FTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FtZWxpemVgIDogYGApO1xyXG5jb25zdCBDQVBJVEFMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYXBpdGFsaXplYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUl9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcktleWAgOiBgYCk7XHJcbmNvbnN0IFNFVF9CTE9DS19UUkFDS0lORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc2V0QmxvY2tUcmFja2luZ2AgOiBgYCk7XHJcbmNvbnN0IFBVU0hfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHB1c2hTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgUE9QX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgV0lUSF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aFNjb3BlSWRgIDogYGApO1xyXG5jb25zdCBXSVRIX0NUWCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aEN0eGAgOiBgYCk7XHJcbmNvbnN0IFVOUkVGID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB1bnJlZmAgOiBgYCk7XHJcbmNvbnN0IElTX1JFRiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgaXNSZWZgIDogYGApO1xyXG4vLyBOYW1lIG1hcHBpbmcgZm9yIHJ1bnRpbWUgaGVscGVycyB0aGF0IG5lZWQgdG8gYmUgaW1wb3J0ZWQgZnJvbSAndnVlJyBpblxyXG4vLyBnZW5lcmF0ZWQgY29kZS4gTWFrZSBzdXJlIHRoZXNlIGFyZSBjb3JyZWN0bHkgZXhwb3J0ZWQgaW4gdGhlIHJ1bnRpbWUhXHJcbi8vIFVzaW5nIGBhbnlgIGhlcmUgYmVjYXVzZSBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbHMgYXMgaW5kZXggdHlwZS5cclxuY29uc3QgaGVscGVyTmFtZU1hcCA9IHtcclxuICAgIFtGUkFHTUVOVF06IGBGcmFnbWVudGAsXHJcbiAgICBbVEVMRVBPUlRdOiBgVGVsZXBvcnRgLFxyXG4gICAgW1NVU1BFTlNFXTogYFN1c3BlbnNlYCxcclxuICAgIFtLRUVQX0FMSVZFXTogYEtlZXBBbGl2ZWAsXHJcbiAgICBbQkFTRV9UUkFOU0lUSU9OXTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIFtPUEVOX0JMT0NLXTogYG9wZW5CbG9ja2AsXHJcbiAgICBbQ1JFQVRFX0JMT0NLXTogYGNyZWF0ZUJsb2NrYCxcclxuICAgIFtDUkVBVEVfVk5PREVdOiBgY3JlYXRlVk5vZGVgLFxyXG4gICAgW0NSRUFURV9DT01NRU5UXTogYGNyZWF0ZUNvbW1lbnRWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX1RFWFRdOiBgY3JlYXRlVGV4dFZOb2RlYCxcclxuICAgIFtDUkVBVEVfU1RBVElDXTogYGNyZWF0ZVN0YXRpY1ZOb2RlYCxcclxuICAgIFtSRVNPTFZFX0NPTVBPTkVOVF06IGByZXNvbHZlQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UXTogYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RJUkVDVElWRV06IGByZXNvbHZlRGlyZWN0aXZlYCxcclxuICAgIFtXSVRIX0RJUkVDVElWRVNdOiBgd2l0aERpcmVjdGl2ZXNgLFxyXG4gICAgW1JFTkRFUl9MSVNUXTogYHJlbmRlckxpc3RgLFxyXG4gICAgW1JFTkRFUl9TTE9UXTogYHJlbmRlclNsb3RgLFxyXG4gICAgW0NSRUFURV9TTE9UU106IGBjcmVhdGVTbG90c2AsXHJcbiAgICBbVE9fRElTUExBWV9TVFJJTkddOiBgdG9EaXNwbGF5U3RyaW5nYCxcclxuICAgIFtNRVJHRV9QUk9QU106IGBtZXJnZVByb3BzYCxcclxuICAgIFtUT19IQU5ETEVSU106IGB0b0hhbmRsZXJzYCxcclxuICAgIFtDQU1FTElaRV06IGBjYW1lbGl6ZWAsXHJcbiAgICBbQ0FQSVRBTElaRV06IGBjYXBpdGFsaXplYCxcclxuICAgIFtUT19IQU5ETEVSX0tFWV06IGB0b0hhbmRsZXJLZXlgLFxyXG4gICAgW1NFVF9CTE9DS19UUkFDS0lOR106IGBzZXRCbG9ja1RyYWNraW5nYCxcclxuICAgIFtQVVNIX1NDT1BFX0lEXTogYHB1c2hTY29wZUlkYCxcclxuICAgIFtQT1BfU0NPUEVfSURdOiBgcG9wU2NvcGVJZGAsXHJcbiAgICBbV0lUSF9TQ09QRV9JRF06IGB3aXRoU2NvcGVJZGAsXHJcbiAgICBbV0lUSF9DVFhdOiBgd2l0aEN0eGAsXHJcbiAgICBbVU5SRUZdOiBgdW5yZWZgLFxyXG4gICAgW0lTX1JFRl06IGBpc1JlZmBcclxufTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lSGVscGVycyhoZWxwZXJzKSB7XHJcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGhlbHBlcnMpLmZvckVhY2gocyA9PiB7XHJcbiAgICAgICAgaGVscGVyTmFtZU1hcFtzXSA9IGhlbHBlcnNbc107XHJcbiAgICB9KTtcclxufVxuXG4vLyBBU1QgVXRpbGl0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTb21lIGV4cHJlc3Npb25zLCBlLmcuIHNlcXVlbmNlIGFuZCBjb25kaXRpb25hbCBleHByZXNzaW9ucywgYXJlIG5ldmVyXHJcbi8vIGFzc29jaWF0ZWQgd2l0aCB0ZW1wbGF0ZSBub2Rlcywgc28gdGhlaXIgc291cmNlIGxvY2F0aW9ucyBhcmUganVzdCBhIHN0dWIuXHJcbi8vIENvbnRhaW5lciB0eXBlcyBsaWtlIENvbXBvdW5kRXhwcmVzc2lvbiBhbHNvIGRvbid0IG5lZWQgYSByZWFsIGxvY2F0aW9uLlxyXG5jb25zdCBsb2NTdHViID0ge1xyXG4gICAgc291cmNlOiAnJyxcclxuICAgIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH0sXHJcbiAgICBlbmQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVSb290KGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDAgLyogUk9PVCAqLyxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBoZWxwZXJzOiBbXSxcclxuICAgICAgICBjb21wb25lbnRzOiBbXSxcclxuICAgICAgICBkaXJlY3RpdmVzOiBbXSxcclxuICAgICAgICBob2lzdHM6IFtdLFxyXG4gICAgICAgIGltcG9ydHM6IFtdLFxyXG4gICAgICAgIGNhY2hlZDogMCxcclxuICAgICAgICB0ZW1wczogMCxcclxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBkaXJlY3RpdmVzLCBpc0Jsb2NrID0gZmFsc2UsIGRpc2FibGVUcmFja2luZyA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoQ1JFQVRFX1ZOT0RFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEzIC8qIFZOT0RFX0NBTEwgKi8sXHJcbiAgICAgICAgdGFnLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZGlyZWN0aXZlcyxcclxuICAgICAgICBpc0Jsb2NrLFxyXG4gICAgICAgIGRpc2FibGVUcmFja2luZyxcclxuICAgICAgICBsb2NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE3IC8qIEpTX0FSUkFZX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGVsZW1lbnRzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcywgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgcHJvcGVydGllc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIHZhbHVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE2IC8qIEpTX1BST1BFUlRZICovLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YixcclxuICAgICAgICBrZXk6IGlzU3RyaW5nKGtleSkgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleSwgdHJ1ZSkgOiBrZXksXHJcbiAgICAgICAgdmFsdWVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBpc1N0YXRpYywgbG9jID0gbG9jU3R1YiwgY29uc3RUeXBlID0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBpc1N0YXRpYyxcclxuICAgICAgICBjb25zdFR5cGU6IGlzU3RhdGljID8gMyAvKiBDQU5fU1RSSU5HSUZZICovIDogY29uc3RUeXBlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDUgLyogSU5URVJQT0xBVElPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudDogaXNTdHJpbmcoY29udGVudClcclxuICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBsb2MpXHJcbiAgICAgICAgICAgIDogY29udGVudFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjaGlsZHJlblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MgPSBbXSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNhbGxlZSxcclxuICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgcmV0dXJucyA9IHVuZGVmaW5lZCwgbmV3bGluZSA9IGZhbHNlLCBpc1Nsb3QgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOCAvKiBKU19GVU5DVElPTl9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHBhcmFtcyxcclxuICAgICAgICByZXR1cm5zLFxyXG4gICAgICAgIG5ld2xpbmUsXHJcbiAgICAgICAgaXNTbG90LFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBuZXdsaW5lID0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHRlc3QsXHJcbiAgICAgICAgY29uc2VxdWVudCxcclxuICAgICAgICBhbHRlcm5hdGUsXHJcbiAgICAgICAgbmV3bGluZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKGluZGV4LCB2YWx1ZSwgaXNWTm9kZSA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgaXNWTm9kZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMSAvKiBKU19CTE9DS19TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgYm9keSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVMaXRlcmFsKGVsZW1lbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi8sXHJcbiAgICAgICAgZWxlbWVudHMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMyAvKiBKU19JRl9TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgdGVzdCxcclxuICAgICAgICBjb25zZXF1ZW50LFxyXG4gICAgICAgIGFsdGVybmF0ZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24obGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjQgLyogSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxlZnQsXHJcbiAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGV4cHJlc3Npb25zLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNiAvKiBKU19SRVRVUk5fU1RBVEVNRU5UICovLFxyXG4gICAgICAgIHJldHVybnMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGlzU3RhdGljRXhwID0gKHApID0+IHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiBwLmlzU3RhdGljO1xyXG5jb25zdCBpc0J1aWx0SW5UeXBlID0gKHRhZywgZXhwZWN0ZWQpID0+IHRhZyA9PT0gZXhwZWN0ZWQgfHwgdGFnID09PSBoeXBoZW5hdGUoZXhwZWN0ZWQpO1xyXG5mdW5jdGlvbiBpc0NvcmVDb21wb25lbnQodGFnKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdUZWxlcG9ydCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIFRFTEVQT1JUO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdTdXNwZW5zZScpKSB7XHJcbiAgICAgICAgcmV0dXJuIFNVU1BFTlNFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdLZWVwQWxpdmUnKSkge1xyXG4gICAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdCYXNlVHJhbnNpdGlvbicpKSB7XHJcbiAgICAgICAgcmV0dXJuIEJBU0VfVFJBTlNJVElPTjtcclxuICAgIH1cclxufVxyXG5jb25zdCBub25JZGVudGlmaWVyUkUgPSAvXlxcZHxbXlxcJFxcd10vO1xyXG5jb25zdCBpc1NpbXBsZUlkZW50aWZpZXIgPSAobmFtZSkgPT4gIW5vbklkZW50aWZpZXJSRS50ZXN0KG5hbWUpO1xyXG5jb25zdCBtZW1iZXJFeHBSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXHMqXFwuXFxzKltBLVphLXpfJF1bXFx3JF0qfFxcW1teXFxdXStcXF0pKiQvO1xyXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb24gPSAocGF0aCkgPT4ge1xyXG4gICAgaWYgKCFwYXRoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBtZW1iZXJFeHBSRS50ZXN0KHBhdGgudHJpbSgpKTtcclxufTtcclxuZnVuY3Rpb24gZ2V0SW5uZXJSYW5nZShsb2MsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBsb2Muc291cmNlLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XHJcbiAgICBjb25zdCBuZXdMb2MgPSB7XHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHN0YXJ0OiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQpLFxyXG4gICAgICAgIGVuZDogbG9jLmVuZFxyXG4gICAgfTtcclxuICAgIGlmIChsZW5ndGggIT0gbnVsbCkge1xyXG4gICAgICAgIG5ld0xvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQgKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0xvYztcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oZXh0ZW5kKHt9LCBwb3MpLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuLy8gYWR2YW5jZSBieSBtdXRhdGlvbiB3aXRob3V0IGNsb25pbmcgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSwgc2luY2UgdGhpc1xyXG4vLyBnZXRzIGNhbGxlZCBhIGxvdCBpbiB0aGUgcGFyc2VyXHJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgbGV0IGxpbmVzQ291bnQgPSAwO1xyXG4gICAgbGV0IGxhc3ROZXdMaW5lUG9zID0gLTE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhcmFjdGVyczsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGkpID09PSAxMCAvKiBuZXdsaW5lIGNoYXIgY29kZSAqLykge1xyXG4gICAgICAgICAgICBsaW5lc0NvdW50Kys7XHJcbiAgICAgICAgICAgIGxhc3ROZXdMaW5lUG9zID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3Mub2Zmc2V0ICs9IG51bWJlck9mQ2hhcmFjdGVycztcclxuICAgIHBvcy5saW5lICs9IGxpbmVzQ291bnQ7XHJcbiAgICBwb3MuY29sdW1uID1cclxuICAgICAgICBsYXN0TmV3TGluZVBvcyA9PT0gLTFcclxuICAgICAgICAgICAgPyBwb3MuY29sdW1uICsgbnVtYmVyT2ZDaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgIDogbnVtYmVyT2ZDaGFyYWN0ZXJzIC0gbGFzdE5ld0xpbmVQb3M7XHJcbiAgICByZXR1cm4gcG9zO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgYHVuZXhwZWN0ZWQgY29tcGlsZXIgY29uZGl0aW9uYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZERpcihub2RlLCBuYW1lLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgIChhbGxvd0VtcHR5IHx8IHAuZXhwKSAmJlxyXG4gICAgICAgICAgICAoaXNTdHJpbmcobmFtZSkgPyBwLm5hbWUgPT09IG5hbWUgOiBuYW1lLnRlc3QocC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmRQcm9wKG5vZGUsIG5hbWUsIGR5bmFtaWNPbmx5ID0gZmFsc2UsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNPbmx5KVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09IG5hbWUgJiYgKHAudmFsdWUgfHwgYWxsb3dFbXB0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgICAgIChwLmV4cCB8fCBhbGxvd0VtcHR5KSAmJlxyXG4gICAgICAgICAgICBpc0JpbmRLZXkocC5hcmcsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0JpbmRLZXkoYXJnLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gISEoYXJnICYmIGlzU3RhdGljRXhwKGFyZykgJiYgYXJnLmNvbnRlbnQgPT09IG5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5wcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgIHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgKCFwLmFyZyB8fCAvLyB2LWJpbmQ9XCJvYmpcIlxyXG4gICAgICAgICAgICBwLmFyZy50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8IC8vIHYtYmluZDpbX2N0eC5mb29dXHJcbiAgICAgICAgICAgICFwLmFyZy5pc1N0YXRpYykgLy8gdi1iaW5kOltmb29dXHJcbiAgICApO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHwgbm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi87XHJcbn1cclxuZnVuY3Rpb24gaXNWU2xvdChwKSB7XHJcbiAgICByZXR1cm4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdzbG90JztcclxufVxyXG5mdW5jdGlvbiBpc1RlbXBsYXRlTm9kZShub2RlKSB7XHJcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyk7XHJcbn1cclxuZnVuY3Rpb24gaXNTbG90T3V0bGV0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBub2RlLnRhZ1R5cGUgPT09IDIgLyogU0xPVCAqLztcclxufVxyXG5mdW5jdGlvbiBpbmplY3RQcm9wKG5vZGUsIHByb3AsIGNvbnRleHQpIHtcclxuICAgIGxldCBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICBjb25zdCBwcm9wcyA9IG5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLyA/IG5vZGUucHJvcHMgOiBub2RlLmFyZ3VtZW50c1syXTtcclxuICAgIGlmIChwcm9wcyA9PSBudWxsIHx8IGlzU3RyaW5nKHByb3BzKSkge1xyXG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIC8vIG1lcmdlZCBwcm9wcy4uLiBhZGQgb3Vyc1xyXG4gICAgICAgIC8vIG9ubHkgaW5qZWN0IGtleSB0byBvYmplY3QgbGl0ZXJhbCBpZiBpdCdzIHRoZSBmaXJzdCBhcmd1bWVudCBzbyB0aGF0XHJcbiAgICAgICAgLy8gaWYgZG9lc24ndCBvdmVycmlkZSB1c2VyIHByb3ZpZGVkIGtleXNcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHByb3BzLmFyZ3VtZW50c1swXTtcclxuICAgICAgICBpZiAoIWlzU3RyaW5nKGZpcnN0KSAmJiBmaXJzdC50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBmaXJzdC5wcm9wZXJ0aWVzLnVuc2hpZnQocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuY2FsbGVlID09PSBUT19IQU5ETEVSUykge1xyXG4gICAgICAgICAgICAgICAgLy8gIzIzNjZcclxuICAgICAgICAgICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1xyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5hcmd1bWVudHMudW5zaGlmdChjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICFwcm9wc1dpdGhJbmplY3Rpb24gJiYgKHByb3BzV2l0aEluamVjdGlvbiA9IHByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgbGV0IGFscmVhZHlFeGlzdHMgPSBmYWxzZTtcclxuICAgICAgICAvLyBjaGVjayBleGlzdGluZyBrZXkgdG8gYXZvaWQgb3ZlcnJpZGluZyB1c2VyIHByb3ZpZGVkIGtleXNcclxuICAgICAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wS2V5TmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGFscmVhZHlFeGlzdHMgPSBwcm9wcy5wcm9wZXJ0aWVzLnNvbWUocCA9PiBwLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgICAgICAgICBwLmtleS5jb250ZW50ID09PSBwcm9wS2V5TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxyZWFkeUV4aXN0cykge1xyXG4gICAgICAgICAgICBwcm9wcy5wcm9wZXJ0aWVzLnVuc2hpZnQocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IHByb3BzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2luZ2xlIHYtYmluZCB3aXRoIGV4cHJlc3Npb24sIHJldHVybiBhIG1lcmdlZCByZXBsYWNlbWVudFxyXG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSksXHJcbiAgICAgICAgICAgIHByb3BzXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgbm9kZS5wcm9wcyA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5vZGUuYXJndW1lbnRzWzJdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvVmFsaWRBc3NldElkKG5hbWUsIHR5cGUpIHtcclxuICAgIHJldHVybiBgXyR7dHlwZX1fJHtuYW1lLnJlcGxhY2UoL1teXFx3XS9nLCAnXycpfWA7XHJcbn1cclxuLy8gQ2hlY2sgaWYgYSBub2RlIGNvbnRhaW5zIGV4cHJlc3Npb25zIHRoYXQgcmVmZXJlbmNlIGN1cnJlbnQgY29udGV4dCBzY29wZSBpZHNcclxuZnVuY3Rpb24gaGFzU2NvcGVSZWYobm9kZSwgaWRzKSB7XHJcbiAgICBpZiAoIW5vZGUgfHwgT2JqZWN0LmtleXMoaWRzKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAoaGFzU2NvcGVSZWYocC5hcmcsIGlkcykgfHwgaGFzU2NvcGVSZWYocC5leHAsIGlkcykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgICAgICBpZiAoaGFzU2NvcGVSZWYobm9kZS5zb3VyY2UsIGlkcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmJyYW5jaGVzLnNvbWUoYiA9PiBoYXNTY29wZVJlZihiLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuY29uZGl0aW9uLCBpZHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gKCFub2RlLmlzU3RhdGljICYmXHJcbiAgICAgICAgICAgICAgICBpc1NpbXBsZUlkZW50aWZpZXIobm9kZS5jb250ZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgISFpZHNbbm9kZS5jb250ZW50XSk7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBpc09iamVjdChjKSAmJiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICBjYXNlIDEyIC8qIFRFWFRfQ0FMTCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGhhc1Njb3BlUmVmKG5vZGUuY29udGVudCwgaWRzKTtcclxuICAgICAgICBjYXNlIDIgLyogVEVYVCAqLzpcclxuICAgICAgICBjYXNlIDMgLyogQ09NTUVOVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbi8vIFRoZSBkZWZhdWx0IGRlY29kZXIgb25seSBwcm92aWRlcyBlc2NhcGVzIGZvciBjaGFyYWN0ZXJzIHJlc2VydmVkIGFzIHBhcnQgb2ZcclxuLy8gdGhlIHRlbXBsYXRlIHN5bnRheCwgYW5kIGlzIG9ubHkgdXNlZCBpZiB0aGUgY3VzdG9tIHJlbmRlcmVyIGRpZCBub3QgcHJvdmlkZVxyXG4vLyBhIHBsYXRmb3JtLXNwZWNpZmljIGRlY29kZXIuXHJcbmNvbnN0IGRlY29kZVJFID0gLyYoZ3R8bHR8YW1wfGFwb3N8cXVvdCk7L2c7XHJcbmNvbnN0IGRlY29kZU1hcCA9IHtcclxuICAgIGd0OiAnPicsXHJcbiAgICBsdDogJzwnLFxyXG4gICAgYW1wOiAnJicsXHJcbiAgICBhcG9zOiBcIidcIixcclxuICAgIHF1b3Q6ICdcIidcclxufTtcclxuY29uc3QgZGVmYXVsdFBhcnNlck9wdGlvbnMgPSB7XHJcbiAgICBkZWxpbWl0ZXJzOiBbYHt7YCwgYH19YF0sXHJcbiAgICBnZXROYW1lc3BhY2U6ICgpID0+IDAgLyogSFRNTCAqLyxcclxuICAgIGdldFRleHRNb2RlOiAoKSA9PiAwIC8qIERBVEEgKi8sXHJcbiAgICBpc1ZvaWRUYWc6IE5PLFxyXG4gICAgaXNQcmVUYWc6IE5PLFxyXG4gICAgaXNDdXN0b21FbGVtZW50OiBOTyxcclxuICAgIGRlY29kZUVudGl0aWVzOiAocmF3VGV4dCkgPT4gcmF3VGV4dC5yZXBsYWNlKGRlY29kZVJFLCAoXywgcDEpID0+IGRlY29kZU1hcFtwMV0pLFxyXG4gICAgb25FcnJvcjogZGVmYXVsdE9uRXJyb3IsXHJcbiAgICBjb21tZW50czogZmFsc2VcclxufTtcclxuZnVuY3Rpb24gYmFzZVBhcnNlKGNvbnRlbnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgb3B0aW9ucyk7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIHJldHVybiBjcmVhdGVSb290KHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMCAvKiBEQVRBICovLCBbXSksIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgcmF3T3B0aW9ucykge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdFBhcnNlck9wdGlvbnMpO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3T3B0aW9ucykge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBvcHRpb25zW2tleV0gPSByYXdPcHRpb25zW2tleV0gfHwgZGVmYXVsdFBhcnNlck9wdGlvbnNba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICBjb2x1bW46IDEsXHJcbiAgICAgICAgbGluZTogMSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IGNvbnRlbnQsXHJcbiAgICAgICAgc291cmNlOiBjb250ZW50LFxyXG4gICAgICAgIGluUHJlOiBmYWxzZSxcclxuICAgICAgICBpblZQcmU6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICBjb25zdCBucyA9IHBhcmVudCA/IHBhcmVudC5ucyA6IDAgLyogSFRNTCAqLztcclxuICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICB3aGlsZSAoIWlzRW5kKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykpIHtcclxuICAgICAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKG1vZGUgPT09IDAgLyogREFUQSAqLyB8fCBtb2RlID09PSAxIC8qIFJDREFUQSAqLykge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIHN0YXJ0c1dpdGgocywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAne3snXHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IDAgLyogREFUQSAqLyAmJiBzWzBdID09PSAnPCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0YWctb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnIScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjbWFya3VwLWRlY2xhcmF0aW9uLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnPCEtLScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGgocywgJzwhRE9DVFlQRScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBET0NUWVBFIGJ5IGEgbGltaXRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydHNXaXRoKHMsICc8IVtDREFUQVsnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnMgIT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQ0RBVEEoY29udGV4dCwgYW5jZXN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxIC8qIENEQVRBX0lOX0hUTUxfQ09OVEVOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMSAvKiBJTkNPUlJFQ1RMWV9PUEVORURfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjZW5kLXRhZy1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA1IC8qIEVPRl9CRUZPUkVfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzJdID09PSAnPicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE0IC8qIE1JU1NJTkdfRU5EX1RBR19OQU1FICovLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL1thLXpdL2kudGVzdChzWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjMgLyogWF9JTlZBTElEX0VORF9UQUcgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIEVuZCAqLywgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTIgLyogSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL1thLXpdL2kudGVzdChzWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMSAvKiBVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBXaGl0ZXNwYWNlIG1hbmFnZW1lbnQgZm9yIG1vcmUgZWZmaWNpZW50IG91dHB1dFxyXG4gICAgLy8gKHNhbWUgYXMgdjIgd2hpdGVzcGFjZTogJ2NvbmRlbnNlJylcclxuICAgIGxldCByZW1vdmVkV2hpdGVzcGFjZSA9IGZhbHNlO1xyXG4gICAgaWYgKG1vZGUgIT09IDIgLyogUkFXVEVYVCAqLykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaW5QcmUgJiYgbm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmICghL1teXFx0XFxyXFxuXFxmIF0vLnRlc3Qobm9kZS5jb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBub2Rlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGVzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSB3aGl0ZXNwYWNlIGlzIHRoZSBmaXJzdCBvciBsYXN0IG5vZGUsIG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlIHdoaXRlc3BhY2UgaXMgYWRqYWNlbnQgdG8gYSBjb21tZW50LCBvcjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSB3aGl0ZXNwYWNlIGlzIGJldHdlZW4gdHdvIGVsZW1lbnRzIEFORCBjb250YWlucyBuZXdsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiB0aGUgd2hpdGVzcGFjZSBpcyBpZ25vcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhbmV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvW1xcclxcbl0vLnRlc3Qobm9kZS5jb250ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNvbmRlbnNlZCBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRvIGEgc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9ICcgJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSgvW1xcdFxcclxcblxcZiBdKy9nLCAnICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gcmVtb3ZlIGNvbW1lbnQgbm9kZXMgaW4gcHJvZCBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbnRleHQub3B0aW9ucy5jb21tZW50cykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0LmluUHJlICYmIHBhcmVudCAmJiBjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcocGFyZW50LnRhZykpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgbmV3bGluZSBwZXIgaHRtbCBzcGVjXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2dyb3VwaW5nLWNvbnRlbnQuaHRtbCN0aGUtcHJlLWVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBub2Rlc1swXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGZpcnN0LnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QuY29udGVudCA9IGZpcnN0LmNvbnRlbnQucmVwbGFjZSgvXlxccj9cXG4vLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlZFdoaXRlc3BhY2UgPyBub2Rlcy5maWx0ZXIoQm9vbGVhbikgOiBub2RlcztcclxufVxyXG5mdW5jdGlvbiBwdXNoTm9kZShub2Rlcywgbm9kZSkge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgY29uc3QgcHJldiA9IGxhc3Qobm9kZXMpO1xyXG4gICAgICAgIC8vIE1lcmdlIGlmIGJvdGggdGhpcyBhbmQgdGhlIHByZXZpb3VzIG5vZGUgYXJlIHRleHQgYW5kIHRob3NlIGFyZVxyXG4gICAgICAgIC8vIGNvbnNlY3V0aXZlLiBUaGlzIGhhcHBlbnMgZm9yIGNhc2VzIGxpa2UgXCJhIDwgYlwiLlxyXG4gICAgICAgIGlmIChwcmV2ICYmXHJcbiAgICAgICAgICAgIHByZXYudHlwZSA9PT0gMiAvKiBURVhUICovICYmXHJcbiAgICAgICAgICAgIHByZXYubG9jLmVuZC5vZmZzZXQgPT09IG5vZGUubG9jLnN0YXJ0Lm9mZnNldCkge1xyXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnQgKz0gbm9kZS5jb250ZW50O1xyXG4gICAgICAgICAgICBwcmV2LmxvYy5lbmQgPSBub2RlLmxvYy5lbmQ7XHJcbiAgICAgICAgICAgIHByZXYubG9jLnNvdXJjZSArPSBub2RlLmxvYy5zb3VyY2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ0RBVEEoY29udGV4dCwgYW5jZXN0b3JzKSB7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgOSk7XHJcbiAgICBjb25zdCBub2RlcyA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMyAvKiBDREFUQSAqLywgYW5jZXN0b3JzKTtcclxuICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNiAvKiBFT0ZfSU5fQ0RBVEEgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ29tbWVudChjb250ZXh0KSB7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgLy8gUmVndWxhciBjb21tZW50LlxyXG4gICAgY29uc3QgbWF0Y2ggPSAvLS0oXFwhKT8+Ly5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDcgLyogRU9GX0lOX0NPTU1FTlQgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG1hdGNoLmluZGV4IDw9IDMpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDAgLyogQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTAgLyogSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCwgbWF0Y2guaW5kZXgpO1xyXG4gICAgICAgIC8vIEFkdmFuY2luZyB3aXRoIHJlcG9ydGluZyBuZXN0ZWQgY29tbWVudHMuXHJcbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICBsZXQgcHJldkluZGV4ID0gMSwgbmVzdGVkSW5kZXggPSAwO1xyXG4gICAgICAgIHdoaWxlICgobmVzdGVkSW5kZXggPSBzLmluZGV4T2YoJzwhLS0nLCBwcmV2SW5kZXgpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5lc3RlZEluZGV4IC0gcHJldkluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChuZXN0ZWRJbmRleCArIDQgPCBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE2IC8qIE5FU1RFRF9DT01NRU5UICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2SW5kZXggPSBuZXN0ZWRJbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAtIHByZXZJbmRleCArIDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAzIC8qIENPTU1FTlQgKi8sXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjb250ZW50U3RhcnQgPSBjb250ZXh0LnNvdXJjZVsxXSA9PT0gJz8nID8gMSA6IDI7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKCc+Jyk7XHJcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoY29udGVudFN0YXJ0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZShjb250ZW50U3RhcnQsIGNsb3NlSW5kZXgpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjbG9zZUluZGV4ICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDMgLyogQ09NTUVOVCAqLyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKSB7XHJcbiAgICAvLyBTdGFydCB0YWcuXHJcbiAgICBjb25zdCB3YXNJblByZSA9IGNvbnRleHQuaW5QcmU7XHJcbiAgICBjb25zdCB3YXNJblZQcmUgPSBjb250ZXh0LmluVlByZTtcclxuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZVRhZyhjb250ZXh0LCAwIC8qIFN0YXJ0ICovLCBwYXJlbnQpO1xyXG4gICAgY29uc3QgaXNQcmVCb3VuZGFyeSA9IGNvbnRleHQuaW5QcmUgJiYgIXdhc0luUHJlO1xyXG4gICAgY29uc3QgaXNWUHJlQm91bmRhcnkgPSBjb250ZXh0LmluVlByZSAmJiAhd2FzSW5WUHJlO1xyXG4gICAgaWYgKGVsZW1lbnQuaXNTZWxmQ2xvc2luZyB8fCBjb250ZXh0Lm9wdGlvbnMuaXNWb2lkVGFnKGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG4gICAgLy8gQ2hpbGRyZW4uXHJcbiAgICBhbmNlc3RvcnMucHVzaChlbGVtZW50KTtcclxuICAgIGNvbnN0IG1vZGUgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0VGV4dE1vZGUoZWxlbWVudCwgcGFyZW50KTtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyc2VDaGlsZHJlbihjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpO1xyXG4gICAgYW5jZXN0b3JzLnBvcCgpO1xyXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgLy8gRW5kIHRhZy5cclxuICAgIGlmIChzdGFydHNXaXRoRW5kVGFnT3Blbihjb250ZXh0LnNvdXJjZSwgZWxlbWVudC50YWcpKSB7XHJcbiAgICAgICAgcGFyc2VUYWcoY29udGV4dCwgMSAvKiBFbmQgKi8sIHBhcmVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjQgLyogWF9NSVNTSU5HX0VORF9UQUcgKi8sIDAsIGVsZW1lbnQubG9jLnN0YXJ0KTtcclxuICAgICAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwICYmIGVsZW1lbnQudGFnLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBzdGFydHNXaXRoKGZpcnN0LmxvYy5zb3VyY2UsICc8IS0tJykpIHtcclxuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA4IC8qIEVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBlbGVtZW50LmxvYy5zdGFydCk7XHJcbiAgICBpZiAoaXNQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5QcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpc1ZQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5jb25zdCBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgaWYsZWxzZSxlbHNlLWlmLGZvcixzbG90YCk7XHJcbi8qKlxyXG4gKiBQYXJzZSBhIHRhZyAoRS5nLiBgPGRpdiBpZD1hPmApIHdpdGggdGhhdCB0eXBlIChzdGFydCB0YWcgb3IgZW5kIHRhZykuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVRhZyhjb250ZXh0LCB0eXBlLCBwYXJlbnQpIHtcclxuICAgIC8vIFRhZyBvcGVuLlxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBtYXRjaCA9IC9ePFxcLz8oW2Etel1bXlxcdFxcclxcblxcZiAvPl0qKS9pLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgY29uc3QgdGFnID0gbWF0Y2hbMV07XHJcbiAgICBjb25zdCBucyA9IGNvbnRleHQub3B0aW9ucy5nZXROYW1lc3BhY2UodGFnLCBwYXJlbnQpO1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgLy8gc2F2ZSBjdXJyZW50IHN0YXRlIGluIGNhc2Ugd2UgbmVlZCB0byByZS1wYXJzZSBhdHRyaWJ1dGVzIHdpdGggdi1wcmVcclxuICAgIGNvbnN0IGN1cnNvciA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGN1cnJlbnRTb3VyY2UgPSBjb250ZXh0LnNvdXJjZTtcclxuICAgIC8vIEF0dHJpYnV0ZXMuXHJcbiAgICBsZXQgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSk7XHJcbiAgICAvLyBjaGVjayA8cHJlPiB0YWdcclxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcodGFnKSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5QcmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgdi1wcmVcclxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiZcclxuICAgICAgICBwcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdwcmUnKSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gdHJ1ZTtcclxuICAgICAgICAvLyByZXNldCBjb250ZXh0XHJcbiAgICAgICAgZXh0ZW5kKGNvbnRleHQsIGN1cnNvcik7XHJcbiAgICAgICAgY29udGV4dC5zb3VyY2UgPSBjdXJyZW50U291cmNlO1xyXG4gICAgICAgIC8vIHJlLXBhcnNlIGF0dHJzIGFuZCBmaWx0ZXIgb3V0IHYtcHJlIGl0c2VsZlxyXG4gICAgICAgIHByb3BzID0gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpLmZpbHRlcihwID0+IHAubmFtZSAhPT0gJ3YtcHJlJyk7XHJcbiAgICB9XHJcbiAgICAvLyBUYWcgY2xvc2UuXHJcbiAgICBsZXQgaXNTZWxmQ2xvc2luZyA9IGZhbHNlO1xyXG4gICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA5IC8qIEVPRl9JTl9UQUcgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaXNTZWxmQ2xvc2luZyA9IHN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLyAmJiBpc1NlbGZDbG9zaW5nKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA0IC8qIEVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGlzU2VsZkNsb3NpbmcgPyAyIDogMSk7XHJcbiAgICB9XHJcbiAgICBsZXQgdGFnVHlwZSA9IDAgLyogRUxFTUVOVCAqLztcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmICFvcHRpb25zLmlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XHJcbiAgICAgICAgY29uc3QgaGFzVklzID0gcHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnaXMnKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5pc05hdGl2ZVRhZyAmJiAhaGFzVklzKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5pc05hdGl2ZVRhZyh0YWcpKVxyXG4gICAgICAgICAgICAgICAgdGFnVHlwZSA9IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNWSXMgfHxcclxuICAgICAgICAgICAgaXNDb3JlQ29tcG9uZW50KHRhZykgfHxcclxuICAgICAgICAgICAgKG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50ICYmIG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50KHRhZykpIHx8XHJcbiAgICAgICAgICAgIC9eW0EtWl0vLnRlc3QodGFnKSB8fFxyXG4gICAgICAgICAgICB0YWcgPT09ICdjb21wb25lbnQnKSB7XHJcbiAgICAgICAgICAgIHRhZ1R5cGUgPSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgICAgIHRhZ1R5cGUgPSAyIC8qIFNMT1QgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3RlbXBsYXRlJyAmJlxyXG4gICAgICAgICAgICBwcm9wcy5zb21lKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpO1xyXG4gICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICB0YWdUeXBlID0gMyAvKiBURU1QTEFURSAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEgLyogRUxFTUVOVCAqLyxcclxuICAgICAgICBucyxcclxuICAgICAgICB0YWcsXHJcbiAgICAgICAgdGFnVHlwZSxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBpc1NlbGZDbG9zaW5nLFxyXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCksXHJcbiAgICAgICAgY29kZWdlbk5vZGU6IHVuZGVmaW5lZCAvLyB0byBiZSBjcmVhdGVkIGR1cmluZyB0cmFuc2Zvcm0gcGhhc2VcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpIHtcclxuICAgIGNvbnN0IHByb3BzID0gW107XHJcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcclxuICAgIHdoaWxlIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICc+JykgJiZcclxuICAgICAgICAhc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+JykpIHtcclxuICAgICAgICBpZiAoc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8nKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjIgLyogVU5FWFBFQ1RFRF9TT0xJRFVTX0lOX1RBRyAqLyk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLykge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMyAvKiBFTkRfVEFHX1dJVEhfQVRUUklCVVRFUyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBwYXJzZUF0dHJpYnV0ZShjb250ZXh0LCBhdHRyaWJ1dGVOYW1lcyk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDAgLyogU3RhcnQgKi8pIHtcclxuICAgICAgICAgICAgcHJvcHMucHVzaChhdHRyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKC9eW15cXHRcXHJcXG5cXGYgLz5dLy50ZXN0KGNvbnRleHQuc291cmNlKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTUgLyogTUlTU0lOR19XSElURVNQQUNFX0JFVFdFRU5fQVRUUklCVVRFUyAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGUoY29udGV4dCwgbmFtZVNldCkge1xyXG4gICAgLy8gTmFtZS5cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgbWF0Y2ggPSAvXlteXFx0XFxyXFxuXFxmIC8+XVteXFx0XFxyXFxuXFxmIC8+PV0qLy5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGNvbnN0IG5hbWUgPSBtYXRjaFswXTtcclxuICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyIC8qIERVUExJQ0FURV9BVFRSSUJVVEUgKi8pO1xyXG4gICAgfVxyXG4gICAgbmFtZVNldC5hZGQobmFtZSk7XHJcbiAgICBpZiAobmFtZVswXSA9PT0gJz0nKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE5IC8qIFVORVhQRUNURURfRVFVQUxTX1NJR05fQkVGT1JFX0FUVFJJQlVURV9OQU1FICovKTtcclxuICAgIH1cclxuICAgIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gL1tcIic8XS9nO1xyXG4gICAgICAgIGxldCBtO1xyXG4gICAgICAgIHdoaWxlICgobSA9IHBhdHRlcm4uZXhlYyhuYW1lKSkpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE3IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX0FUVFJJQlVURV9OQU1FICovLCBtLmluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbmFtZS5sZW5ndGgpO1xyXG4gICAgLy8gVmFsdWVcclxuICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgIGlmICgvXltcXHRcXHJcXG5cXGYgXSo9Ly50ZXN0KGNvbnRleHQuc291cmNlKSkge1xyXG4gICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUF0dHJpYnV0ZVZhbHVlKGNvbnRleHQpO1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEzIC8qIE1JU1NJTkdfQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBsb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpO1xyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiAvXih2LXw6fEB8IykvLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IC8oPzpedi0oW2EtejAtOS1dKykpPyg/Oig/Ojp8XkB8XiMpKFxcW1teXFxdXStcXF18W15cXC5dKykpPyguKyk/JC9pLmV4ZWMobmFtZSk7XHJcbiAgICAgICAgY29uc3QgZGlyTmFtZSA9IG1hdGNoWzFdIHx8XHJcbiAgICAgICAgICAgIChzdGFydHNXaXRoKG5hbWUsICc6JykgPyAnYmluZCcgOiBzdGFydHNXaXRoKG5hbWUsICdAJykgPyAnb24nIDogJ3Nsb3QnKTtcclxuICAgICAgICBsZXQgYXJnO1xyXG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1Nsb3QgPSBkaXJOYW1lID09PSAnc2xvdCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmFtZS5pbmRleE9mKG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCksIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBzdGFydE9mZnNldCArIG1hdGNoWzJdLmxlbmd0aCArICgoaXNTbG90ICYmIG1hdGNoWzNdKSB8fCAnJykubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gbWF0Y2hbMl07XHJcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJ1snKSkge1xyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5lbmRzV2l0aCgnXScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI2IC8qIFhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyKDEsIGNvbnRlbnQubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjMTI0MSBzcGVjaWFsIGNhc2UgZm9yIHYtc2xvdDogdnVldGlmeSByZWxpZXMgZXh0ZW5zaXZlbHkgb24gc2xvdFxyXG4gICAgICAgICAgICAgICAgLy8gbmFtZXMgY29udGFpbmluZyBkb3RzLiB2LXNsb3QgZG9lc24ndCBoYXZlIGFueSBtb2RpZmllcnMgYW5kIFZ1ZSAyLnhcclxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRzIHN1Y2ggdXNhZ2Ugc28gd2UgYXJlIGtlZXBpbmcgaXQgY29uc2lzdGVudCB3aXRoIDIueC5cclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gbWF0Y2hbM10gfHwgJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJnID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyxcclxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogaXNTdGF0aWNcclxuICAgICAgICAgICAgICAgICAgICA/IDMgLyogQ0FOX1NUUklOR0lGWSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgICAgICBsb2NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzUXVvdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTG9jID0gdmFsdWUubG9jO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zdGFydC5vZmZzZXQrKztcclxuICAgICAgICAgICAgdmFsdWVMb2Muc3RhcnQuY29sdW1uKys7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLmVuZCA9IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSh2YWx1ZUxvYy5zdGFydCwgdmFsdWUuY29udGVudCk7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnNvdXJjZSA9IHZhbHVlTG9jLnNvdXJjZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDcgLyogRElSRUNUSVZFICovLFxyXG4gICAgICAgICAgICBuYW1lOiBkaXJOYW1lLFxyXG4gICAgICAgICAgICBleHA6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgYXMgbm9uLWNvbnN0YW50IGJ5IGRlZmF1bHQuIFRoaXMgY2FuIGJlIHBvdGVudGlhbGx5IHNldCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdmFsdWVzIGJ5IGB0cmFuc2Zvcm1FeHByZXNzaW9uYCB0byBtYWtlIGl0IGVsaWdpYmxlIGZvciBob2lzdGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVyczogbWF0Y2hbM10gPyBtYXRjaFszXS5zdWJzdHIoMSkuc3BsaXQoJy4nKSA6IFtdLFxyXG4gICAgICAgICAgICBsb2NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiA2IC8qIEFUVFJJQlVURSAqLyxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSAmJiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDIgLyogVEVYVCAqLyxcclxuICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcclxuICAgICAgICAgICAgbG9jOiB2YWx1ZS5sb2NcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVZhbHVlKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBjb25zdCBxdW90ZSA9IGNvbnRleHQuc291cmNlWzBdO1xyXG4gICAgY29uc3QgaXNRdW90ZWQgPSBxdW90ZSA9PT0gYFwiYCB8fCBxdW90ZSA9PT0gYCdgO1xyXG4gICAgaWYgKGlzUXVvdGVkKSB7XHJcbiAgICAgICAgLy8gUXVvdGVkIHZhbHVlLlxyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YocXVvdGUpO1xyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoLCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBlbmRJbmRleCwgNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVW5xdW90ZWRcclxuICAgICAgICBjb25zdCBtYXRjaCA9IC9eW15cXHRcXHJcXG5cXGYgPl0rLy5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuZXhwZWN0ZWRDaGFycyA9IC9bXCInPD1gXS9nO1xyXG4gICAgICAgIGxldCBtO1xyXG4gICAgICAgIHdoaWxlICgobSA9IHVuZXhwZWN0ZWRDaGFycy5leGVjKG1hdGNoWzBdKSkpIHtcclxuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE4IC8qIFVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqLywgbS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIG1hdGNoWzBdLmxlbmd0aCwgNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgY29udGVudCwgaXNRdW90ZWQsIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlSW50ZXJwb2xhdGlvbihjb250ZXh0LCBtb2RlKSB7XHJcbiAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnM7XHJcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihjbG9zZSwgb3Blbi5sZW5ndGgpO1xyXG4gICAgaWYgKGNsb3NlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI1IC8qIFhfTUlTU0lOR19JTlRFUlBPTEFUSU9OX0VORCAqLyk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG9wZW4ubGVuZ3RoKTtcclxuICAgIGNvbnN0IGlubmVyU3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBpbm5lckVuZCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IHJhd0NvbnRlbnRMZW5ndGggPSBjbG9zZUluZGV4IC0gb3Blbi5sZW5ndGg7XHJcbiAgICBjb25zdCByYXdDb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgcmF3Q29udGVudExlbmd0aCk7XHJcbiAgICBjb25zdCBwcmVUcmltQ29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgcmF3Q29udGVudExlbmd0aCwgbW9kZSk7XHJcbiAgICBjb25zdCBjb250ZW50ID0gcHJlVHJpbUNvbnRlbnQudHJpbSgpO1xyXG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBwcmVUcmltQ29udGVudC5pbmRleE9mKGNvbnRlbnQpO1xyXG4gICAgaWYgKHN0YXJ0T2Zmc2V0ID4gMCkge1xyXG4gICAgICAgIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihpbm5lclN0YXJ0LCByYXdDb250ZW50LCBzdGFydE9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbmRPZmZzZXQgPSByYXdDb250ZW50TGVuZ3RoIC0gKHByZVRyaW1Db250ZW50Lmxlbmd0aCAtIGNvbnRlbnQubGVuZ3RoIC0gc3RhcnRPZmZzZXQpO1xyXG4gICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyRW5kLCByYXdDb250ZW50LCBlbmRPZmZzZXQpO1xyXG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNsb3NlLmxlbmd0aCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDUgLyogSU5URVJQT0xBVElPTiAqLyxcclxuICAgICAgICBjb250ZW50OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gU2V0IGBpc0NvbnN0YW50YCB0byBmYWxzZSBieSBkZWZhdWx0IGFuZCB3aWxsIGRlY2lkZSBpbiB0cmFuc2Zvcm1FeHByZXNzaW9uXHJcbiAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBOT1RfQ09OU1RBTlQgKi8sXHJcbiAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGlubmVyU3RhcnQsIGlubmVyRW5kKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKSB7XHJcbiAgICBjb25zdCBlbmRUb2tlbnMgPSBbJzwnLCBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVyc1swXV07XHJcbiAgICBpZiAobW9kZSA9PT0gMyAvKiBDREFUQSAqLykge1xyXG4gICAgICAgIGVuZFRva2Vucy5wdXNoKCddXT4nKTtcclxuICAgIH1cclxuICAgIGxldCBlbmRJbmRleCA9IGNvbnRleHQuc291cmNlLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kVG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKGVuZFRva2Vuc1tpXSwgMSk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBlbmRJbmRleCA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgIGVuZEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBlbmRJbmRleCwgbW9kZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIgLyogVEVYVCAqLyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogR2V0IHRleHQgZGF0YSB3aXRoIGEgZ2l2ZW4gbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24uXHJcbiAqIFRoaXMgdHJhbnNsYXRlcyBIVE1MIGVudGl0aWVzIGluIHRoZSB0ZXh0IGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVRleHREYXRhKGNvbnRleHQsIGxlbmd0aCwgbW9kZSkge1xyXG4gICAgY29uc3QgcmF3VGV4dCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIGxlbmd0aCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbGVuZ3RoKTtcclxuICAgIGlmIChtb2RlID09PSAyIC8qIFJBV1RFWFQgKi8gfHxcclxuICAgICAgICBtb2RlID09PSAzIC8qIENEQVRBICovIHx8XHJcbiAgICAgICAgcmF3VGV4dC5pbmRleE9mKCcmJykgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1RleHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBEQVRBIG9yIFJDREFUQSBjb250YWluaW5nIFwiJlwiXCIuIEVudGl0eSBkZWNvZGluZyByZXF1aXJlZC5cclxuICAgICAgICByZXR1cm4gY29udGV4dC5vcHRpb25zLmRlY29kZUVudGl0aWVzKHJhd1RleHQsIG1vZGUgPT09IDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDdXJzb3IoY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBjb2x1bW4sIGxpbmUsIG9mZnNldCB9ID0gY29udGV4dDtcclxuICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGVuZCA9IGVuZCB8fCBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXJ0LFxyXG4gICAgICAgIGVuZCxcclxuICAgICAgICBzb3VyY2U6IGNvbnRleHQub3JpZ2luYWxTb3VyY2Uuc2xpY2Uoc3RhcnQub2Zmc2V0LCBlbmQub2Zmc2V0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBsYXN0KHhzKSB7XHJcbiAgICByZXR1cm4geHNbeHMubGVuZ3RoIC0gMV07XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRzV2l0aChzb3VyY2UsIHNlYXJjaFN0cmluZykge1xyXG4gICAgcmV0dXJuIHNvdXJjZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XHJcbn1cclxuZnVuY3Rpb24gYWR2YW5jZUJ5KGNvbnRleHQsIG51bWJlck9mQ2hhcmFjdGVycykge1xyXG4gICAgY29uc3QgeyBzb3VyY2UgfSA9IGNvbnRleHQ7XHJcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oY29udGV4dCwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG4gICAgY29udGV4dC5zb3VyY2UgPSBzb3VyY2Uuc2xpY2UobnVtYmVyT2ZDaGFyYWN0ZXJzKTtcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlU3BhY2VzKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gL15bXFx0XFxyXFxuXFxmIF0rLy5leGVjKGNvbnRleHQuc291cmNlKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcclxuICAgIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUoc3RhcnQsIGNvbnRleHQub3JpZ2luYWxTb3VyY2Uuc2xpY2Uoc3RhcnQub2Zmc2V0LCBudW1iZXJPZkNoYXJhY3RlcnMpLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGVtaXRFcnJvcihjb250ZXh0LCBjb2RlLCBvZmZzZXQsIGxvYyA9IGdldEN1cnNvcihjb250ZXh0KSkge1xyXG4gICAgaWYgKG9mZnNldCkge1xyXG4gICAgICAgIGxvYy5vZmZzZXQgKz0gb2Zmc2V0O1xyXG4gICAgICAgIGxvYy5jb2x1bW4gKz0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5vcHRpb25zLm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCB7XHJcbiAgICAgICAgc3RhcnQ6IGxvYyxcclxuICAgICAgICBlbmQ6IGxvYyxcclxuICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XHJcbiAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2U7XHJcbiAgICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogREFUQSAqLzpcclxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJzwvJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb2JhYmx5IGJhZCBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoRW5kVGFnT3BlbihzLCBhbmNlc3RvcnNbaV0udGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxIC8qIFJDREFUQSAqLzpcclxuICAgICAgICBjYXNlIDIgLyogUkFXVEVYVCAqLzoge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgcGFyZW50LnRhZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDMgLyogQ0RBVEEgKi86XHJcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICddXT4nKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIXM7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRzV2l0aEVuZFRhZ09wZW4oc291cmNlLCB0YWcpIHtcclxuICAgIHJldHVybiAoc3RhcnRzV2l0aChzb3VyY2UsICc8LycpICYmXHJcbiAgICAgICAgc291cmNlLnN1YnN0cigyLCB0YWcubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKSAmJlxyXG4gICAgICAgIC9bXFx0XFxyXFxuXFxmIC8+XS8udGVzdChzb3VyY2VbMiArIHRhZy5sZW5ndGhdIHx8ICc+JykpO1xyXG59XG5cbmZ1bmN0aW9uIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpIHtcclxuICAgIHdhbGsocm9vdCwgY29udGV4dCwgXHJcbiAgICAvLyBSb290IG5vZGUgaXMgdW5mb3J0dW5hdGVseSBub24taG9pc3RhYmxlIGR1ZSB0byBwb3RlbnRpYWwgcGFyZW50XHJcbiAgICAvLyBmYWxsdGhyb3VnaCBhdHRyaWJ1dGVzLlxyXG4gICAgaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCByb290LmNoaWxkcmVuWzBdKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkge1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcm9vdDtcclxuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgIWlzU2xvdE91dGxldChjaGlsZCkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhbGsobm9kZSwgY29udGV4dCwgZG9Ob3RIb2lzdE5vZGUgPSBmYWxzZSkge1xyXG4gICAgbGV0IGhhc0hvaXN0ZWROb2RlID0gZmFsc2U7XHJcbiAgICAvLyBTb21lIHRyYW5zZm9ybXMsIGUuZy4gdHJhbnNmb3JtQXNzZXRVcmxzIGZyb20gQHZ1ZS9jb21waWxlci1zZmMsIHJlcGxhY2VzXHJcbiAgICAvLyBzdGF0aWMgYmluZGluZ3Mgd2l0aCBleHByZXNzaW9ucy4gVGhlc2UgZXhwcmVzc2lvbnMgYXJlIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgIC8vIGNvbnN0YW50IHNvIHRoZXkgYXJlIHN0aWxsIGVsaWdpYmxlIGZvciBob2lzdGluZywgYnV0IHRoZXkgYXJlIG9ubHlcclxuICAgIC8vIGF2YWlsYWJsZSBhdCBydW50aW1lIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIGV2YWx1YXRlZCBhaGVhZCBvZiB0aW1lLlxyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGEgY29uY2VybiBmb3IgcHJlLXN0cmluZ2lmaWNhdGlvbiAodmlhIHRyYW5zZm9ybUhvaXN0IGJ5XHJcbiAgICAvLyBAdnVlL2NvbXBpbGVyLWRvbSksIGJ1dCBkb2luZyBpdCBoZXJlIGFsbG93cyB1cyB0byBwZXJmb3JtIG9ubHkgb25lIGZ1bGxcclxuICAgIC8vIHdhbGsgb2YgdGhlIEFTVCBhbmQgYWxsb3cgYHN0cmluZ2lmeVN0YXRpY2AgdG8gc3RvcCB3YWxraW5nIGFzIHNvb24gYXMgaXRzXHJcbiAgICAvLyBzdHJpbmdmaWNpYXRpb24gdGhyZXNob2xkIGlzIG1ldC5cclxuICAgIGxldCBjYW5TdHJpbmdpZnkgPSB0cnVlO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vIG9ubHkgcGxhaW4gZWxlbWVudHMgJiB0ZXh0IGNhbGxzIGFyZSBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICBjaGlsZC50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29uc3RhbnRUeXBlID0gZG9Ob3RIb2lzdE5vZGVcclxuICAgICAgICAgICAgICAgID8gMCAvKiBOT1RfQ09OU1RBTlQgKi9cclxuICAgICAgICAgICAgICAgIDogZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlIDwgMyAvKiBDQU5fU1RSSU5HSUZZICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuU3RyaW5naWZ5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID49IDIgLyogQ0FOX0hPSVNUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUucGF0Y2hGbGFnID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLTEgLyogSE9JU1RFRCAqLyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qIEhPSVNURUQgKi9gIDogYGApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlID0gY29udGV4dC5ob2lzdChjaGlsZC5jb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzSG9pc3RlZE5vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgY29udGFpbiBkeW5hbWljIGNoaWxkcmVuLCBidXQgaXRzIHByb3BzIG1heSBiZSBlbGlnaWJsZSBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGhvaXN0aW5nLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhZyA9IGdldFBhdGNoRmxhZyhjb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghZmxhZyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnID09PSA1MTIgLyogTkVFRF9QQVRDSCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnID09PSAxIC8qIFRFWFQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA+PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAvKiBDQU5fSE9JU1QgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZXROb2RlUHJvcHMoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLnByb3BzID0gY29udGV4dC5ob2lzdChwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gMTIgLyogVEVYVF9DQUxMICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPCAzIC8qIENBTl9TVFJJTkdJRlkgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5TdHJpbmdpZnkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA+PSAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlID0gY29udGV4dC5ob2lzdChjaGlsZC5jb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzSG9pc3RlZE5vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdhbGsgZnVydGhlclxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDExIC8qIEZPUiAqLykge1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1mb3Igc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcclxuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkLmJyYW5jaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1pZiBzaW5nbGUgY2hpbGQgYmVjYXVzZSBpdCBoYXMgdG8gYmUgYSBibG9ja1xyXG4gICAgICAgICAgICAgICAgd2FsayhjaGlsZC5icmFuY2hlc1tpXSwgY29udGV4dCwgY2hpbGQuYnJhbmNoZXNbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjYW5TdHJpbmdpZnkgJiYgaGFzSG9pc3RlZE5vZGUgJiYgY29udGV4dC50cmFuc2Zvcm1Ib2lzdCkge1xyXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSG9pc3QoY2hpbGRyZW4sIGNvbnRleHQsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbnN0YW50Q2FjaGUgfSA9IGNvbnRleHQ7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICBpZiAobm9kZS50YWdUeXBlICE9PSAwIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjb25zdGFudENhY2hlLmdldChub2RlKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgIT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgaWYgKCFmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmV0dXJuVHlwZSA9IDMgLyogQ0FOX1NUUklOR0lGWSAqLztcclxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgaXRzZWxmIGhhcyBubyBwYXRjaCBmbGFnLiBIb3dldmVyIHdlIHN0aWxsIG5lZWQgdG8gY2hlY2s6XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBFdmVuIGZvciBhIG5vZGUgd2l0aCBubyBwYXRjaCBmbGFnLCBpdCBpcyBwb3NzaWJsZSBmb3IgaXQgdG8gY29udGFpblxyXG4gICAgICAgICAgICAgICAgLy8gbm9uLWhvaXN0YWJsZSBleHByZXNzaW9ucyB0aGF0IHJlZmVycyB0byBzY29wZSB2YXJpYWJsZXMsIGUuZy4gY29tcGlsZXJcclxuICAgICAgICAgICAgICAgIC8vIGluamVjdGVkIGtleXMgb3IgY2FjaGVkIGV2ZW50IGhhbmRsZXJzLiBUaGVyZWZvcmUgd2UgbmVlZCB0byBhbHdheXNcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBjb2RlZ2VuTm9kZSdzIHByb3BzIHRvIGJlIHN1cmUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRQcm9wc1R5cGUgPSBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRQcm9wc1R5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRQcm9wc1R5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGdlbmVyYXRlZFByb3BzVHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDIuIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShub2RlLmNoaWxkcmVuW2ldLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIE5PVF9DT05TVEFOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGNoaWxkVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAzLiBpZiB0aGUgdHlwZSBpcyBub3QgYWxyZWFkeSBDQU5fU0tJUF9QQVRDSCB3aGljaCBpcyB0aGUgbG93ZXN0IG5vbi0wXHJcbiAgICAgICAgICAgICAgICAvLyB0eXBlLCBjaGVjayBpZiBhbnkgb2YgdGhlIHByb3BzIGNhbiBjYXVzZSB0aGUgdHlwZSB0byBiZSBsb3dlcmVkXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gc2tpcCBjYW5fcGF0Y2ggYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgYnkgdGhlIGFic2VuY2Ugb2YgYVxyXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2hGbGFnLlxyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblR5cGUgPiAxIC8qIENBTl9TS0lQX1BBVENIICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdiaW5kJyAmJiBwLmV4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwVHlwZSA9IGdldENvbnN0YW50VHlwZShwLmV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIE5PVF9DT05TVEFOVCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGV4cFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHN2Zy9mb3JlaWduT2JqZWN0IGNvdWxkIGJlIGJsb2NrIGhlcmUsIGhvd2V2ZXIgaWYgdGhleSBhcmVcclxuICAgICAgICAgICAgICAgIC8vIHN0YXRpYyB0aGVuIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBibG9ja3Mgc2luY2UgdGhlcmUgd2lsbCBiZSBub1xyXG4gICAgICAgICAgICAgICAgLy8gbmVzdGVkIHVwZGF0ZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmlzQmxvY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgcmV0dXJuVHlwZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zdFR5cGU7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkgfHwgaXNTeW1ib2woY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGNoaWxkVHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgcmV0dXJuVHlwZSA9IDMgLyogQ0FOX1NUUklOR0lGWSAqLztcclxuICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKG5vZGUpO1xyXG4gICAgaWYgKHByb3BzICYmIHByb3BzLnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBwcm9wcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBrZXlUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGtleSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChrZXlUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleVR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0ga2V5VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gdmFsdWVUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblR5cGU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKG5vZGUpIHtcclxuICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5Ob2RlLnByb3BzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFBhdGNoRmxhZyhub2RlKSB7XHJcbiAgICBjb25zdCBmbGFnID0gbm9kZS5wYXRjaEZsYWc7XHJcbiAgICByZXR1cm4gZmxhZyA/IHBhcnNlSW50KGZsYWcsIDEwKSA6IHVuZGVmaW5lZDtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIHsgZmlsZW5hbWUgPSAnJywgcHJlZml4SWRlbnRpZmllcnMgPSBmYWxzZSwgaG9pc3RTdGF0aWMgPSBmYWxzZSwgY2FjaGVIYW5kbGVycyA9IGZhbHNlLCBub2RlVHJhbnNmb3JtcyA9IFtdLCBkaXJlY3RpdmVUcmFuc2Zvcm1zID0ge30sIHRyYW5zZm9ybUhvaXN0ID0gbnVsbCwgaXNCdWlsdEluQ29tcG9uZW50ID0gTk9PUCwgaXNDdXN0b21FbGVtZW50ID0gTk9PUCwgZXhwcmVzc2lvblBsdWdpbnMgPSBbXSwgc2NvcGVJZCA9IG51bGwsIHNzciA9IGZhbHNlLCBzc3JDc3NWYXJzID0gYGAsIGJpbmRpbmdNZXRhZGF0YSA9IEVNUFRZX09CSiwgaW5saW5lID0gZmFsc2UsIGlzVFMgPSBmYWxzZSwgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yIH0pIHtcclxuICAgIGNvbnN0IG5hbWVNYXRjaCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcPy4qJC8sICcnKS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xyXG4gICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAvLyBvcHRpb25zXHJcbiAgICAgICAgc2VsZk5hbWU6IG5hbWVNYXRjaCAmJiBjYXBpdGFsaXplKGNhbWVsaXplJDEobmFtZU1hdGNoWzFdKSksXHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgaG9pc3RTdGF0aWMsXHJcbiAgICAgICAgY2FjaGVIYW5kbGVycyxcclxuICAgICAgICBub2RlVHJhbnNmb3JtcyxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIHRyYW5zZm9ybUhvaXN0LFxyXG4gICAgICAgIGlzQnVpbHRJbkNvbXBvbmVudCxcclxuICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICAgICAgZXhwcmVzc2lvblBsdWdpbnMsXHJcbiAgICAgICAgc2NvcGVJZCxcclxuICAgICAgICBzc3IsXHJcbiAgICAgICAgc3NyQ3NzVmFycyxcclxuICAgICAgICBiaW5kaW5nTWV0YWRhdGEsXHJcbiAgICAgICAgaW5saW5lLFxyXG4gICAgICAgIGlzVFMsXHJcbiAgICAgICAgb25FcnJvcixcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIHJvb3QsXHJcbiAgICAgICAgaGVscGVyczogbmV3IFNldCgpLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IG5ldyBTZXQoKSxcclxuICAgICAgICBkaXJlY3RpdmVzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgaG9pc3RzOiBbXSxcclxuICAgICAgICBpbXBvcnRzOiBbXSxcclxuICAgICAgICBjb25zdGFudENhY2hlOiBuZXcgTWFwKCksXHJcbiAgICAgICAgdGVtcHM6IDAsXHJcbiAgICAgICAgY2FjaGVkOiAwLFxyXG4gICAgICAgIGlkZW50aWZpZXJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIHNjb3Blczoge1xyXG4gICAgICAgICAgICB2Rm9yOiAwLFxyXG4gICAgICAgICAgICB2U2xvdDogMCxcclxuICAgICAgICAgICAgdlByZTogMCxcclxuICAgICAgICAgICAgdk9uY2U6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICBjdXJyZW50Tm9kZTogcm9vdCxcclxuICAgICAgICBjaGlsZEluZGV4OiAwLFxyXG4gICAgICAgIC8vIG1ldGhvZHNcclxuICAgICAgICBoZWxwZXIobmFtZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuYWRkKG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhlbHBlclN0cmluZyhuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtjb250ZXh0LmhlbHBlcihuYW1lKV19YDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcGxhY2VOb2RlKG5vZGUpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBiZWluZyByZXBsYWNlZCBpcyBhbHJlYWR5IHJlbW92ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW5bY29udGV4dC5jaGlsZEluZGV4XSA9IGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbnRleHQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgcm9vdCBub2RlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZhbEluZGV4ID0gbm9kZVxyXG4gICAgICAgICAgICAgICAgPyBsaXN0LmluZGV4T2Yobm9kZSlcclxuICAgICAgICAgICAgICAgIDogY29udGV4dC5jdXJyZW50Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gY29udGV4dC5jaGlsZEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcmVtb3ZhbEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub2RlIGJlaW5nIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgY3VycmVudCBwYXJlbnRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBub2RlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaWJsaW5nIG5vZGUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hpbGRJbmRleCA+IHJlbW92YWxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hpbGRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuLnNwbGljZShyZW1vdmFsSW5kZXgsIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Ob2RlUmVtb3ZlZDogKCkgPT4geyB9LFxyXG4gICAgICAgIGFkZElkZW50aWZpZXJzKGV4cCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlSWRlbnRpZmllcnMoZXhwKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBob2lzdChleHApIHtcclxuICAgICAgICAgICAgY29udGV4dC5ob2lzdHMucHVzaChleHApO1xyXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2hvaXN0ZWRfJHtjb250ZXh0LmhvaXN0cy5sZW5ndGh9YCwgZmFsc2UsIGV4cC5sb2MsIDIgLyogQ0FOX0hPSVNUICovKTtcclxuICAgICAgICAgICAgaWRlbnRpZmllci5ob2lzdGVkID0gZXhwO1xyXG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhY2hlKGV4cCwgaXNWTm9kZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDYWNoZUV4cHJlc3Npb24oKytjb250ZXh0LmNhY2hlZCwgZXhwLCBpc1ZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNmb3JtKHJvb3QsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIG9wdGlvbnMpO1xyXG4gICAgdHJhdmVyc2VOb2RlKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgaWYgKG9wdGlvbnMuaG9pc3RTdGF0aWMpIHtcclxuICAgICAgICBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmICghb3B0aW9ucy5zc3IpIHtcclxuICAgICAgICBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIC8vIGZpbmFsaXplIG1ldGEgaW5mb3JtYXRpb25cclxuICAgIHJvb3QuaGVscGVycyA9IFsuLi5jb250ZXh0LmhlbHBlcnNdO1xyXG4gICAgcm9vdC5jb21wb25lbnRzID0gWy4uLmNvbnRleHQuY29tcG9uZW50c107XHJcbiAgICByb290LmRpcmVjdGl2ZXMgPSBbLi4uY29udGV4dC5kaXJlY3RpdmVzXTtcclxuICAgIHJvb3QuaW1wb3J0cyA9IGNvbnRleHQuaW1wb3J0cztcclxuICAgIHJvb3QuaG9pc3RzID0gY29udGV4dC5ob2lzdHM7XHJcbiAgICByb290LnRlbXBzID0gY29udGV4dC50ZW1wcztcclxuICAgIHJvb3QuY2FjaGVkID0gY29udGV4dC5jYWNoZWQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xyXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgLy8gaWYgdGhlIHNpbmdsZSBjaGlsZCBpcyBhbiBlbGVtZW50LCB0dXJuIGl0IGludG8gYSBibG9jay5cclxuICAgICAgICBpZiAoaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkgJiYgY2hpbGQuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIGVsZW1lbnQgcm9vdCBpcyBuZXZlciBob2lzdGVkIHNvIGNvZGVnZW5Ob2RlIHdpbGwgbmV2ZXIgYmVcclxuICAgICAgICAgICAgLy8gU2ltcGxlRXhwcmVzc2lvbk5vZGVcclxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmlzQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgaGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNvZGVnZW5Ob2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgPHNsb3QvPiwgSWZOb2RlLCBGb3JOb2RlOiBhbHJlYWR5IGJsb2Nrcy5cclxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgdGV4dCBub2RlOiBhbHdheXMgcGF0Y2hlZC5cclxuICAgICAgICAgICAgLy8gcm9vdCBjb2RlZ2VuIGZhbGxzIHRocm91Z2ggdmlhIGdlbk5vZGUoKVxyXG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIC8vIHJvb3QgaGFzIG11bHRpcGxlIG5vZGVzIC0gcmV0dXJuIGEgZnJhZ21lbnQgYmxvY2suXHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLztcclxuICAgICAgICBsZXQgcGF0Y2hGbGFnVGV4dCA9IFBhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL107XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyYWdtZW50IGFjdHVhbGx5IGNvbnRhaW5zIGEgc2luZ2xlIHZhbGlkIGNoaWxkIHdpdGhcclxuICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke1BhdGNoRmxhZ05hbWVzWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByb290LmNoaWxkcmVuLCBwYXRjaEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3BhdGNoRmxhZ1RleHR9ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSA7XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VDaGlsZHJlbihwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IG5vZGVSZW1vdmVkID0gKCkgPT4ge1xyXG4gICAgICAgIGktLTtcclxuICAgIH07XHJcbiAgICBmb3IgKDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIGNvbnRleHQuY2hpbGRJbmRleCA9IGk7XHJcbiAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkID0gbm9kZVJlbW92ZWQ7XHJcbiAgICAgICAgdHJhdmVyc2VOb2RlKGNoaWxkLCBjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICAvLyBhcHBseSB0cmFuc2Zvcm0gcGx1Z2luc1xyXG4gICAgY29uc3QgeyBub2RlVHJhbnNmb3JtcyB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBvbkV4aXQgPSBub2RlVHJhbnNmb3Jtc1tpXShub2RlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAob25FeGl0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9uRXhpdCkpIHtcclxuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaCguLi5vbkV4aXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIHJlbW92ZWRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkXHJcbiAgICAgICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAzIC8qIENPTU1FTlQgKi86XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluamVjdCBpbXBvcnQgZm9yIHRoZSBDb21tZW50IHN5bWJvbCwgd2hpY2ggaXMgbmVlZGVkIGZvciBjcmVhdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gY29tbWVudCBub2RlcyB3aXRoIGBjcmVhdGVWTm9kZWBcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB0cmF2ZXJzZSwgYnV0IHdlIG5lZWQgdG8gaW5qZWN0IHRvU3RyaW5nIGhlbHBlclxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihUT19ESVNQTEFZX1NUUklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gZm9yIGNvbnRhaW5lciB0eXBlcywgZnVydGhlciB0cmF2ZXJzZSBkb3dud2FyZHNcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuYnJhbmNoZXNbaV0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgIGNhc2UgMCAvKiBST09UICovOlxyXG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8vIGV4aXQgdHJhbnNmb3Jtc1xyXG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICBsZXQgaSA9IGV4aXRGbnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGV4aXRGbnNbaV0oKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKG5hbWUsIGZuKSB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gaXNTdHJpbmcobmFtZSlcclxuICAgICAgICA/IChuKSA9PiBuID09PSBuYW1lXHJcbiAgICAgICAgOiAobikgPT4gbmFtZS50ZXN0KG4pO1xyXG4gICAgcmV0dXJuIChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRyYW5zZm9ybXMgYXJlIG5vdCBjb25jZXJuZWQgd2l0aCBzbG90c1xyXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgaW4gdlNsb3QudHNcclxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyAmJiBwcm9wcy5zb21lKGlzVlNsb3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZXhpdEZucyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBtYXRjaGVzKHByb3AubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgYXJlIHJlbW92ZWQgdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3ZSByZW1vdmUgdGhlbSAqYmVmb3JlKiBhcHBseWluZyBzbyB0aGF0IGl0IGNhbiBmdXJ0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhdmVyc2UgaXRzZWxmIGluIGNhc2UgaXQgbW92ZXMgdGhlIG5vZGUgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBmbihub2RlLCBwcm9wLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXhpdEZucztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IFBVUkVfQU5OT1RBVElPTiA9IGAvKiNfX1BVUkVfXyovYDtcclxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7IG1vZGUgPSAnZnVuY3Rpb24nLCBwcmVmaXhJZGVudGlmaWVycyA9IG1vZGUgPT09ICdtb2R1bGUnLCBzb3VyY2VNYXAgPSBmYWxzZSwgZmlsZW5hbWUgPSBgdGVtcGxhdGUudnVlLmh0bWxgLCBzY29wZUlkID0gbnVsbCwgb3B0aW1pemVJbXBvcnRzID0gZmFsc2UsIHJ1bnRpbWVHbG9iYWxOYW1lID0gYFZ1ZWAsIHJ1bnRpbWVNb2R1bGVOYW1lID0gYHZ1ZWAsIHNzciA9IGZhbHNlIH0pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcclxuICAgICAgICBzb3VyY2VNYXAsXHJcbiAgICAgICAgZmlsZW5hbWUsXHJcbiAgICAgICAgc2NvcGVJZCxcclxuICAgICAgICBvcHRpbWl6ZUltcG9ydHMsXHJcbiAgICAgICAgcnVudGltZUdsb2JhbE5hbWUsXHJcbiAgICAgICAgcnVudGltZU1vZHVsZU5hbWUsXHJcbiAgICAgICAgc3NyLFxyXG4gICAgICAgIHNvdXJjZTogYXN0LmxvYy5zb3VyY2UsXHJcbiAgICAgICAgY29kZTogYGAsXHJcbiAgICAgICAgY29sdW1uOiAxLFxyXG4gICAgICAgIGxpbmU6IDEsXHJcbiAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgIGluZGVudExldmVsOiAwLFxyXG4gICAgICAgIHB1cmU6IGZhbHNlLFxyXG4gICAgICAgIG1hcDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlbHBlcihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBfJHtoZWxwZXJOYW1lTWFwW2tleV19YDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2goY29kZSwgbm9kZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gY29kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluZGVudCgpIHtcclxuICAgICAgICAgICAgbmV3bGluZSgrK2NvbnRleHQuaW5kZW50TGV2ZWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVpbmRlbnQod2l0aG91dE5ld0xpbmUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dE5ld0xpbmUpIHtcclxuICAgICAgICAgICAgICAgIC0tY29udGV4dC5pbmRlbnRMZXZlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld2xpbmUoLS1jb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV3bGluZSgpIHtcclxuICAgICAgICAgICAgbmV3bGluZShjb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gbmV3bGluZShuKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKCdcXG4nICsgYCAgYC5yZXBlYXQobikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGUoYXN0LCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIG9wdGlvbnMpO1xyXG4gICAgaWYgKG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZClcclxuICAgICAgICBvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQoY29udGV4dCk7XHJcbiAgICBjb25zdCB7IG1vZGUsIHB1c2gsIHByZWZpeElkZW50aWZpZXJzLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lLCBzY29wZUlkLCBzc3IgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBoYXNIZWxwZXJzID0gYXN0LmhlbHBlcnMubGVuZ3RoID4gMDtcclxuICAgIGNvbnN0IHVzZVdpdGhCbG9jayA9ICFwcmVmaXhJZGVudGlmaWVycyAmJiBtb2RlICE9PSAnbW9kdWxlJztcclxuICAgIC8vIHByZWFtYmxlc1xyXG4gICAgLy8gaW4gc2V0dXAoKSBpbmxpbmUgbW9kZSwgdGhlIHByZWFtYmxlIGlzIGdlbmVyYXRlZCBpbiBhIHN1YiBjb250ZXh0XHJcbiAgICAvLyBhbmQgcmV0dXJuZWQgc2VwYXJhdGVseS5cclxuICAgIGNvbnN0IHByZWFtYmxlQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB7XHJcbiAgICAgICAgZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIHByZWFtYmxlQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBlbnRlciByZW5kZXIgZnVuY3Rpb25cclxuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHNzciA/IGBzc3JSZW5kZXJgIDogYHJlbmRlcmA7XHJcbiAgICBjb25zdCBhcmdzID0gc3NyID8gWydfY3R4JywgJ19wdXNoJywgJ19wYXJlbnQnLCAnX2F0dHJzJ10gOiBbJ19jdHgnLCAnX2NhY2hlJ107XHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhcmdzLmpvaW4oJywgJyk7XHJcbiAgICB7XHJcbiAgICAgICAgcHVzaChgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCR7c2lnbmF0dXJlfSkge2ApO1xyXG4gICAgfVxyXG4gICAgaW5kZW50KCk7XHJcbiAgICBpZiAodXNlV2l0aEJsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgd2l0aCAoX2N0eCkge2ApO1xyXG4gICAgICAgIGluZGVudCgpO1xyXG4gICAgICAgIC8vIGZ1bmN0aW9uIG1vZGUgY29uc3QgZGVjbGFyYXRpb25zIHNob3VsZCBiZSBpbnNpZGUgd2l0aCBibG9ja1xyXG4gICAgICAgIC8vIGFsc28gdGhleSBzaG91bGQgYmUgcmVuYW1lZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCB1c2VyIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAoaGFzSGVscGVycykge1xyXG4gICAgICAgICAgICBwdXNoKGBjb25zdCB7ICR7YXN0LmhlbHBlcnNcclxuICAgICAgICAgICAgICAgIC5tYXAocyA9PiBgJHtoZWxwZXJOYW1lTWFwW3NdfTogXyR7aGVscGVyTmFtZU1hcFtzXX1gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IH0gPSBfVnVlYCk7XHJcbiAgICAgICAgICAgIHB1c2goYFxcbmApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZ2VuZXJhdGUgYXNzZXQgcmVzb2x1dGlvbiBzdGF0ZW1lbnRzXHJcbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5jb21wb25lbnRzLCAnY29tcG9uZW50JywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmRpcmVjdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5kaXJlY3RpdmVzLCAnZGlyZWN0aXZlJywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGFzdC50ZW1wcyA+IDApIHtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgcHVzaChgbGV0IGApO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LnRlbXBzOyBpKyspIHtcclxuICAgICAgICAgICAgcHVzaChgJHtpID4gMCA/IGAsIGAgOiBgYH1fdGVtcCR7aX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoIHx8IGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMpIHtcclxuICAgICAgICBwdXNoKGBcXG5gKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICB9XHJcbiAgICAvLyBnZW5lcmF0ZSB0aGUgVk5vZGUgdHJlZSBleHByZXNzaW9uXHJcbiAgICBpZiAoIXNzcikge1xyXG4gICAgICAgIHB1c2goYHJldHVybiBgKTtcclxuICAgIH1cclxuICAgIGlmIChhc3QuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICBnZW5Ob2RlKGFzdC5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdXNoKGBudWxsYCk7XHJcbiAgICB9XHJcbiAgICBpZiAodXNlV2l0aEJsb2NrKSB7XHJcbiAgICAgICAgZGVpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGB9YCk7XHJcbiAgICB9XHJcbiAgICBkZWluZGVudCgpO1xyXG4gICAgcHVzaChgfWApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhc3QsXHJcbiAgICAgICAgY29kZTogY29udGV4dC5jb2RlLFxyXG4gICAgICAgIHByZWFtYmxlOiBgYCxcclxuICAgICAgICAvLyBTb3VyY2VNYXBHZW5lcmF0b3IgZG9lcyBoYXZlIHRvSlNPTigpIG1ldGhvZCBidXQgaXQncyBub3QgaW4gdGhlIHR5cGVzXHJcbiAgICAgICAgbWFwOiBjb250ZXh0Lm1hcCA/IGNvbnRleHQubWFwLnRvSlNPTigpIDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHNzciwgcHJlZml4SWRlbnRpZmllcnMsIHB1c2gsIG5ld2xpbmUsIHJ1bnRpbWVNb2R1bGVOYW1lLCBydW50aW1lR2xvYmFsTmFtZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IFZ1ZUJpbmRpbmcgPSBydW50aW1lR2xvYmFsTmFtZTtcclxuICAgIGNvbnN0IGFsaWFzSGVscGVyID0gKHMpID0+IGAke2hlbHBlck5hbWVNYXBbc119OiBfJHtoZWxwZXJOYW1lTWFwW3NdfWA7XHJcbiAgICAvLyBHZW5lcmF0ZSBjb25zdCBkZWNsYXJhdGlvbiBmb3IgaGVscGVyc1xyXG4gICAgLy8gSW4gcHJlZml4IG1vZGUsIHdlIHBsYWNlIHRoZSBjb25zdCBkZWNsYXJhdGlvbiBhdCB0b3Agc28gaXQncyBkb25lXHJcbiAgICAvLyBvbmx5IG9uY2U7IEJ1dCBpZiB3ZSBub3QgcHJlZml4aW5nLCB3ZSBwbGFjZSB0aGUgZGVjbGFyYXRpb24gaW5zaWRlIHRoZVxyXG4gICAgLy8gd2l0aCBibG9jayBzbyBpdCBkb2Vzbid0IGluY3VyIHRoZSBgaW5gIGNoZWNrIGNvc3QgZm9yIGV2ZXJ5IGhlbHBlciBhY2Nlc3MuXHJcbiAgICBpZiAoYXN0LmhlbHBlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gXCJ3aXRoXCIgbW9kZS5cclxuICAgICAgICAgICAgLy8gc2F2ZSBWdWUgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSB0byBhdm9pZCBjb2xsaXNpb25cclxuICAgICAgICAgICAgcHVzaChgY29uc3QgX1Z1ZSA9ICR7VnVlQmluZGluZ31cXG5gKTtcclxuICAgICAgICAgICAgLy8gaW4gXCJ3aXRoXCIgbW9kZSwgaGVscGVycyBhcmUgZGVjbGFyZWQgaW5zaWRlIHRoZSB3aXRoIGJsb2NrIHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIGhhcyBjaGVjayBjb3N0LCBidXQgaG9pc3RzIGFyZSBsaWZ0ZWQgb3V0IG9mIHRoZSBmdW5jdGlvbiAtIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gcHJvdmlkZSB0aGUgaGVscGVyIGhlcmUuXHJcbiAgICAgICAgICAgIGlmIChhc3QuaG9pc3RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljSGVscGVycyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVk5PREUsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX0NPTU1FTlQsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1RFWFQsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1NUQVRJQ1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaGVscGVyID0+IGFzdC5oZWxwZXJzLmluY2x1ZGVzKGhlbHBlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhbGlhc0hlbHBlcilcclxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHtzdGF0aWNIZWxwZXJzfSB9ID0gX1Z1ZVxcbmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2VuSG9pc3RzKGFzdC5ob2lzdHMsIGNvbnRleHQpO1xyXG4gICAgbmV3bGluZSgpO1xyXG4gICAgcHVzaChgcmV0dXJuIGApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkFzc2V0cyhhc3NldHMsIHR5cGUsIHsgaGVscGVyLCBwdXNoLCBuZXdsaW5lIH0pIHtcclxuICAgIGNvbnN0IHJlc29sdmVyID0gaGVscGVyKHR5cGUgPT09ICdjb21wb25lbnQnID8gUkVTT0xWRV9DT01QT05FTlQgOiBSRVNPTFZFX0RJUkVDVElWRSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGlkID0gYXNzZXRzW2ldO1xyXG4gICAgICAgIHB1c2goYGNvbnN0ICR7dG9WYWxpZEFzc2V0SWQoaWQsIHR5cGUpfSA9ICR7cmVzb2x2ZXJ9KCR7SlNPTi5zdHJpbmdpZnkoaWQpfSlgKTtcclxuICAgICAgICBpZiAoaSA8IGFzc2V0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuSG9pc3RzKGhvaXN0cywgY29udGV4dCkge1xyXG4gICAgaWYgKCFob2lzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5wdXJlID0gdHJ1ZTtcclxuICAgIGNvbnN0IHsgcHVzaCwgbmV3bGluZSwgaGVscGVyLCBzY29wZUlkLCBtb2RlIH0gPSBjb250ZXh0O1xyXG4gICAgbmV3bGluZSgpO1xyXG4gICAgaG9pc3RzLmZvckVhY2goKGV4cCwgaSkgPT4ge1xyXG4gICAgICAgIGlmIChleHApIHtcclxuICAgICAgICAgICAgcHVzaChgY29uc3QgX2hvaXN0ZWRfJHtpICsgMX0gPSBgKTtcclxuICAgICAgICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb250ZXh0LnB1cmUgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1RleHQkMShuKSB7XHJcbiAgICByZXR1cm4gKGlzU3RyaW5nKG4pIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSAyIC8qIFRFWFQgKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZXMsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG11bHRpbGluZXMgPSBub2Rlcy5sZW5ndGggPiAzIHx8XHJcbiAgICAgICAgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpICYmIG5vZGVzLnNvbWUobiA9PiBpc0FycmF5KG4pIHx8ICFpc1RleHQkMShuKSkpO1xyXG4gICAgY29udGV4dC5wdXNoKGBbYCk7XHJcbiAgICBtdWx0aWxpbmVzICYmIGNvbnRleHQuaW5kZW50KCk7XHJcbiAgICBnZW5Ob2RlTGlzdChub2RlcywgY29udGV4dCwgbXVsdGlsaW5lcyk7XHJcbiAgICBtdWx0aWxpbmVzICYmIGNvbnRleHQuZGVpbmRlbnQoKTtcclxuICAgIGNvbnRleHQucHVzaChgXWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzID0gZmFsc2UsIGNvbW1hID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcclxuICAgICAgICAgICAgcHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xyXG4gICAgICAgICAgICBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgaWYgKG11bHRpbGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbW1hICYmIHB1c2goJywnKTtcclxuICAgICAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbW1hICYmIHB1c2goJywgJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcclxuICAgICAgICBjb250ZXh0LnB1c2gobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU3ltYm9sKG5vZGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKGNvbnRleHQuaGVscGVyKG5vZGUpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBhc3NlcnQobm9kZS5jb2RlZ2VuTm9kZSAhPSBudWxsLCBgQ29kZWdlbiBub2RlIGlzIG1pc3NpbmcgZm9yIGVsZW1lbnQvaWYvZm9yIG5vZGUuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBBcHBseSBhcHByb3ByaWF0ZSB0cmFuc2Zvcm1zIGZpcnN0LmApO1xyXG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIgLyogVEVYVCAqLzpcclxuICAgICAgICAgICAgZ2VuVGV4dChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICAgICAgZ2VuSW50ZXJwb2xhdGlvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZS5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEzIC8qIFZOT0RFX0NBTEwgKi86XHJcbiAgICAgICAgICAgIGdlblZOb2RlQ2FsbChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNhbGxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE3IC8qIEpTX0FSUkFZX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOCAvKiBKU19GVU5DVElPTl9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5GdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNhY2hlRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gU1NSIG9ubHkgdHlwZXNcclxuICAgICAgICBjYXNlIDIxIC8qIEpTX0JMT0NLX1NUQVRFTUVOVCAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyMiAvKiBKU19URU1QTEFURV9MSVRFUkFMICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIzIC8qIEpTX0lGX1NUQVRFTUVOVCAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNCAvKiBKU19BU1NJR05NRU5UX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjUgLyogSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNiAvKiBKU19SRVRVUk5fU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICAvLyBub29wXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYHVuaGFuZGxlZCBjb2RlZ2VuIG5vZGUgdHlwZTogJHtub2RlLnR5cGV9YCk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZXhoYXVzdCBhbGwgcG9zc2libGUgdHlwZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhoYXVzdGl2ZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuVGV4dChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KSwgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnQsIGlzU3RhdGljIH0gPSBub2RlO1xyXG4gICAgY29udGV4dC5wdXNoKGlzU3RhdGljID8gSlNPTi5zdHJpbmdpZnkoY29udGVudCkgOiBjb250ZW50LCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHB1cmUpXHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgcHVzaChgJHtoZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpfShgKTtcclxuICAgIGdlbk5vZGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2ggfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBwdXNoKGBbYCk7XHJcbiAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYF1gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGUuaXNTdGF0aWMpIHtcclxuICAgICAgICAvLyBvbmx5IHF1b3RlIGtleXMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgY29uc3QgdGV4dCA9IGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpXHJcbiAgICAgICAgICAgID8gbm9kZS5jb250ZW50XHJcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KTtcclxuICAgICAgICBwdXNoKHRleHQsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgWyR7bm9kZS5jb250ZW50fV1gLCBub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcclxuICAgICAgICBpZiAocHVyZSkge1xyXG4gICAgICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1c2goYCR7aGVscGVyKENSRUFURV9DT01NRU5UKX0oJHtKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpfSlgLCBub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCB7IHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jaywgZGlzYWJsZVRyYWNraW5nIH0gPSBub2RlO1xyXG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBwdXNoKGhlbHBlcihXSVRIX0RJUkVDVElWRVMpICsgYChgKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgKCR7aGVscGVyKE9QRU5fQkxPQ0spfSgke2Rpc2FibGVUcmFja2luZyA/IGB0cnVlYCA6IGBgfSksIGApO1xyXG4gICAgfVxyXG4gICAgaWYgKHB1cmUpIHtcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICB9XHJcbiAgICBwdXNoKGhlbHBlcihpc0Jsb2NrID8gQ1JFQVRFX0JMT0NLIDogQ1JFQVRFX1ZOT0RFKSArIGAoYCwgbm9kZSk7XHJcbiAgICBnZW5Ob2RlTGlzdChnZW5OdWxsYWJsZUFyZ3MoW3RhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wc10pLCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxuICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBwdXNoKGAsIGApO1xyXG4gICAgICAgIGdlbk5vZGUoZGlyZWN0aXZlcywgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbk51bGxhYmxlQXJncyhhcmdzKSB7XHJcbiAgICBsZXQgaSA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChhcmdzW2ldICE9IG51bGwpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcChhcmcgPT4gYXJnIHx8IGBudWxsYCk7XHJcbn1cclxuLy8gSmF2YVNjcmlwdFxyXG5mdW5jdGlvbiBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGNhbGxlZSA9IGlzU3RyaW5nKG5vZGUuY2FsbGVlKSA/IG5vZGUuY2FsbGVlIDogaGVscGVyKG5vZGUuY2FsbGVlKTtcclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgcHVzaChjYWxsZWUgKyBgKGAsIG5vZGUpO1xyXG4gICAgZ2VuTm9kZUxpc3Qobm9kZS5hcmd1bWVudHMsIGNvbnRleHQpO1xyXG4gICAgcHVzaChgKWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlO1xyXG4gICAgaWYgKCFwcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHB1c2goYHt9YCwgbm9kZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IHByb3BlcnRpZXMubGVuZ3RoID4gMSB8fFxyXG4gICAgICAgICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSAmJlxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNvbWUocCA9PiBwLnZhbHVlLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pKTtcclxuICAgIHB1c2gobXVsdGlsaW5lcyA/IGB7YCA6IGB7IGApO1xyXG4gICAgbXVsdGlsaW5lcyAmJiBpbmRlbnQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICAvLyBrZXlcclxuICAgICAgICBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShrZXksIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYDogYCk7XHJcbiAgICAgICAgLy8gdmFsdWVcclxuICAgICAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIG9ubHkgcmVhY2ggdGhpcyBpZiBpdCdzIG11bHRpbGluZXNcclxuICAgICAgICAgICAgcHVzaChgLGApO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbXVsdGlsaW5lcyAmJiBkZWluZGVudCgpO1xyXG4gICAgcHVzaChtdWx0aWxpbmVzID8gYH1gIDogYCB9YCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLmVsZW1lbnRzLCBjb250ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBnZW5GdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBzY29wZUlkLCBtb2RlIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBwYXJhbXMsIHJldHVybnMsIGJvZHksIG5ld2xpbmUsIGlzU2xvdCB9ID0gbm9kZTtcclxuICAgIGlmIChpc1Nsb3QpIHtcclxuICAgICAgICBwdXNoKGBfJHtoZWxwZXJOYW1lTWFwW1dJVEhfQ1RYXX0oYCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGAoYCwgbm9kZSk7XHJcbiAgICBpZiAoaXNBcnJheShwYXJhbXMpKSB7XHJcbiAgICAgICAgZ2VuTm9kZUxpc3QocGFyYW1zLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmFtcykge1xyXG4gICAgICAgIGdlbk5vZGUocGFyYW1zLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHB1c2goYCkgPT4gYCk7XHJcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XHJcbiAgICAgICAgcHVzaChge2ApO1xyXG4gICAgICAgIGluZGVudCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJldHVybnMpIHtcclxuICAgICAgICBpZiAobmV3bGluZSkge1xyXG4gICAgICAgICAgICBwdXNoKGByZXR1cm4gYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHJldHVybnMpKSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShyZXR1cm5zLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUocmV0dXJucywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYm9keSkge1xyXG4gICAgICAgIGdlbk5vZGUoYm9keSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XHJcbiAgICAgICAgZGVpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGB9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZTogbmVlZE5ld2xpbmUgfSA9IG5vZGU7XHJcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAodGVzdC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgY29uc3QgbmVlZHNQYXJlbnMgPSAhaXNTaW1wbGVJZGVudGlmaWVyKHRlc3QuY29udGVudCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbkV4cHJlc3Npb24odGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgKGApO1xyXG4gICAgICAgIGdlbk5vZGUodGVzdCwgY29udGV4dCk7XHJcbiAgICAgICAgcHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgbmVlZE5ld2xpbmUgJiYgaW5kZW50KCk7XHJcbiAgICBjb250ZXh0LmluZGVudExldmVsKys7XHJcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgICBwdXNoKGA/IGApO1xyXG4gICAgZ2VuTm9kZShjb25zZXF1ZW50LCBjb250ZXh0KTtcclxuICAgIGNvbnRleHQuaW5kZW50TGV2ZWwtLTtcclxuICAgIG5lZWROZXdsaW5lICYmIG5ld2xpbmUoKTtcclxuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcclxuICAgIHB1c2goYDogYCk7XHJcbiAgICBjb25zdCBpc05lc3RlZCA9IGFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovO1xyXG4gICAgaWYgKCFpc05lc3RlZCkge1xyXG4gICAgICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcclxuICAgIH1cclxuICAgIGdlbk5vZGUoYWx0ZXJuYXRlLCBjb250ZXh0KTtcclxuICAgIGlmICghaXNOZXN0ZWQpIHtcclxuICAgICAgICBjb250ZXh0LmluZGVudExldmVsLS07XHJcbiAgICB9XHJcbiAgICBuZWVkTmV3bGluZSAmJiBkZWluZGVudCh0cnVlIC8qIHdpdGhvdXQgbmV3bGluZSAqLyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dIHx8IChgKTtcclxuICAgIGlmIChub2RlLmlzVk5vZGUpIHtcclxuICAgICAgICBpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgtMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dID0gYCk7XHJcbiAgICBnZW5Ob2RlKG5vZGUudmFsdWUsIGNvbnRleHQpO1xyXG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xyXG4gICAgICAgIHB1c2goYCxgKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oMSksYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XWApO1xyXG4gICAgICAgIGRlaW5kZW50KCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGApYCk7XHJcbn1cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcclxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxyXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcclxuICAgICgnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcclxuICAgICAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xyXG4gICAgICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzLHR5cGVvZix2b2lkJylcclxuICAgICAgICAuc3BsaXQoJywnKVxyXG4gICAgICAgIC5qb2luKCdcXFxcYnxcXFxcYicpICtcclxuICAgICdcXFxcYicpO1xyXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXHJcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcclxuLyoqXHJcbiAqIFZhbGlkYXRlIGEgbm9uLXByZWZpeGVkIGV4cHJlc3Npb24uXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB1c2luZyB0aGUgaW4tYnJvd3NlciBydW50aW1lIGNvbXBpbGVyIHNpbmNlIGl0XHJcbiAqIGRvZXNuJ3QgcHJlZml4IGV4cHJlc3Npb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcyA9IGZhbHNlLCBhc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gICAgLy8gZW1wdHkgZXhwcmVzc2lvbnMgYXJlIHZhbGlkYXRlZCBwZXItZGlyZWN0aXZlIHNpbmNlIHNvbWUgZGlyZWN0aXZlc1xyXG4gICAgLy8gZG8gYWxsb3cgZW1wdHkgZXhwcmVzc2lvbnMuXHJcbiAgICBpZiAoIWV4cC50cmltKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBGdW5jdGlvbihhc1Jhd1N0YXRlbWVudHNcclxuICAgICAgICAgICAgPyBgICR7ZXhwfSBgXHJcbiAgICAgICAgICAgIDogYHJldHVybiAke2FzUGFyYW1zID8gYCgke2V4cH0pID0+IHt9YCA6IGAoJHtleHB9KWB9YCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxldCBtZXNzYWdlID0gZS5tZXNzYWdlO1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cFxyXG4gICAgICAgICAgICAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJylcclxuICAgICAgICAgICAgLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIke2tleXdvcmRNYXRjaFswXX1cImA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQzIC8qIFhfSU5WQUxJRF9FWFBSRVNTSU9OICovLCBub2RlLmxvYywgdW5kZWZpbmVkLCBtZXNzYWdlKSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtRXhwcmVzc2lvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICBub2RlLmNvbnRlbnQgPSBwcm9jZXNzRXhwcmVzc2lvbihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAvLyBoYW5kbGUgZGlyZWN0aXZlcyBvbiBlbGVtZW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGZvciB2LW9uICYgdi1mb3Igc2luY2UgdGhleSBhcmUgc3BlY2lhbCBoYW5kbGVkXHJcbiAgICAgICAgICAgIGlmIChkaXIudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgZGlyLm5hbWUgIT09ICdmb3InKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHAgPSBkaXIuZXhwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gZGlyLmFyZztcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGV4cCBpZiB0aGlzIGlzIHYtb246YXJnIC0gd2UgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Igd3JhcHBpbmcgaW5saW5lIHN0YXRlbWVudHMuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAhKGRpci5uYW1lID09PSAnb24nICYmIGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwID0gcHJvY2Vzc0V4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbG90IGFyZ3MgbXVzdCBiZSBwcm9jZXNzZWQgYXMgZnVuY3Rpb24gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLm5hbWUgPT09ICdzbG90Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmICFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXIuYXJnID0gcHJvY2Vzc0V4cHJlc3Npb24oYXJnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLy8gSW1wb3J0YW50OiBzaW5jZSB0aGlzIGZ1bmN0aW9uIHVzZXMgTm9kZS5qcyBvbmx5IGRlcGVuZGVuY2llcywgaXQgc2hvdWxkXHJcbi8vIGFsd2F5cyBiZSB1c2VkIHdpdGggYSBsZWFkaW5nICF0cnVlIGNoZWNrIHNvIHRoYXQgaXQgY2FuIGJlXHJcbi8vIHRyZWUtc2hha2VuIGZyb20gdGhlIGJyb3dzZXIgYnVpbGQuXHJcbmZ1bmN0aW9uIHByb2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIFxyXG4vLyBzb21lIGV4cHJlc3Npb25zIGxpa2Ugdi1zbG90IHByb3BzICYgdi1mb3IgYWxpYXNlcyBzaG91bGQgYmUgcGFyc2VkIGFzXHJcbi8vIGZ1bmN0aW9uIHBhcmFtc1xyXG5hc1BhcmFtcyA9IGZhbHNlLCBcclxuLy8gdi1vbiBoYW5kbGVyIHZhbHVlcyBtYXkgY29udGFpbiBtdWx0aXBsZSBzdGF0ZW1lbnRzXHJcbmFzUmF3U3RhdGVtZW50cyA9IGZhbHNlKSB7XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAvLyBzaW1wbGUgaW4tYnJvd3NlciB2YWxpZGF0aW9uIChzYW1lIGxvZ2ljIGluIDIueClcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcywgYXNSYXdTdGF0ZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtSWYgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKC9eKGlmfGVsc2V8ZWxzZS1pZikkLywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIChpZk5vZGUsIGJyYW5jaCwgaXNSb290KSA9PiB7XHJcbiAgICAgICAgLy8gIzE1ODc6IFdlIG5lZWQgdG8gZHluYW1pY2FsbHkgaW5jcmVtZW50IHRoZSBrZXkgYmFzZWQgb24gdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyBub2RlJ3Mgc2libGluZyBub2Rlcywgc2luY2UgY2hhaW5lZCB2LWlmL2Vsc2UgYnJhbmNoZXMgYXJlXHJcbiAgICAgICAgLy8gcmVuZGVyZWQgYXQgdGhlIHNhbWUgZGVwdGhcclxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihpZk5vZGUpO1xyXG4gICAgICAgIGxldCBrZXkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpLS0gPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAga2V5ICs9IHNpYmxpbmcuYnJhbmNoZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV4aXQgY2FsbGJhY2suIENvbXBsZXRlIHRoZSBjb2RlZ2VuTm9kZSB3aGVuIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW5cclxuICAgICAgICAvLyB0cmFuc2Zvcm1lZC5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSb290KSB7XHJcbiAgICAgICAgICAgICAgICBpZk5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBicmFuY2gncyBjb2RlZ2VuIG5vZGUgdG8gdGhlIHYtaWYgcm9vdC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENvbmRpdGlvbiA9IGdldFBhcmVudENvbmRpdGlvbihpZk5vZGUuY29kZWdlbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZGl0aW9uLmFsdGVybmF0ZSA9IGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5ICsgaWZOb2RlLmJyYW5jaGVzLmxlbmd0aCAtIDEsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59KTtcclxuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXHJcbmZ1bmN0aW9uIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdlbHNlJyAmJlxyXG4gICAgICAgICghZGlyLmV4cCB8fCAhZGlyLmV4cC5jb250ZW50LnRyaW0oKSkpIHtcclxuICAgICAgICBjb25zdCBsb2MgPSBkaXIuZXhwID8gZGlyLmV4cC5sb2MgOiBub2RlLmxvYztcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyNyAvKiBYX1ZfSUZfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIGRpci5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUgJiYgZGlyLmV4cCkge1xyXG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZGlyLmV4cCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLm5hbWUgPT09ICdpZicpIHtcclxuICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xyXG4gICAgICAgIGNvbnN0IGlmTm9kZSA9IHtcclxuICAgICAgICAgICAgdHlwZTogOSAvKiBJRiAqLyxcclxuICAgICAgICAgICAgbG9jOiBub2RlLmxvYyxcclxuICAgICAgICAgICAgYnJhbmNoZXM6IFticmFuY2hdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb250ZXh0LnJlcGxhY2VOb2RlKGlmTm9kZSk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NDb2RlZ2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbG9jYXRlIHRoZSBhZGphY2VudCB2LWlmXHJcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjb21tZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihub2RlKTtcclxuICAgICAgICB3aGlsZSAoaS0tID49IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50cy51bnNoaWZ0KHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiZcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcudHlwZSA9PT0gMiAvKiBURVhUICovICYmXHJcbiAgICAgICAgICAgICAgICAhc2libGluZy5jb250ZW50LnRyaW0oKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBJRiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgbm9kZSB0byB0aGUgaWYgbm9kZSdzIGJyYW5jaGVzXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaC5jaGlsZHJlbiA9IFsuLi5jb21tZW50cywgLi4uYnJhbmNoLmNoaWxkcmVuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHVzZXIgaXMgZm9yY2luZyBzYW1lIGtleSBvbiBkaWZmZXJlbnQgYnJhbmNoZXNcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBicmFuY2gudXNlcktleTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMuZm9yRWFjaCgoeyB1c2VyS2V5IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVLZXkodXNlcktleSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI4IC8qIFhfVl9JRl9TQU1FX0tFWSAqLywgYnJhbmNoLnVzZXJLZXkubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMucHVzaChicmFuY2gpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oc2libGluZywgYnJhbmNoLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgYnJhbmNoIHdhcyByZW1vdmVkLCBpdCB3aWxsIG5vdCBiZSB0cmF2ZXJzZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gdHJhdmVyc2UgaGVyZS5cclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShicmFuY2gsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBvbiBleGl0XHJcbiAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc2V0IGN1cnJlbnROb2RlIGFmdGVyIHRyYXZlcnNhbCB0byBpbmRpY2F0ZSB0aGlzXHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI5IC8qIFhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCBub2RlLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMTAgLyogSUZfQlJBTkNIICovLFxyXG4gICAgICAgIGxvYzogbm9kZS5sb2MsXHJcbiAgICAgICAgY29uZGl0aW9uOiBkaXIubmFtZSA9PT0gJ2Vsc2UnID8gdW5kZWZpbmVkIDogZGlyLmV4cCxcclxuICAgICAgICBjaGlsZHJlbjogbm9kZS50YWdUeXBlID09PSAzIC8qIFRFTVBMQVRFICovICYmICFmaW5kRGlyKG5vZGUsICdmb3InKVxyXG4gICAgICAgICAgICA/IG5vZGUuY2hpbGRyZW5cclxuICAgICAgICAgICAgOiBbbm9kZV0sXHJcbiAgICAgICAgdXNlcktleTogZmluZFByb3Aobm9kZSwgYGtleWApXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpIHtcclxuICAgIGlmIChicmFuY2guY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihicmFuY2guY29uZGl0aW9uLCBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpLCBcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcGFzcyBpbiBhc0Jsb2NrOiB0cnVlIHNvIHRoYXQgdGhlIGNvbW1lbnQgbm9kZSBjYWxsXHJcbiAgICAgICAgLy8gY2xvc2VzIHRoZSBjdXJyZW50IGJsb2NrLlxyXG4gICAgICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKSwgW1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnXCJ2LWlmXCInIDogJ1wiXCInLFxyXG4gICAgICAgICAgICAndHJ1ZSdcclxuICAgICAgICBdKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3Qga2V5UHJvcGVydHkgPSBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXlJbmRleH1gLCBmYWxzZSwgbG9jU3R1YiwgMiAvKiBDQU5fSE9JU1QgKi8pKTtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGJyYW5jaDtcclxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgZmlyc3RDaGlsZC50eXBlICE9PSAxIC8qIEVMRU1FTlQgKi87XHJcbiAgICBpZiAobmVlZEZyYWdtZW50V3JhcHBlcikge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZmlyc3RDaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8pIHtcclxuICAgICAgICAgICAgLy8gb3B0aW1pemUgYXdheSBuZXN0ZWQgZnJhZ21lbnRzIHdoZW4gY2hpbGQgaXMgYSBGb3JOb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IHZub2RlQ2FsbCA9IGZpcnN0Q2hpbGQuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZUNhbGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW2tleVByb3BlcnR5XSksIGNoaWxkcmVuLCA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gK1xyXG4gICAgICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL119ICovYFxyXG4gICAgICAgICAgICAgICAgICAgIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsIGJyYW5jaC5sb2MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHZub2RlQ2FsbCA9IGZpcnN0Q2hpbGRcclxuICAgICAgICAgICAgLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgIC8vIENoYW5nZSBjcmVhdGVWTm9kZSB0byBjcmVhdGVCbG9jay5cclxuICAgICAgICBpZiAodm5vZGVDYWxsLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgdm5vZGVDYWxsLmlzQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICBoZWxwZXIoT1BFTl9CTE9DSyk7XHJcbiAgICAgICAgICAgIGhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgYnJhbmNoIGtleVxyXG4gICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlQ2FsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1NhbWVLZXkoYSwgYikge1xyXG4gICAgaWYgKCFhIHx8IGEudHlwZSAhPT0gYi50eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGEudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICBpZiAoYS52YWx1ZS5jb250ZW50ICE9PSBiLnZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRpcmVjdGl2ZVxyXG4gICAgICAgIGNvbnN0IGV4cCA9IGEuZXhwO1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaEV4cCA9IGIuZXhwO1xyXG4gICAgICAgIGlmIChleHAudHlwZSAhPT0gYnJhbmNoRXhwLnR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgKGV4cC5pc1N0YXRpYyAhPT0gYnJhbmNoRXhwLmlzU3RhdGljIHx8XHJcbiAgICAgICAgICAgICAgICBleHAuY29udGVudCAhPT0gYnJhbmNoRXhwLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBnZXRQYXJlbnRDb25kaXRpb24obm9kZSkge1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5hbHRlcm5hdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUZvciA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oJ2ZvcicsIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xyXG4gICAgcmV0dXJuIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBmb3JOb2RlID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgdGhlIGxvb3AgcmVuZGVyIGZ1bmN0aW9uIGV4cHJlc3Npb24gbm93LCBhbmQgYWRkIHRoZVxyXG4gICAgICAgIC8vIGl0ZXJhdG9yIG9uIGV4aXQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcclxuICAgICAgICBjb25zdCByZW5kZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihoZWxwZXIoUkVOREVSX0xJU1QpLCBbXHJcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3Qga2V5UHJvcCA9IGZpbmRQcm9wKG5vZGUsIGBrZXlgKTtcclxuICAgICAgICBjb25zdCBrZXlQcm9wZXJ0eSA9IGtleVByb3BcclxuICAgICAgICAgICAgPyBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwga2V5UHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqL1xyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleVByb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDoga2V5UHJvcC5leHApXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBjb25zdCBpc1N0YWJsZUZyYWdtZW50ID0gZm9yTm9kZS5zb3VyY2UudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgICAgICBmb3JOb2RlLnNvdXJjZS5jb25zdFR5cGUgPiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICBjb25zdCBmcmFnbWVudEZsYWcgPSBpc1N0YWJsZUZyYWdtZW50XHJcbiAgICAgICAgICAgID8gNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXHJcbiAgICAgICAgICAgIDoga2V5UHJvcFxyXG4gICAgICAgICAgICAgICAgPyAxMjggLyogS0VZRURfRlJBR01FTlQgKi9cclxuICAgICAgICAgICAgICAgIDogMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi87XHJcbiAgICAgICAgZm9yTm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCB1bmRlZmluZWQsIHJlbmRlckV4cCwgZnJhZ21lbnRGbGFnICtcclxuICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1tmcmFnbWVudEZsYWddfSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlIC8qIGlzQmxvY2sgKi8sICFpc1N0YWJsZUZyYWdtZW50IC8qIGRpc2FibGVUcmFja2luZyAqLywgbm9kZS5sb2MpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpbmlzaCB0aGUgY29kZWdlbiBub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIHRyYXZlcnNlZFxyXG4gICAgICAgICAgICBsZXQgY2hpbGRCbG9jaztcclxuICAgICAgICAgICAgY29uc3QgaXNUZW1wbGF0ZSA9IGlzVGVtcGxhdGVOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBmb3JOb2RlO1xyXG4gICAgICAgICAgICAvLyBjaGVjayA8dGVtcGxhdGUgdi1mb3I+IGtleSBwbGFjZW1lbnRcclxuICAgICAgICAgICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpICYmIGlzVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZmluZFByb3AoYywgJ2tleScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMiAvKiBYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi8sIGtleS5sb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZHJlblswXS50eXBlICE9PSAxIC8qIEVMRU1FTlQgKi87XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RPdXRsZXQgPSBpc1Nsb3RPdXRsZXQobm9kZSlcclxuICAgICAgICAgICAgICAgID8gbm9kZVxyXG4gICAgICAgICAgICAgICAgOiBpc1RlbXBsYXRlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1Nsb3RPdXRsZXQobm9kZS5jaGlsZHJlblswXSlcclxuICAgICAgICAgICAgICAgICAgICA/IG5vZGUuY2hpbGRyZW5bMF0gLy8gYXBpLWV4dHJhY3RvciBzb21laG93IGZhaWxzIHRvIGluZmVyIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChzbG90T3V0bGV0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8c2xvdCB2LWZvcj1cIi4uLlwiPiBvciA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIj48c2xvdC8+PC90ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBzbG90T3V0bGV0LmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIiA6a2V5PVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbmplY3QgdGhlIGtleSB0byB0aGUgcmVuZGVyU2xvdCgpIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3BzIGZvciByZW5kZXJTbG90IGlzIHBhc3NlZCBhcyB0aGUgM3JkIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiPiB3aXRoIHRleHQgb3IgbXVsdGktZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBnZW5lcmF0ZSBhIGZyYWdtZW50IGJsb2NrIGZvciBlYWNoIGxvb3BcclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwga2V5UHJvcGVydHkgPyBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pIDogdW5kZWZpbmVkLCBub2RlLmNoaWxkcmVuLCA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gK1xyXG4gICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXX0gKi9gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgZWxlbWVudCB2LWZvci4gRGlyZWN0bHkgdXNlIHRoZSBjaGlsZCdzIGNvZGVnZW5Ob2RlXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgbWFyayBpdCBhcyBhIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IGNoaWxkcmVuWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2suaXNCbG9jayA9ICFpc1N0YWJsZUZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoQ1JFQVRFX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlckV4cC5hcmd1bWVudHMucHVzaChjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhmb3JOb2RlLnBhcnNlUmVzdWx0KSwgY2hpbGRCbG9jaywgdHJ1ZSAvKiBmb3JjZSBuZXdsaW5lICovKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59KTtcclxuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAgLyogWF9WX0ZPUl9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyc2VSZXN1bHQgPSBwYXJzZUZvckV4cHJlc3Npb24oXHJcbiAgICAvLyBjYW4gb25seSBiZSBzaW1wbGUgZXhwcmVzc2lvbiBiZWNhdXNlIHZGb3IgdHJhbnNmb3JtIGlzIGFwcGxpZWRcclxuICAgIC8vIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybS5cclxuICAgIGRpci5leHAsIGNvbnRleHQpO1xyXG4gICAgaWYgKCFwYXJzZVJlc3VsdCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMxIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycywgc2NvcGVzIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBzb3VyY2UsIHZhbHVlLCBrZXksIGluZGV4IH0gPSBwYXJzZVJlc3VsdDtcclxuICAgIGNvbnN0IGZvck5vZGUgPSB7XHJcbiAgICAgICAgdHlwZTogMTEgLyogRk9SICovLFxyXG4gICAgICAgIGxvYzogZGlyLmxvYyxcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgdmFsdWVBbGlhczogdmFsdWUsXHJcbiAgICAgICAga2V5QWxpYXM6IGtleSxcclxuICAgICAgICBvYmplY3RJbmRleEFsaWFzOiBpbmRleCxcclxuICAgICAgICBwYXJzZVJlc3VsdCxcclxuICAgICAgICBjaGlsZHJlbjogaXNUZW1wbGF0ZU5vZGUobm9kZSkgPyBub2RlLmNoaWxkcmVuIDogW25vZGVdXHJcbiAgICB9O1xyXG4gICAgY29udGV4dC5yZXBsYWNlTm9kZShmb3JOb2RlKTtcclxuICAgIC8vIGJvb2trZWVwaW5nXHJcbiAgICBzY29wZXMudkZvcisrO1xyXG4gICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oZm9yTm9kZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHNjb3Blcy52Rm9yLS07XHJcbiAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgb25FeGl0KCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XHJcbi8vIFRoaXMgcmVnZXggZG9lc24ndCBjb3ZlciB0aGUgY2FzZSBpZiBrZXkgb3IgaW5kZXggYWxpYXNlcyBoYXZlIGRlc3RydWN0dXJpbmcsXHJcbi8vIGJ1dCB0aG9zZSBkbyBub3QgbWFrZSBzZW5zZSBpbiB0aGUgZmlyc3QgcGxhY2UsIHNvIHRoaXMgd29ya3MgaW4gcHJhY3RpY2UuXHJcbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XHJcbmNvbnN0IHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XHJcbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihpbnB1dCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgbG9jID0gaW5wdXQubG9jO1xyXG4gICAgY29uc3QgZXhwID0gaW5wdXQuY29udGVudDtcclxuICAgIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgICBpZiAoIWluTWF0Y2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgWywgTEhTLCBSSFNdID0gaW5NYXRjaDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBzb3VyY2U6IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIFJIUy50cmltKCksIGV4cC5pbmRleE9mKFJIUywgTEhTLmxlbmd0aCkpLFxyXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXHJcbiAgICAgICAgaW5kZXg6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LnNvdXJjZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBsZXQgdmFsdWVDb250ZW50ID0gTEhTLnRyaW0oKVxyXG4gICAgICAgIC5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKVxyXG4gICAgICAgIC50cmltKCk7XHJcbiAgICBjb25zdCB0cmltbWVkT2Zmc2V0ID0gTEhTLmluZGV4T2YodmFsdWVDb250ZW50KTtcclxuICAgIGNvbnN0IGl0ZXJhdG9yTWF0Y2ggPSB2YWx1ZUNvbnRlbnQubWF0Y2goZm9ySXRlcmF0b3JSRSk7XHJcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xyXG4gICAgICAgIHZhbHVlQ29udGVudCA9IHZhbHVlQ29udGVudC5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XHJcbiAgICAgICAgY29uc3Qga2V5Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgICAgIGxldCBrZXlPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGtleUNvbnRlbnQpIHtcclxuICAgICAgICAgICAga2V5T2Zmc2V0ID0gZXhwLmluZGV4T2Yoa2V5Q29udGVudCwgdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZXN1bHQua2V5ID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywga2V5Q29udGVudCwga2V5T2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5rZXksIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXggPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBpbmRleENvbnRlbnQsIGV4cC5pbmRleE9mKGluZGV4Q29udGVudCwgcmVzdWx0LmtleVxyXG4gICAgICAgICAgICAgICAgICAgID8ga2V5T2Zmc2V0ICsga2V5Q29udGVudC5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA6IHRyaW1tZWRPZmZzZXQgKyB2YWx1ZUNvbnRlbnQubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5pbmRleCwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWVDb250ZW50KSB7XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgdmFsdWVDb250ZW50LCB0cmltbWVkT2Zmc2V0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQudmFsdWUsIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQWxpYXNFeHByZXNzaW9uKHJhbmdlLCBjb250ZW50LCBvZmZzZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBnZXRJbm5lclJhbmdlKHJhbmdlLCBvZmZzZXQsIGNvbnRlbnQubGVuZ3RoKSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yTG9vcFBhcmFtcyh7IHZhbHVlLCBrZXksIGluZGV4IH0pIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgcGFyYW1zLnB1c2godmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2AsIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfYCwgZmFsc2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfX2AsIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcy5wdXNoKGluZGV4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cblxuY29uc3QgZGVmYXVsdEZhbGxiYWNrID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdW5kZWZpbmVkYCwgZmFsc2UpO1xyXG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdDpcclxuLy8gMS4gVHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgc28gdGhhdCB0aGV5IGRvbid0IGdldCBwcmVmaXhlZFxyXG4vLyAgICBieSB0cmFuc2Zvcm1FeHByZXNzaW9uLiBUaGlzIGlzIG9ubHkgYXBwbGllZCBpbiBub24tYnJvd3NlciBidWlsZHMgd2l0aFxyXG4vLyAgICB7IHByZWZpeElkZW50aWZpZXJzOiB0cnVlIH0uXHJcbi8vIDIuIFRyYWNrIHYtc2xvdCBkZXB0aHMgc28gdGhhdCB3ZSBrbm93IGEgc2xvdCBpcyBpbnNpZGUgYW5vdGhlciBzbG90LlxyXG4vLyAgICBOb3RlIHRoZSBleGl0IGNhbGxiYWNrIGlzIGV4ZWN1dGVkIGJlZm9yZSBidWlsZFNsb3RzKCkgb24gdGhlIHNhbWUgbm9kZSxcclxuLy8gICAgc28gb25seSBuZXN0ZWQgc2xvdHMgc2VlIHBvc2l0aXZlIG51bWJlcnMuXHJcbmNvbnN0IHRyYWNrU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAobm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLyB8fFxyXG4gICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8pKSB7XHJcbiAgICAgICAgLy8gV2UgYXJlIG9ubHkgY2hlY2tpbmcgbm9uLWVtcHR5IHYtc2xvdCBoZXJlXHJcbiAgICAgICAgLy8gc2luY2Ugd2Ugb25seSBjYXJlIGFib3V0IHNsb3RzIHRoYXQgaW50cm9kdWNlIHNjb3BlIHZhcmlhYmxlcy5cclxuICAgICAgICBjb25zdCB2U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnKTtcclxuICAgICAgICBpZiAodlNsb3QpIHtcclxuICAgICAgICAgICAgdlNsb3QuZXhwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0IHRyYWNrcyBzY29wZSBpZGVudGlmaWVycyBmb3Igc2NvcGVkIHNsb3RzIHdpdGggdi1mb3IuXHJcbi8vIFRoaXMgdHJhbnNmb3JtIGlzIG9ubHkgYXBwbGllZCBpbiBub24tYnJvd3NlciBidWlsZHMgd2l0aCB7IHByZWZpeElkZW50aWZpZXJzOiB0cnVlIH1cclxuY29uc3QgdHJhY2tWRm9yU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBsZXQgdkZvcjtcclxuICAgIGlmIChpc1RlbXBsYXRlTm9kZShub2RlKSAmJlxyXG4gICAgICAgIG5vZGUucHJvcHMuc29tZShpc1ZTbG90KSAmJlxyXG4gICAgICAgICh2Rm9yID0gZmluZERpcihub2RlLCAnZm9yJykpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKHZGb3IucGFyc2VSZXN1bHQgPSBwYXJzZUZvckV4cHJlc3Npb24odkZvci5leHAsIGNvbnRleHQpKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGtleSwgaW5kZXggfSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgY29uc3QgeyBhZGRJZGVudGlmaWVycywgcmVtb3ZlSWRlbnRpZmllcnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIHZhbHVlICYmIGFkZElkZW50aWZpZXJzKHZhbHVlKTtcclxuICAgICAgICAgICAga2V5ICYmIGFkZElkZW50aWZpZXJzKGtleSk7XHJcbiAgICAgICAgICAgIGluZGV4ICYmIGFkZElkZW50aWZpZXJzKGluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlICYmIHJlbW92ZUlkZW50aWZpZXJzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGtleSAmJiByZW1vdmVJZGVudGlmaWVycyhrZXkpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggJiYgcmVtb3ZlSWRlbnRpZmllcnMoaW5kZXgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgYnVpbGRDbGllbnRTbG90Rm4gPSAocHJvcHMsIGNoaWxkcmVuLCBsb2MpID0+IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihwcm9wcywgY2hpbGRyZW4sIGZhbHNlIC8qIG5ld2xpbmUgKi8sIHRydWUgLyogaXNTbG90ICovLCBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlblswXS5sb2MgOiBsb2MpO1xyXG4vLyBJbnN0ZWFkIG9mIGJlaW5nIGEgRGlyZWN0aXZlVHJhbnNmb3JtLCB2LXNsb3QgcHJvY2Vzc2luZyBpcyBjYWxsZWQgZHVyaW5nXHJcbi8vIHRyYW5zZm9ybUVsZW1lbnQgdG8gYnVpbGQgdGhlIHNsb3RzIG9iamVjdCBmb3IgYSBjb21wb25lbnQuXHJcbmZ1bmN0aW9uIGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCwgYnVpbGRTbG90Rm4gPSBidWlsZENsaWVudFNsb3RGbikge1xyXG4gICAgY29udGV4dC5oZWxwZXIoV0lUSF9DVFgpO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gICAgY29uc3Qgc2xvdHNQcm9wZXJ0aWVzID0gW107XHJcbiAgICBjb25zdCBkeW5hbWljU2xvdHMgPSBbXTtcclxuICAgIGNvbnN0IGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSA9IChwcm9wcywgY2hpbGRyZW4pID0+IGNyZWF0ZU9iamVjdFByb3BlcnR5KGBkZWZhdWx0YCwgYnVpbGRTbG90Rm4ocHJvcHMsIGNoaWxkcmVuLCBsb2MpKTtcclxuICAgIC8vIElmIHRoZSBzbG90IGlzIGluc2lkZSBhIHYtZm9yIG9yIGFub3RoZXIgdi1zbG90LCBmb3JjZSBpdCB0byBiZSBkeW5hbWljXHJcbiAgICAvLyBzaW5jZSBpdCBsaWtlbHkgdXNlcyBhIHNjb3BlIHZhcmlhYmxlLlxyXG4gICAgbGV0IGhhc0R5bmFtaWNTbG90cyA9IGNvbnRleHQuc2NvcGVzLnZTbG90ID4gMCB8fCBjb250ZXh0LnNjb3Blcy52Rm9yID4gMDtcclxuICAgIC8vIDEuIENoZWNrIGZvciBzbG90IHdpdGggc2xvdFByb3BzIG9uIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAvLyAgICA8Q29tcCB2LXNsb3Q9XCJ7IHByb3AgfVwiLz5cclxuICAgIGNvbnN0IG9uQ29tcG9uZW50U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnLCB0cnVlKTtcclxuICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICBjb25zdCB7IGFyZywgZXhwIH0gPSBvbkNvbXBvbmVudFNsb3Q7XHJcbiAgICAgICAgaWYgKGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignZGVmYXVsdCcsIHRydWUpLCBidWlsZFNsb3RGbihleHAsIGNoaWxkcmVuLCBsb2MpKSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLiBJdGVyYXRlIHRocm91Z2ggY2hpbGRyZW4gYW5kIGNoZWNrIGZvciB0ZW1wbGF0ZSBzbG90c1xyXG4gICAgLy8gICAgPHRlbXBsYXRlIHYtc2xvdDpmb289XCJ7IHByb3AgfVwiPlxyXG4gICAgbGV0IGhhc1RlbXBsYXRlU2xvdHMgPSBmYWxzZTtcclxuICAgIGxldCBoYXNOYW1lZERlZmF1bHRTbG90ID0gZmFsc2U7XHJcbiAgICBjb25zdCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbiA9IFtdO1xyXG4gICAgY29uc3Qgc2VlblNsb3ROYW1lcyA9IG5ldyBTZXQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzbG90RWxlbWVudCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGxldCBzbG90RGlyO1xyXG4gICAgICAgIGlmICghaXNUZW1wbGF0ZU5vZGUoc2xvdEVsZW1lbnQpIHx8XHJcbiAgICAgICAgICAgICEoc2xvdERpciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdzbG90JywgdHJ1ZSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdCBhIDx0ZW1wbGF0ZSB2LXNsb3Q+LCBza2lwLlxyXG4gICAgICAgICAgICBpZiAoc2xvdEVsZW1lbnQudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5wdXNoKHNsb3RFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgICAgICAvLyBhbHJlYWR5IGhhcyBvbi1jb21wb25lbnQgc2xvdCAtIHRoaXMgaXMgaW5jb3JyZWN0IHVzYWdlLlxyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNiAvKiBYX1ZfU0xPVF9NSVhFRF9TTE9UX1VTQUdFICovLCBzbG90RGlyLmxvYykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzVGVtcGxhdGVTbG90cyA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogc2xvdENoaWxkcmVuLCBsb2M6IHNsb3RMb2MgfSA9IHNsb3RFbGVtZW50O1xyXG4gICAgICAgIGNvbnN0IHsgYXJnOiBzbG90TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGRlZmF1bHRgLCB0cnVlKSwgZXhwOiBzbG90UHJvcHMsIGxvYzogZGlyTG9jIH0gPSBzbG90RGlyO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIG5hbWUgaXMgZHluYW1pYy5cclxuICAgICAgICBsZXQgc3RhdGljU2xvdE5hbWU7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljRXhwKHNsb3ROYW1lKSkge1xyXG4gICAgICAgICAgICBzdGF0aWNTbG90TmFtZSA9IHNsb3ROYW1lID8gc2xvdE5hbWUuY29udGVudCA6IGBkZWZhdWx0YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNsb3RGdW5jdGlvbiA9IGJ1aWxkU2xvdEZuKHNsb3RQcm9wcywgc2xvdENoaWxkcmVuLCBzbG90TG9jKTtcclxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHNsb3QgaXMgY29uZGl0aW9uYWwgKHYtaWYvdi1mb3IpXHJcbiAgICAgICAgbGV0IHZJZjtcclxuICAgICAgICBsZXQgdkVsc2U7XHJcbiAgICAgICAgbGV0IHZGb3I7XHJcbiAgICAgICAgaWYgKCh2SWYgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnaWYnKSkpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHZJZi5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIGRlZmF1bHRGYWxsYmFjaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodkVsc2UgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAvXmVsc2UoLWlmKT8kLywgdHJ1ZSAvKiBhbGxvd0VtcHR5ICovKSkpIHtcclxuICAgICAgICAgICAgLy8gZmluZCBhZGphY2VudCB2LWlmXHJcbiAgICAgICAgICAgIGxldCBqID0gaTtcclxuICAgICAgICAgICAgbGV0IHByZXY7XHJcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcclxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2LnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIGlzVGVtcGxhdGVOb2RlKHByZXYpICYmIGZpbmREaXIocHJldiwgJ2lmJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBzbG90IHRvIHByZXZpb3VzIGNvbmRpdGlvbmFsXHJcbiAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uYWwgPSBkeW5hbWljU2xvdHNbZHluYW1pY1Nsb3RzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbmRpdGlvbmFsLmFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5hbHRlcm5hdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb25hbC5hbHRlcm5hdGUgPSB2RWxzZS5leHBcclxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2RWxzZS5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIGRlZmF1bHRGYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICA6IGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOSAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqLywgdkVsc2UubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHZGb3IgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnZm9yJykpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gdkZvci5wYXJzZVJlc3VsdCB8fFxyXG4gICAgICAgICAgICAgICAgcGFyc2VGb3JFeHByZXNzaW9uKHZGb3IuZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIGR5bmFtaWMgc2xvdHMgYXMgYW4gYXJyYXkgYW5kIGFkZCBpdCB0byB0aGUgY3JlYXRlU2xvdCgpXHJcbiAgICAgICAgICAgICAgICAvLyBhcmdzLiBUaGUgcnVudGltZSBrbm93cyBob3cgdG8gaGFuZGxlIGl0IGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRU5ERVJfTElTVCksIFtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMocGFyc2VSZXN1bHQpLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pLCB0cnVlIC8qIGZvcmNlIG5ld2xpbmUgKi8pXHJcbiAgICAgICAgICAgICAgICBdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMSAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCB2Rm9yLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBkdXBsaWNhdGUgc3RhdGljIG5hbWVzXHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW5TbG90TmFtZXMuaGFzKHN0YXRpY1Nsb3ROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM3IC8qIFhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTICovLCBkaXJMb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlZW5TbG90TmFtZXMuYWRkKHN0YXRpY1Nsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTmFtZWREZWZhdWx0U2xvdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghb25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgaWYgKCFoYXNUZW1wbGF0ZVNsb3RzKSB7XHJcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAob24gY29tcG9uZW50KVxyXG4gICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBjaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gaW1wbGljaXQgZGVmYXVsdCBzbG90IChtaXhlZCB3aXRoIG5hbWVkIHNsb3RzKVxyXG4gICAgICAgICAgICBpZiAoaGFzTmFtZWREZWZhdWx0U2xvdCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzggLyogWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU4gKi8sIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuWzBdLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHVuZGVmaW5lZCwgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHNsb3RGbGFnID0gaGFzRHluYW1pY1Nsb3RzXHJcbiAgICAgICAgPyAyIC8qIERZTkFNSUMgKi9cclxuICAgICAgICA6IGhhc0ZvcndhcmRlZFNsb3RzKG5vZGUuY2hpbGRyZW4pXHJcbiAgICAgICAgICAgID8gMyAvKiBGT1JXQVJERUQgKi9cclxuICAgICAgICAgICAgOiAxIC8qIFNUQUJMRSAqLztcclxuICAgIGxldCBzbG90cyA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oc2xvdHNQcm9wZXJ0aWVzLmNvbmNhdChjcmVhdGVPYmplY3RQcm9wZXJ0eShgX2AsIFxyXG4gICAgLy8gMiA9IGNvbXBpbGVkIGJ1dCBkeW5hbWljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiwgYnV0IG11c3QgcnVuIGRpZmZcclxuICAgIC8vIDEgPSBjb21waWxlZCBhbmQgc3RhdGljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiBBTkQgZGlmZiBhcyBvcHRpbWl6ZWRcclxuICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oc2xvdEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3Nsb3RGbGFnc1RleHRbc2xvdEZsYWddfSAqL2AgOiBgYCksIGZhbHNlKSkpLCBsb2MpO1xyXG4gICAgaWYgKGR5bmFtaWNTbG90cy5sZW5ndGgpIHtcclxuICAgICAgICBzbG90cyA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9TTE9UUyksIFtcclxuICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkeW5hbWljU2xvdHMpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNsb3RzLFxyXG4gICAgICAgIGhhc0R5bmFtaWNTbG90c1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBidWlsZER5bmFtaWNTbG90KG5hbWUsIGZuKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYG5hbWVgLCBuYW1lKSxcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZm5gLCBmbilcclxuICAgIF0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkcmVuKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50YWdUeXBlID09PSAyIC8qIFNMT1QgKi8gfHxcclxuICAgICAgICAgICAgICAgIChjaGlsZC50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5jaGlsZHJlbikpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG4vLyBzb21lIGRpcmVjdGl2ZSB0cmFuc2Zvcm1zIChlLmcuIHYtbW9kZWwpIG1heSByZXR1cm4gYSBzeW1ib2wgZm9yIHJ1bnRpbWVcclxuLy8gaW1wb3J0LCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxyXG5jb25zdCBkaXJlY3RpdmVJbXBvcnRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyBnZW5lcmF0ZSBhIEphdmFTY3JpcHQgQVNUIGZvciB0aGlzIGVsZW1lbnQncyBjb2RlZ2VuXHJcbmNvbnN0IHRyYW5zZm9ybUVsZW1lbnQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKCEobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAobm9kZS50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gcGVyZm9ybSB0aGUgd29yayBvbiBleGl0LCBhZnRlciBhbGwgY2hpbGQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXHJcbiAgICAvLyBwcm9jZXNzZWQgYW5kIG1lcmdlZC5cclxuICAgIHJldHVybiBmdW5jdGlvbiBwb3N0VHJhbnNmb3JtRWxlbWVudCgpIHtcclxuICAgICAgICBjb25zdCB7IHRhZywgcHJvcHMgfSA9IG5vZGU7XHJcbiAgICAgICAgY29uc3QgaXNDb21wb25lbnQgPSBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgIC8vIFRoZSBnb2FsIG9mIHRoZSB0cmFuc2Zvcm0gaXMgdG8gY3JlYXRlIGEgY29kZWdlbk5vZGUgaW1wbGVtZW50aW5nIHRoZVxyXG4gICAgICAgIC8vIFZOb2RlQ2FsbCBpbnRlcmZhY2UuXHJcbiAgICAgICAgY29uc3Qgdm5vZGVUYWcgPSBpc0NvbXBvbmVudFxyXG4gICAgICAgICAgICA/IHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQpXHJcbiAgICAgICAgICAgIDogYFwiJHt0YWd9XCJgO1xyXG4gICAgICAgIGNvbnN0IGlzRHluYW1pY0NvbXBvbmVudCA9IGlzT2JqZWN0KHZub2RlVGFnKSAmJiB2bm9kZVRhZy5jYWxsZWUgPT09IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQ7XHJcbiAgICAgICAgbGV0IHZub2RlUHJvcHM7XHJcbiAgICAgICAgbGV0IHZub2RlQ2hpbGRyZW47XHJcbiAgICAgICAgbGV0IHZub2RlUGF0Y2hGbGFnO1xyXG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgIGxldCB2bm9kZUR5bmFtaWNQcm9wcztcclxuICAgICAgICBsZXQgZHluYW1pY1Byb3BOYW1lcztcclxuICAgICAgICBsZXQgdm5vZGVEaXJlY3RpdmVzO1xyXG4gICAgICAgIGxldCBzaG91bGRVc2VCbG9jayA9IFxyXG4gICAgICAgIC8vIGR5bmFtaWMgY29tcG9uZW50IG1heSByZXNvbHZlIHRvIHBsYWluIGVsZW1lbnRzXHJcbiAgICAgICAgaXNEeW5hbWljQ29tcG9uZW50IHx8XHJcbiAgICAgICAgICAgIHZub2RlVGFnID09PSBURUxFUE9SVCB8fFxyXG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gU1VTUEVOU0UgfHxcclxuICAgICAgICAgICAgKCFpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gPHN2Zz4gYW5kIDxmb3JlaWduT2JqZWN0PiBtdXN0IGJlIGZvcmNlZCBpbnRvIGJsb2NrcyBzbyB0aGF0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGluc2lkZSBnZXQgcHJvcGVyIGlzU1ZHIGZsYWcgYXQgcnVudGltZS4gKCM2MzksICM2NDMpXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IHdlYi1zcGVjaWZpYywgYnV0IHNwbGl0dGluZyB0aGUgbG9naWMgb3V0IG9mIGNvcmVcclxuICAgICAgICAgICAgICAgIC8vIGxlYWRzIHRvIHRvbyBtdWNoIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkuXHJcbiAgICAgICAgICAgICAgICAodGFnID09PSAnc3ZnJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzkzODogZWxlbWVudHMgd2l0aCBkeW5hbWljIGtleXMgc2hvdWxkIGJlIGZvcmNlZCBpbnRvIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmRQcm9wKG5vZGUsICdrZXknLCB0cnVlKSkpO1xyXG4gICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcHNCdWlsZFJlc3VsdCA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHZub2RlUHJvcHMgPSBwcm9wc0J1aWxkUmVzdWx0LnByb3BzO1xyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSBwcm9wc0J1aWxkUmVzdWx0LnBhdGNoRmxhZztcclxuICAgICAgICAgICAgZHluYW1pY1Byb3BOYW1lcyA9IHByb3BzQnVpbGRSZXN1bHQuZHluYW1pY1Byb3BOYW1lcztcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHByb3BzQnVpbGRSZXN1bHQuZGlyZWN0aXZlcztcclxuICAgICAgICAgICAgdm5vZGVEaXJlY3RpdmVzID1cclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkaXJlY3RpdmVzLm1hcChkaXIgPT4gYnVpbGREaXJlY3RpdmVBcmdzKGRpciwgY29udGV4dCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHZub2RlVGFnID09PSBLRUVQX0FMSVZFKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbHRob3VnaCBhIGJ1aWx0LWluIGNvbXBvbmVudCwgd2UgY29tcGlsZSBLZWVwQWxpdmUgd2l0aCByYXcgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2Ygc2xvdCBmdW5jdGlvbnMgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbnNpZGUgVHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gb3Igb3RoZXIgVHJhbnNpdGlvbi13cmFwcGluZyBIT0NzLlxyXG4gICAgICAgICAgICAgICAgLy8gVG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcyB3aXRoIGJsb2NrIG9wdGltaXphdGlvbnMsIHdlIG5lZWQgdG86XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBGb3JjZSBrZWVwLWFsaXZlIGludG8gYSBibG9jay4gVGhpcyBhdm9pZHMgaXRzIGNoaWxkcmVuIGJlaW5nXHJcbiAgICAgICAgICAgICAgICAvLyAgICBjb2xsZWN0ZWQgYnkgYSBwYXJlbnQgYmxvY2suXHJcbiAgICAgICAgICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyAyLiBGb3JjZSBrZWVwLWFsaXZlIHRvIGFsd2F5cyBiZSB1cGRhdGVkLCBzaW5jZSBpdCB1c2VzIHJhdyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ0IC8qIFhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOICovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRCdWlsZEFzU2xvdHMgPSBpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgaXMgbm90IGEgcmVhbCBjb21wb25lbnQgYW5kIGhhcyBkZWRpY2F0ZWQgcnVudGltZSBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgdm5vZGVUYWcgIT09IFRFTEVQT1JUICYmXHJcbiAgICAgICAgICAgICAgICAvLyBleHBsYWluZWQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gS0VFUF9BTElWRTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEJ1aWxkQXNTbG90cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzbG90cywgaGFzRHluYW1pY1Nsb3RzIH0gPSBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IHNsb3RzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTbG90cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdm5vZGVUYWcgIT09IFRFTEVQT1JUKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gY2hpbGQudHlwZTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkeW5hbWljIHRleHQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNUZXh0Q2hpbGQgPSB0eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEgLyogVEVYVCAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgZGlyZWN0bHkgaWYgdGhlIG9ubHkgY2hpbGQgaXMgYSB0ZXh0IG5vZGVcclxuICAgICAgICAgICAgICAgIC8vIChwbGFpbiAvIGludGVycG9sYXRpb24gLyBleHByZXNzaW9uKVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgfHwgdHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXRjaEZsYWcgJiBkeW5hbWljUHJvcE5hbWVzXHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgZmxhZ3MgKG5lZ2F0aXZlIGFuZCBtdXR1YWxseSBleGNsdXNpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbcGF0Y2hGbGFnXX0gKi9gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0d2lzZSBmbGFnc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKFBhdGNoRmxhZ05hbWVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKE51bWJlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihuID0+IG4gPiAwICYmIHBhdGNoRmxhZyAmIG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBQYXRjaEZsYWdOYW1lc1tuXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oYCwgYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7ZmxhZ05hbWVzfSAqL2A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IFN0cmluZyhwYXRjaEZsYWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzICYmIGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUR5bmFtaWNQcm9wcyA9IHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMoZHluYW1pY1Byb3BOYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB2bm9kZVRhZywgdm5vZGVQcm9wcywgdm5vZGVDaGlsZHJlbiwgdm5vZGVQYXRjaEZsYWcsIHZub2RlRHluYW1pY1Byb3BzLCB2bm9kZURpcmVjdGl2ZXMsICEhc2hvdWxkVXNlQmxvY2ssIGZhbHNlIC8qIGRpc2FibGVUcmFja2luZyAqLywgbm9kZS5sb2MpO1xyXG4gICAgfTtcclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudFR5cGUobm9kZSwgY29udGV4dCwgc3NyID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgdGFnIH0gPSBub2RlO1xyXG4gICAgLy8gMS4gZHluYW1pYyBjb21wb25lbnRcclxuICAgIGNvbnN0IGlzUHJvcCA9IG5vZGUudGFnID09PSAnY29tcG9uZW50JyA/IGZpbmRQcm9wKG5vZGUsICdpcycpIDogZmluZERpcihub2RlLCAnaXMnKTtcclxuICAgIGlmIChpc1Byb3ApIHtcclxuICAgICAgICBjb25zdCBleHAgPSBpc1Byb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi9cclxuICAgICAgICAgICAgPyBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcclxuICAgICAgICAgICAgOiBpc1Byb3AuZXhwO1xyXG4gICAgICAgIGlmIChleHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXHJcbiAgICAgICAgICAgICAgICBleHBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMi4gYnVpbHQtaW4gY29tcG9uZW50cyAoVGVsZXBvcnQsIFRyYW5zaXRpb24sIEtlZXBBbGl2ZSwgU3VzcGVuc2UuLi4pXHJcbiAgICBjb25zdCBidWlsdEluID0gaXNDb3JlQ29tcG9uZW50KHRhZykgfHwgY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQodGFnKTtcclxuICAgIGlmIChidWlsdEluKSB7XHJcbiAgICAgICAgLy8gYnVpbHQtaW5zIGFyZSBzaW1wbHkgZmFsbHRocm91Z2hzIC8gaGF2ZSBzcGVjaWFsIGhhbmRsaW5nIGR1cmluZyBzc3JcclxuICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGltcG9ydCB0aGVpciBydW50aW1lIGVxdWl2YWxlbnRzXHJcbiAgICAgICAgaWYgKCFzc3IpXHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGJ1aWx0SW4pO1xyXG4gICAgICAgIHJldHVybiBidWlsdEluO1xyXG4gICAgfVxyXG4gICAgLy8gNS4gdXNlciBjb21wb25lbnQgKHJlc29sdmUpXHJcbiAgICBjb250ZXh0LmhlbHBlcihSRVNPTFZFX0NPTVBPTkVOVCk7XHJcbiAgICBjb250ZXh0LmNvbXBvbmVudHMuYWRkKHRhZyk7XHJcbiAgICByZXR1cm4gdG9WYWxpZEFzc2V0SWQodGFnLCBgY29tcG9uZW50YCk7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBwcm9wcyA9IG5vZGUucHJvcHMsIHNzciA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB7IHRhZywgbG9jOiBlbGVtZW50TG9jIH0gPSBub2RlO1xyXG4gICAgY29uc3QgaXNDb21wb25lbnQgPSBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgbGV0IHByb3BlcnRpZXMgPSBbXTtcclxuICAgIGNvbnN0IG1lcmdlQXJncyA9IFtdO1xyXG4gICAgY29uc3QgcnVudGltZURpcmVjdGl2ZXMgPSBbXTtcclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgbGV0IHBhdGNoRmxhZyA9IDA7XHJcbiAgICBsZXQgaGFzUmVmID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzQ2xhc3NCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzU3R5bGVCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzRHluYW1pY0tleXMgPSBmYWxzZTtcclxuICAgIGxldCBoYXNWbm9kZUhvb2sgPSBmYWxzZTtcclxuICAgIGNvbnN0IGR5bmFtaWNQcm9wTmFtZXMgPSBbXTtcclxuICAgIGNvbnN0IGFuYWx5emVQYXRjaEZsYWcgPSAoeyBrZXksIHZhbHVlIH0pID0+IHtcclxuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRXZlbnRIYW5kbGVyID0gaXNPbihuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc0NvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICAgICAgaXNFdmVudEhhbmRsZXIgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdGhlIGZsYWcgZm9yIGNsaWNrIGhhbmRsZXJzIGJlY2F1c2UgaHlkcmF0aW9uIGdpdmVzIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAvLyBkZWRpY2F0ZWQgZmFzdCBwYXRoLlxyXG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25jbGljaycgJiZcclxuICAgICAgICAgICAgICAgIC8vIG9taXQgdi1tb2RlbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ29uVXBkYXRlOm1vZGVsVmFsdWUnICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcclxuICAgICAgICAgICAgICAgICFpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiYgaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGhhc1Zub2RlSG9vayA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICgodmFsdWUudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUodmFsdWUsIGNvbnRleHQpID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIHByb3AgaXMgYSBjYWNoZWQgaGFuZGxlciBvciBoYXMgY29uc3RhbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhhc0NsYXNzQmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJyAmJiAhaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhhc1N0eWxlQmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ2tleScgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY0tleXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gc3RhdGljIGF0dHJpYnV0ZVxyXG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcclxuICAgICAgICBpZiAocHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxvYywgbmFtZSwgdmFsdWUgfSA9IHByb3A7XHJcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xyXG4gICAgICAgICAgICAgICAgaGFzUmVmID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIDppcyBvbiA8Y29tcG9uZW50PlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJiB0YWcgPT09ICdjb21wb25lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihuYW1lLCB0cnVlLCBnZXRJbm5lclJhbmdlKGxvYywgMCwgbmFtZS5sZW5ndGgpKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbih2YWx1ZSA/IHZhbHVlLmNvbnRlbnQgOiAnJywgaXNTdGF0aWMsIHZhbHVlID8gdmFsdWUubG9jIDogbG9jKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZywgZXhwLCBsb2MgfSA9IHByb3A7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQmluZCA9IG5hbWUgPT09ICdiaW5kJztcclxuICAgICAgICAgICAgY29uc3QgaXNPbiA9IG5hbWUgPT09ICdvbic7XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1zbG90IC0gaXQgaXMgaGFuZGxlZCBieSBpdHMgZGVkaWNhdGVkIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzbG90Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM5IC8qIFhfVl9TTE9UX01JU1BMQUNFRCAqLywgbG9jKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtb25jZSAtIGl0IGlzIGhhbmRsZWQgYnkgaXRzIGRlZGljYXRlZCB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb25jZScpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1pcyBhbmQgOmlzIG9uIDxjb21wb25lbnQ+XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaXMnIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNCaW5kICYmIHRhZyA9PT0gJ2NvbXBvbmVudCcgJiYgaXNCaW5kS2V5KGFyZywgJ2lzJykpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtb24gaW4gU1NSIGNvbXBpbGF0aW9uXHJcbiAgICAgICAgICAgIGlmIChpc09uICYmIHNzcikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB2LWJpbmQgYW5kIHYtb24gd2l0aCBubyBhcmd1bWVudFxyXG4gICAgICAgICAgICBpZiAoIWFyZyAmJiAoaXNCaW5kIHx8IGlzT24pKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goZXhwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtb249XCJvYmpcIiAtPiB0b0hhbmRsZXJzKG9iailcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBjb250ZXh0LmhlbHBlcihUT19IQU5ETEVSUyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtleHBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGlzQmluZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDMzIC8qIFhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAzNCAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmVUcmFuc2Zvcm0gPSBjb250ZXh0LmRpcmVjdGl2ZVRyYW5zZm9ybXNbbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmVUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGhhcyBidWlsdC1pbiBkaXJlY3RpdmUgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgbmVlZFJ1bnRpbWUgfSA9IGRpcmVjdGl2ZVRyYW5zZm9ybShwcm9wLCBub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICFzc3IgJiYgcHJvcHMuZm9yRWFjaChhbmFseXplUGF0Y2hGbGFnKTtcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCguLi5wcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVlZFJ1bnRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBydW50aW1lRGlyZWN0aXZlcy5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bWJvbChuZWVkUnVudGltZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlSW1wb3J0TWFwLnNldChwcm9wLCBuZWVkUnVudGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gYnVpbHQtaW4gdHJhbnNmb3JtLCB0aGlzIGlzIGEgdXNlciBjdXN0b20gZGlyZWN0aXZlLlxyXG4gICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBwcm9wc0V4cHJlc3Npb24gPSB1bmRlZmluZWQ7XHJcbiAgICAvLyBoYXMgdi1iaW5kPVwib2JqZWN0XCIgb3Igdi1vbj1cIm9iamVjdFwiLCB3cmFwIHdpdGggbWVyZ2VQcm9wc1xyXG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJnZUFyZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIG1lcmdlQXJncywgZWxlbWVudExvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggbm90aGluZyBlbHNlIC0gbm8gbmVlZCBmb3IgYSBtZXJnZVByb3BzIGNhbGxcclxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gbWVyZ2VBcmdzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKTtcclxuICAgIH1cclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgaWYgKGhhc0R5bmFtaWNLZXlzKSB7XHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IDE2IC8qIEZVTExfUFJPUFMgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaGFzQ2xhc3NCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyIC8qIENMQVNTICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzU3R5bGVCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSA0IC8qIFNUWUxFICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHluYW1pY1Byb3BOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDggLyogUFJPUFMgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgocGF0Y2hGbGFnID09PSAwIHx8IHBhdGNoRmxhZyA9PT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pICYmXHJcbiAgICAgICAgKGhhc1JlZiB8fCBoYXNWbm9kZUhvb2sgfHwgcnVudGltZURpcmVjdGl2ZXMubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICBwYXRjaEZsYWcgfD0gNTEyIC8qIE5FRURfUEFUQ0ggKi87XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBwcm9wc0V4cHJlc3Npb24sXHJcbiAgICAgICAgZGlyZWN0aXZlczogcnVudGltZURpcmVjdGl2ZXMsXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wTmFtZXNcclxuICAgIH07XHJcbn1cclxuLy8gRGVkdXBlIHByb3BzIGluIGFuIG9iamVjdCBsaXRlcmFsLlxyXG4vLyBMaXRlcmFsIGR1cGxpY2F0ZWQgYXR0cmlidXRlcyB3b3VsZCBoYXZlIGJlZW4gd2FybmVkIGR1cmluZyB0aGUgcGFyc2UgcGhhc2UsXHJcbi8vIGhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdG8gZW5jb3VudGVyIGR1cGxpY2F0ZWQgYG9uWFhYYCBoYW5kbGVycyB3aXRoIGRpZmZlcmVudFxyXG4vLyBtb2RpZmllcnMuIFdlIGFsc28gbmVlZCB0byBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgY2xhc3MgLyBzdHlsZSBhdHRyaWJ1dGVzLlxyXG4vLyAtIG9uWFhYIGhhbmRsZXJzIC8gc3R5bGU6IG1lcmdlIGludG8gYXJyYXlcclxuLy8gLSBjbGFzczogbWVyZ2UgaW50byBzaW5nbGUgZXhwcmVzc2lvbiB3aXRoIGNvbmNhdGVuYXRpb25cclxuZnVuY3Rpb24gZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XHJcbiAgICBjb25zdCBrbm93blByb3BzID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgZGVkdXBlZCA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgLy8gZHluYW1pYyBrZXlzIGFyZSBhbHdheXMgYWxsb3dlZFxyXG4gICAgICAgIGlmIChwcm9wLmtleS50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8gfHwgIXByb3Aua2V5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0ga25vd25Qcm9wcy5nZXQobmFtZSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnc3R5bGUnIHx8IG5hbWUgPT09ICdjbGFzcycgfHwgbmFtZS5zdGFydHNXaXRoKCdvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgZHVwbGljYXRlLCBzaG91bGQgaGF2ZSBlbWl0dGVkIGVycm9yIGR1cmluZyBwYXJzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAga25vd25Qcm9wcy5zZXQobmFtZSwgcHJvcCk7XHJcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVkdXBlZDtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIGluY29taW5nKSB7XHJcbiAgICBpZiAoZXhpc3RpbmcudmFsdWUudHlwZSA9PT0gMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGV4aXN0aW5nLnZhbHVlLmVsZW1lbnRzLnB1c2goaW5jb21pbmcudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXhpc3RpbmcudmFsdWUgPSBjcmVhdGVBcnJheUV4cHJlc3Npb24oW2V4aXN0aW5nLnZhbHVlLCBpbmNvbWluZy52YWx1ZV0sIGV4aXN0aW5nLmxvYyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYnVpbGREaXJlY3RpdmVBcmdzKGRpciwgY29udGV4dCkge1xyXG4gICAgY29uc3QgZGlyQXJncyA9IFtdO1xyXG4gICAgY29uc3QgcnVudGltZSA9IGRpcmVjdGl2ZUltcG9ydE1hcC5nZXQoZGlyKTtcclxuICAgIGlmIChydW50aW1lKSB7XHJcbiAgICAgICAgLy8gYnVpbHQtaW4gZGlyZWN0aXZlIHdpdGggcnVudGltZVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChjb250ZXh0LmhlbHBlclN0cmluZyhydW50aW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGluamVjdCBzdGF0ZW1lbnQgZm9yIHJlc29sdmluZyBkaXJlY3RpdmVcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXMuYWRkKGRpci5uYW1lKTtcclxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKHRvVmFsaWRBc3NldElkKGRpci5uYW1lLCBgZGlyZWN0aXZlYCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoZGlyLmV4cClcclxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmV4cCk7XHJcbiAgICBpZiAoZGlyLmFyZykge1xyXG4gICAgICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmFyZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycykubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFkaXIuYXJnKSB7XHJcbiAgICAgICAgICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cnVlRXhwcmVzc2lvbiA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcclxuICAgICAgICBkaXJBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkaXIubW9kaWZpZXJzLm1hcChtb2RpZmllciA9PiBjcmVhdGVPYmplY3RQcm9wZXJ0eShtb2RpZmllciwgdHJ1ZUV4cHJlc3Npb24pKSwgbG9jKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMocHJvcHMpIHtcclxuICAgIGxldCBwcm9wc05hbWVzU3RyaW5nID0gYFtgO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBwcm9wc05hbWVzU3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHByb3BzW2ldKTtcclxuICAgICAgICBpZiAoaSA8IGwgLSAxKVxyXG4gICAgICAgICAgICBwcm9wc05hbWVzU3RyaW5nICs9ICcsICc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHNOYW1lc1N0cmluZyArIGBdYDtcclxufVxuXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAoKHN0cikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xyXG59KTtcblxuY29uc3QgdHJhbnNmb3JtU2xvdE91dGxldCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAoaXNTbG90T3V0bGV0KG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHsgc2xvdE5hbWUsIHNsb3RQcm9wcyB9ID0gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3Qgc2xvdEFyZ3MgPSBbXHJcbiAgICAgICAgICAgIGNvbnRleHQucHJlZml4SWRlbnRpZmllcnMgPyBgX2N0eC4kc2xvdHNgIDogYCRzbG90c2AsXHJcbiAgICAgICAgICAgIHNsb3ROYW1lXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAoc2xvdFByb3BzKSB7XHJcbiAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goc2xvdFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChge31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbG90QXJncy5wdXNoKGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihbXSwgY2hpbGRyZW4sIGZhbHNlLCBmYWxzZSwgbG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRU5ERVJfU0xPVCksIHNsb3RBcmdzLCBsb2MpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgc2xvdE5hbWUgPSBgXCJkZWZhdWx0XCJgO1xyXG4gICAgbGV0IHNsb3RQcm9wcyA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IG5vbk5hbWVQcm9wcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICduYW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gSlNPTi5zdHJpbmdpZnkocC52YWx1ZS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAubmFtZSA9IGNhbWVsaXplKHAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBpc0JpbmRLZXkocC5hcmcsICduYW1lJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLmV4cClcclxuICAgICAgICAgICAgICAgICAgICBzbG90TmFtZSA9IHAuZXhwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmIHAuYXJnICYmIGlzU3RhdGljRXhwKHAuYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZShwLmFyZy5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5vbk5hbWVQcm9wcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgeyBwcm9wcywgZGlyZWN0aXZlcyB9ID0gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBub25OYW1lUHJvcHMpO1xyXG4gICAgICAgIHNsb3RQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNSAvKiBYX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVCAqLywgZGlyZWN0aXZlc1swXS5sb2MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNsb3ROYW1lLFxyXG4gICAgICAgIHNsb3RQcm9wc1xyXG4gICAgfTtcclxufVxuXG5jb25zdCBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XlxccypmdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcclxuY29uc3QgdHJhbnNmb3JtT24gPSAoZGlyLCBub2RlLCBjb250ZXh0LCBhdWdtZW50b3IpID0+IHtcclxuICAgIGNvbnN0IHsgbG9jLCBtb2RpZmllcnMsIGFyZyB9ID0gZGlyO1xyXG4gICAgaWYgKCFkaXIuZXhwICYmICFtb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzQgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgbGV0IGV2ZW50TmFtZTtcclxuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGlmIChhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmF3TmFtZSA9IGFyZy5jb250ZW50O1xyXG4gICAgICAgICAgICAvLyBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycywgYXV0byBjb252ZXJ0IGl0IHRvIGNhbWVsQ2FzZS4gU2VlIGlzc3VlICMyMjQ5XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24odG9IYW5kbGVyS2V5KGNhbWVsaXplJDEocmF3TmFtZSkpLCB0cnVlLCBhcmcubG9jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICMyMzg4XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgICAgICBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGAsXHJcbiAgICAgICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgICAgICBgKWBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSBhIGNvbXBvdW5kIGV4cHJlc3Npb24uXHJcbiAgICAgICAgZXZlbnROYW1lID0gYXJnO1xyXG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKFRPX0hBTkRMRVJfS0VZKX0oYCk7XHJcbiAgICAgICAgZXZlbnROYW1lLmNoaWxkcmVuLnB1c2goYClgKTtcclxuICAgIH1cclxuICAgIC8vIGhhbmRsZXIgcHJvY2Vzc2luZ1xyXG4gICAgbGV0IGV4cCA9IGRpci5leHA7XHJcbiAgICBpZiAoZXhwICYmICFleHAuY29udGVudC50cmltKCkpIHtcclxuICAgICAgICBleHAgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgc2hvdWxkQ2FjaGUgPSBjb250ZXh0LmNhY2hlSGFuZGxlcnMgJiYgIWV4cDtcclxuICAgIGlmIChleHApIHtcclxuICAgICAgICBjb25zdCBpc01lbWJlckV4cCA9IGlzTWVtYmVyRXhwcmVzc2lvbihleHAuY29udGVudCk7XHJcbiAgICAgICAgY29uc3QgaXNJbmxpbmVTdGF0ZW1lbnQgPSAhKGlzTWVtYmVyRXhwIHx8IGZuRXhwUkUudGVzdChleHAuY29udGVudCkpO1xyXG4gICAgICAgIGNvbnN0IGhhc011bHRpcGxlU3RhdGVtZW50cyA9IGV4cC5jb250ZW50LmluY2x1ZGVzKGA7YCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBmYWxzZSwgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzSW5saW5lU3RhdGVtZW50IHx8IChzaG91bGRDYWNoZSAmJiBpc01lbWJlckV4cCkpIHtcclxuICAgICAgICAgICAgLy8gd3JhcCBpbmxpbmUgc3RhdGVtZW50IGluIGEgZnVuY3Rpb24gZXhwcmVzc2lvblxyXG4gICAgICAgICAgICBleHAgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICAgICAgYCR7aXNJbmxpbmVTdGF0ZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICA/IGAkZXZlbnRgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtgYH0oLi4uYXJncylgfSA9PiAke2hhc011bHRpcGxlU3RhdGVtZW50cyA/IGB7YCA6IGAoYH1gLFxyXG4gICAgICAgICAgICAgICAgZXhwLFxyXG4gICAgICAgICAgICAgICAgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYH1gIDogYClgXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCByZXQgPSB7XHJcbiAgICAgICAgcHJvcHM6IFtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoZXZlbnROYW1lLCBleHAgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgKCkgPT4ge31gLCBmYWxzZSwgbG9jKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG4gICAgLy8gYXBwbHkgZXh0ZW5kZWQgY29tcGlsZXIgYXVnbWVudG9yXHJcbiAgICBpZiAoYXVnbWVudG9yKSB7XHJcbiAgICAgICAgcmV0ID0gYXVnbWVudG9yKHJldCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcclxuICAgICAgICAvLyBjYWNoZSBoYW5kbGVycyBzbyB0aGF0IGl0J3MgYWx3YXlzIHRoZSBzYW1lIGhhbmRsZXIgYmVpbmcgcGFzc2VkIGRvd24uXHJcbiAgICAgICAgLy8gdGhpcyBhdm9pZHMgdW5uZWNlc3NhcnkgcmUtcmVuZGVycyB3aGVuIHVzZXJzIHVzZSBpbmxpbmUgaGFuZGxlcnMgb25cclxuICAgICAgICAvLyBjb21wb25lbnRzLlxyXG4gICAgICAgIHJldC5wcm9wc1swXS52YWx1ZSA9IGNvbnRleHQuY2FjaGUocmV0LnByb3BzWzBdLnZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn07XG5cbi8vIHYtYmluZCB3aXRob3V0IGFyZyBpcyBoYW5kbGVkIGRpcmVjdGx5IGluIC4vdHJhbnNmb3JtRWxlbWVudHMudHMgZHVlIHRvIGl0IGFmZmVjdGluZ1xyXG4vLyBjb2RlZ2VuIGZvciB0aGUgZW50aXJlIHByb3BzIG9iamVjdC4gVGhpcyB0cmFuc2Zvcm0gaGVyZSBpcyBvbmx5IGZvciB2LWJpbmRcclxuLy8gKndpdGgqIGFyZ3MuXHJcbmNvbnN0IHRyYW5zZm9ybUJpbmQgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbW9kaWZpZXJzLCBsb2MgfSA9IGRpcjtcclxuICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XHJcbiAgICBpZiAoYXJnLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgKGApO1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApIHx8IFwiXCJgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICBhcmcuY29udGVudCA9IGAke2FyZy5jb250ZW50fSB8fCBcIlwiYDtcclxuICAgIH1cclxuICAgIC8vIC5wcm9wIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgZHVlIHRvIG5ldyBwYXRjaCBiZWhhdmlvclxyXG4gICAgLy8gLnN5bmMgaXMgcmVwbGFjZWQgYnkgdi1tb2RlbDphcmdcclxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2NhbWVsJykpIHtcclxuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZSQxKGFyZy5jb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfSgke2FyZy5jb250ZW50fSlgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KGApO1xyXG4gICAgICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZXhwIHx8XHJcbiAgICAgICAgKGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmICFleHAuY29udGVudC50cmltKCkpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzMgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUsIGxvYykpXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnLCBleHApXVxyXG4gICAgfTtcclxufTtcblxuLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBhbmQgZXhwcmVzc2lvbnMgaW50byBhIHNpbmdsZSBleHByZXNzaW9uXHJcbi8vIGUuZy4gPGRpdj5hYmMge3sgZCB9fSB7eyBlIH19PC9kaXY+IHNob3VsZCBoYXZlIGEgc2luZ2xlIGV4cHJlc3Npb24gbm9kZSBhcyBjaGlsZC5cclxuY29uc3QgdHJhbnNmb3JtVGV4dCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAwIC8qIFJPT1QgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMTEgLyogRk9SICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxMCAvKiBJRl9CUkFOQ0ggKi8pIHtcclxuICAgICAgICAvLyBwZXJmb3JtIHRoZSB0cmFuc2Zvcm0gb24gbm9kZSBleGl0IHNvIHRoYXQgYWxsIGV4cHJlc3Npb25zIGhhdmUgYWxyZWFkeVxyXG4gICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkLlxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNUZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1RleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGV4dChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IGNoaWxkcmVuW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogY2hpbGQubG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2NoaWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGUgaW50byBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLmNoaWxkcmVuLnB1c2goYCArIGAsIG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaGFzVGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSB0ZXh0IGNoaWxkLCBsZWF2ZSBpdFxyXG4gICAgICAgICAgICAgICAgLy8gYXMtaXMgc2luY2UgdGhlIHJ1bnRpbWUgaGFzIGRlZGljYXRlZCBmYXN0IHBhdGggZm9yIHRoaXMgYnkgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tcG9uZW50IHJvb3QgaXQncyBhbHdheXMgbm9ybWFsaXplZCBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMCAvKiBST09UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8pKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcmUtY29udmVydCB0ZXh0IG5vZGVzIGludG8gY3JlYXRlVGV4dFZOb2RlKHRleHQpIGNhbGxzIHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUgbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RleHQoY2hpbGQpIHx8IGNoaWxkLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxBcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlVGV4dFZOb2RlIGRlZmF1bHRzIHRvIHNpbmdsZSB3aGl0ZXNwYWNlLCBzbyBpZiBpdCBpcyBhXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIHNwYWNlIHRoZSBjb2RlIGNvdWxkIGJlIGFuIGVtcHR5IGNhbGwgdG8gc2F2ZSBieXRlcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gMiAvKiBURVhUICovIHx8IGNoaWxkLmNvbnRlbnQgIT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayBkeW5hbWljIHRleHQgd2l0aCBmbGFnIHNvIGl0IGdldHMgcGF0Y2hlZCBpbnNpZGUgYSBibG9ja1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3MucHVzaCgxIC8qIFRFWFQgKi8gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1sxIC8qIFRFWFQgKi9dfSAqL2AgOiBgYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTIgLyogVEVYVF9DQUxMICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjaGlsZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBjaGlsZC5sb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlOiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfVEVYVCksIGNhbGxBcmdzKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCBzZWVuID0gbmV3IFdlYWtTZXQoKTtcclxuY29uc3QgdHJhbnNmb3JtT25jZSA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiYgZmluZERpcihub2RlLCAnb25jZScsIHRydWUpKSB7XHJcbiAgICAgICAgaWYgKHNlZW4uaGFzKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Vlbi5hZGQobm9kZSk7XHJcbiAgICAgICAgY29udGV4dC5oZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXIgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICBpZiAoY3VyLmNvZGVnZW5Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXIuY29kZWdlbk5vZGUgPSBjb250ZXh0LmNhY2hlKGN1ci5jb2RlZ2VuTm9kZSwgdHJ1ZSAvKiBpc1ZOb2RlICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybU1vZGVsID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIGFyZyB9ID0gZGlyO1xyXG4gICAgaWYgKCFleHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MCAvKiBYX1ZfTU9ERUxfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3RXhwID0gZXhwLmxvYy5zb3VyY2U7XHJcbiAgICBjb25zdCBleHBTdHJpbmcgPSBleHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyA/IGV4cC5jb250ZW50IDogcmF3RXhwO1xyXG4gICAgLy8gaW0gU0ZDIDxzY3JpcHQgc2V0dXA+IGlubGluZSBtb2RlLCB0aGUgZXhwIG1heSBoYXZlIGJlZW4gdHJhbnNmb3JtZWQgaW50b1xyXG4gICAgLy8gX3VucmVmKGV4cClcclxuICAgIGNvbnRleHQuYmluZGluZ01ldGFkYXRhW3Jhd0V4cF07XHJcbiAgICBjb25zdCBtYXliZVJlZiA9ICF0cnVlICAgIC8qIFNFVFVQX0NPTlNUICovO1xyXG4gICAgaWYgKCFpc01lbWJlckV4cHJlc3Npb24oZXhwU3RyaW5nKSAmJiAhbWF5YmVSZWYpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MSAvKiBYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIGV4cC5sb2MpKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BOYW1lID0gYXJnID8gYXJnIDogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignbW9kZWxWYWx1ZScsIHRydWUpO1xyXG4gICAgY29uc3QgZXZlbnROYW1lID0gYXJnXHJcbiAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXHJcbiAgICAgICAgICAgID8gYG9uVXBkYXRlOiR7YXJnLmNvbnRlbnR9YFxyXG4gICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbJ1wib25VcGRhdGU6XCIgKyAnLCBhcmddKVxyXG4gICAgICAgIDogYG9uVXBkYXRlOm1vZGVsVmFsdWVgO1xyXG4gICAgbGV0IGFzc2lnbm1lbnRFeHA7XHJcbiAgICBjb25zdCBldmVudEFyZyA9IGNvbnRleHQuaXNUUyA/IGAoJGV2ZW50OiBhbnkpYCA6IGAkZXZlbnRgO1xyXG4gICAge1xyXG4gICAgICAgIGFzc2lnbm1lbnRFeHAgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xyXG4gICAgICAgICAgICBgJHtldmVudEFyZ30gPT4gKGAsXHJcbiAgICAgICAgICAgIGV4cCxcclxuICAgICAgICAgICAgYCA9ICRldmVudClgXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wcyA9IFtcclxuICAgICAgICAvLyBtb2RlbFZhbHVlOiBmb29cclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShwcm9wTmFtZSwgZGlyLmV4cCksXHJcbiAgICAgICAgLy8gXCJvblVwZGF0ZTptb2RlbFZhbHVlXCI6ICRldmVudCA9PiAoZm9vID0gJGV2ZW50KVxyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgYXNzaWdubWVudEV4cClcclxuICAgIF07XHJcbiAgICAvLyBtb2RlbE1vZGlmaWVyczogeyBmb286IHRydWUsIFwiYmFyLWJhelwiOiB0cnVlIH1cclxuICAgIGlmIChkaXIubW9kaWZpZXJzLmxlbmd0aCAmJiBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVyc1xyXG4gICAgICAgICAgICAubWFwKG0gPT4gKGlzU2ltcGxlSWRlbnRpZmllcihtKSA/IG0gOiBKU09OLnN0cmluZ2lmeShtKSkgKyBgOiB0cnVlYClcclxuICAgICAgICAgICAgLmpvaW4oYCwgYCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYXJnXHJcbiAgICAgICAgICAgID8gaXNTdGF0aWNFeHAoYXJnKVxyXG4gICAgICAgICAgICAgICAgPyBgJHthcmcuY29udGVudH1Nb2RpZmllcnNgXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYXJnLCAnICsgXCJNb2RpZmllcnNcIiddKVxyXG4gICAgICAgICAgICA6IGBtb2RlbE1vZGlmaWVyc2A7XHJcbiAgICAgICAgcHJvcHMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShtb2RpZmllcnNLZXksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHsgJHttb2RpZmllcnN9IH1gLCBmYWxzZSwgZGlyLmxvYywgMiAvKiBDQU5fSE9JU1QgKi8pKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcyhwcm9wcyA9IFtdKSB7XHJcbiAgICByZXR1cm4geyBwcm9wcyB9O1xyXG59XG5cbmZ1bmN0aW9uIGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQocHJlZml4SWRlbnRpZmllcnMpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PbmNlLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1JZixcclxuICAgICAgICAgICAgdHJhbnNmb3JtRm9yLFxyXG4gICAgICAgICAgICAuLi4oKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBbdHJhbnNmb3JtRXhwcmVzc2lvbl1cclxuICAgICAgICAgICAgICAgICAgICA6IFtdKSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtU2xvdE91dGxldCxcclxuICAgICAgICAgICAgdHJhbnNmb3JtRWxlbWVudCxcclxuICAgICAgICAgICAgdHJhY2tTbG90U2NvcGVzLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1UZXh0XHJcbiAgICAgICAgXSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9uOiB0cmFuc2Zvcm1PbixcclxuICAgICAgICAgICAgYmluZDogdHJhbnNmb3JtQmluZCxcclxuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsXHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxufVxyXG4vLyB3ZSBuYW1lIGl0IGBiYXNlQ29tcGlsZWAgc28gdGhhdCBoaWdoZXIgb3JkZXIgY29tcGlsZXJzIGxpa2VcclxuLy8gQHZ1ZS9jb21waWxlci1kb20gY2FuIGV4cG9ydCBgY29tcGlsZWAgd2hpbGUgcmUtZXhwb3J0aW5nIGV2ZXJ5dGhpbmcgZWxzZS5cclxuZnVuY3Rpb24gYmFzZUNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3Qgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcclxuICAgIGNvbnN0IGlzTW9kdWxlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ21vZHVsZSc7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5wcmVmaXhJZGVudGlmaWVycyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDUgLyogWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc01vZHVsZU1vZGUpIHtcclxuICAgICAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ2IC8qIFhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHByZWZpeElkZW50aWZpZXJzID0gIXRydWUgO1xyXG4gICAgaWYgKG9wdGlvbnMuY2FjaGVIYW5kbGVycykge1xyXG4gICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NyAvKiBYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc2NvcGVJZCAmJiAhaXNNb2R1bGVNb2RlKSB7XHJcbiAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ4IC8qIFhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXN0ID0gaXNTdHJpbmcodGVtcGxhdGUpID8gYmFzZVBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSA6IHRlbXBsYXRlO1xyXG4gICAgY29uc3QgW25vZGVUcmFuc2Zvcm1zLCBkaXJlY3RpdmVUcmFuc2Zvcm1zXSA9IGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQoKTtcclxuICAgIHRyYW5zZm9ybShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXHJcbiAgICAgICAgICAgIC4uLm5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSkgLy8gdXNlciB0cmFuc2Zvcm1zXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoe30sIGRpcmVjdGl2ZVRyYW5zZm9ybXMsIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fSAvLyB1c2VyIHRyYW5zZm9ybXNcclxuICAgICAgICApXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGUoYXN0LCBleHRlbmQoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVyc1xyXG4gICAgfSkpO1xyXG59XG5cbmNvbnN0IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0gPSAoKSA9PiAoeyBwcm9wczogW10gfSk7XG5cbmV4cG9ydCB7IEJBU0VfVFJBTlNJVElPTiwgQ0FNRUxJWkUsIENBUElUQUxJWkUsIENSRUFURV9CTE9DSywgQ1JFQVRFX0NPTU1FTlQsIENSRUFURV9TTE9UUywgQ1JFQVRFX1NUQVRJQywgQ1JFQVRFX1RFWFQsIENSRUFURV9WTk9ERSwgRlJBR01FTlQsIElTX1JFRiwgS0VFUF9BTElWRSwgTUVSR0VfUFJPUFMsIE9QRU5fQkxPQ0ssIFBPUF9TQ09QRV9JRCwgUFVTSF9TQ09QRV9JRCwgUkVOREVSX0xJU1QsIFJFTkRFUl9TTE9ULCBSRVNPTFZFX0NPTVBPTkVOVCwgUkVTT0xWRV9ESVJFQ1RJVkUsIFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQsIFNFVF9CTE9DS19UUkFDS0lORywgU1VTUEVOU0UsIFRFTEVQT1JULCBUT19ESVNQTEFZX1NUUklORywgVE9fSEFORExFUlMsIFRPX0hBTkRMRVJfS0VZLCBVTlJFRiwgV0lUSF9DVFgsIFdJVEhfRElSRUNUSVZFUywgV0lUSF9TQ09QRV9JRCwgYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lLCBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24sIGFzc2VydCwgYmFzZUNvbXBpbGUsIGJhc2VQYXJzZSwgYnVpbGRQcm9wcywgYnVpbGRTbG90cywgY3JlYXRlQXJyYXlFeHByZXNzaW9uLCBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbiwgY3JlYXRlQmxvY2tTdGF0ZW1lbnQsIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbiwgY3JlYXRlQ2FsbEV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uLCBjcmVhdGVGb3JMb29wUGFyYW1zLCBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24sIGNyZWF0ZUlmU3RhdGVtZW50LCBjcmVhdGVJbnRlcnBvbGF0aW9uLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uLCBjcmVhdGVPYmplY3RQcm9wZXJ0eSwgY3JlYXRlUmV0dXJuU3RhdGVtZW50LCBjcmVhdGVSb290LCBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24sIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0sIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbCwgY3JlYXRlVHJhbnNmb3JtQ29udGV4dCwgY3JlYXRlVk5vZGVDYWxsLCBmaW5kRGlyLCBmaW5kUHJvcCwgZ2VuZXJhdGUsIGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQsIGdldElubmVyUmFuZ2UsIGhhc0R5bmFtaWNLZXlWQmluZCwgaGFzU2NvcGVSZWYsIGhlbHBlck5hbWVNYXAsIGluamVjdFByb3AsIGlzQmluZEtleSwgaXNCdWlsdEluVHlwZSwgaXNDb3JlQ29tcG9uZW50LCBpc01lbWJlckV4cHJlc3Npb24sIGlzU2ltcGxlSWRlbnRpZmllciwgaXNTbG90T3V0bGV0LCBpc1N0YXRpY0V4cCwgaXNUZW1wbGF0ZU5vZGUsIGlzVGV4dCwgaXNWU2xvdCwgbG9jU3R1Yiwgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgcHJvY2Vzc0V4cHJlc3Npb24sIHByb2Nlc3NGb3IsIHByb2Nlc3NJZiwgcHJvY2Vzc1Nsb3RPdXRsZXQsIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIHJlc29sdmVDb21wb25lbnRUeXBlLCB0b1ZhbGlkQXNzZXRJZCwgdHJhY2tTbG90U2NvcGVzLCB0cmFja1ZGb3JTbG90U2NvcGVzLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybUJpbmQsIHRyYW5zZm9ybUVsZW1lbnQsIHRyYW5zZm9ybUV4cHJlc3Npb24sIHRyYW5zZm9ybU1vZGVsLCB0cmFuc2Zvcm1PbiwgdHJhdmVyc2VOb2RlIH07XG4iLCJpbXBvcnQgeyByZWdpc3RlclJ1bnRpbWVIZWxwZXJzLCBpc0J1aWx0SW5UeXBlLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uLCBjcmVhdGVDb21waWxlckVycm9yLCBjcmVhdGVPYmplY3RQcm9wZXJ0eSwgY3JlYXRlQ2FsbEV4cHJlc3Npb24sIFRPX0RJU1BMQVlfU1RSSU5HLCB0cmFuc2Zvcm1Nb2RlbCBhcyB0cmFuc2Zvcm1Nb2RlbCQxLCBmaW5kUHJvcCwgaGFzRHluYW1pY0tleVZCaW5kLCB0cmFuc2Zvcm1PbiBhcyB0cmFuc2Zvcm1PbiQxLCBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24sIGlzU3RhdGljRXhwLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5pbXBvcnQgeyBpc1ZvaWRUYWcsIGlzSFRNTFRhZywgaXNTVkdUYWcsIG1ha2VNYXAsIHBhcnNlU3RyaW5nU3R5bGUsIGNhcGl0YWxpemUsIGV4dGVuZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3QgVl9NT0RFTF9SQURJTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsUmFkaW9gIDogYGApO1xyXG5jb25zdCBWX01PREVMX0NIRUNLQk9YID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxDaGVja2JveGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfVEVYVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsVGV4dGAgOiBgYCk7XHJcbmNvbnN0IFZfTU9ERUxfU0VMRUNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxTZWxlY3RgIDogYGApO1xyXG5jb25zdCBWX01PREVMX0RZTkFNSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbER5bmFtaWNgIDogYGApO1xyXG5jb25zdCBWX09OX1dJVEhfTU9ESUZJRVJTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25Nb2RpZmllcnNHdWFyZGAgOiBgYCk7XHJcbmNvbnN0IFZfT05fV0lUSF9LRVlTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25LZXlzR3VhcmRgIDogYGApO1xyXG5jb25zdCBWX1NIT1cgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZTaG93YCA6IGBgKTtcclxuY29uc3QgVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT05fR1JPVVAgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25Hcm91cGAgOiBgYCk7XHJcbnJlZ2lzdGVyUnVudGltZUhlbHBlcnMoe1xyXG4gICAgW1ZfTU9ERUxfUkFESU9dOiBgdk1vZGVsUmFkaW9gLFxyXG4gICAgW1ZfTU9ERUxfQ0hFQ0tCT1hdOiBgdk1vZGVsQ2hlY2tib3hgLFxyXG4gICAgW1ZfTU9ERUxfVEVYVF06IGB2TW9kZWxUZXh0YCxcclxuICAgIFtWX01PREVMX1NFTEVDVF06IGB2TW9kZWxTZWxlY3RgLFxyXG4gICAgW1ZfTU9ERUxfRFlOQU1JQ106IGB2TW9kZWxEeW5hbWljYCxcclxuICAgIFtWX09OX1dJVEhfTU9ESUZJRVJTXTogYHdpdGhNb2RpZmllcnNgLFxyXG4gICAgW1ZfT05fV0lUSF9LRVlTXTogYHdpdGhLZXlzYCxcclxuICAgIFtWX1NIT1ddOiBgdlNob3dgLFxyXG4gICAgW1RSQU5TSVRJT05dOiBgVHJhbnNpdGlvbmAsXHJcbiAgICBbVFJBTlNJVElPTl9HUk9VUF06IGBUcmFuc2l0aW9uR3JvdXBgXHJcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGRlY29kZXI7XHJcbmZ1bmN0aW9uIGRlY29kZUh0bWxCcm93c2VyKHJhdykge1xyXG4gICAgKGRlY29kZXIgfHwgKGRlY29kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkpLmlubmVySFRNTCA9IHJhdztcclxuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50O1xyXG59XG5cbmNvbnN0IGlzUmF3VGV4dENvbnRhaW5lciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc3R5bGUsaWZyYW1lLHNjcmlwdCxub3NjcmlwdCcsIHRydWUpO1xyXG5jb25zdCBwYXJzZXJPcHRpb25zID0ge1xyXG4gICAgaXNWb2lkVGFnLFxyXG4gICAgaXNOYXRpdmVUYWc6IHRhZyA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxyXG4gICAgaXNQcmVUYWc6IHRhZyA9PiB0YWcgPT09ICdwcmUnLFxyXG4gICAgZGVjb2RlRW50aXRpZXM6IGRlY29kZUh0bWxCcm93c2VyICxcclxuICAgIGlzQnVpbHRJbkNvbXBvbmVudDogKHRhZykgPT4ge1xyXG4gICAgICAgIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgYFRyYW5zaXRpb25gKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVFJBTlNJVElPTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsIGBUcmFuc2l0aW9uR3JvdXBgKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVFJBTlNJVElPTl9HUk9VUDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RyZWUtY29uc3RydWN0aW9uLWRpc3BhdGNoZXJcclxuICAgIGdldE5hbWVzcGFjZSh0YWcsIHBhcmVudCkge1xyXG4gICAgICAgIGxldCBucyA9IHBhcmVudCA/IHBhcmVudC5ucyA6IDAgLyogSFRNTCAqLztcclxuICAgICAgICBpZiAocGFyZW50ICYmIG5zID09PSAyIC8qIE1BVEhfTUwgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC50YWcgPT09ICdhbm5vdGF0aW9uLXhtbCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU1ZHICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wcm9wcy5zb21lKGEgPT4gYS50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGEubmFtZSA9PT0gJ2VuY29kaW5nJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGEudmFsdWUgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChhLnZhbHVlLmNvbnRlbnQgPT09ICd0ZXh0L2h0bWwnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEudmFsdWUuY29udGVudCA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKC9ebSg/Oltpb25zXXx0ZXh0KSQvLnRlc3QocGFyZW50LnRhZykgJiZcclxuICAgICAgICAgICAgICAgIHRhZyAhPT0gJ21nbHlwaCcgJiZcclxuICAgICAgICAgICAgICAgIHRhZyAhPT0gJ21hbGlnbm1hcmsnKSB7XHJcbiAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJlbnQgJiYgbnMgPT09IDEgLyogU1ZHICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQudGFnID09PSAnZm9yZWlnbk9iamVjdCcgfHxcclxuICAgICAgICAgICAgICAgIHBhcmVudC50YWcgPT09ICdkZXNjJyB8fFxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnRhZyA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5zID09PSAwIC8qIEhUTUwgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNWRyAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIE1BVEhfTUwgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5zO1xyXG4gICAgfSxcclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNwYXJzaW5nLWh0bWwtZnJhZ21lbnRzXHJcbiAgICBnZXRUZXh0TW9kZSh7IHRhZywgbnMgfSkge1xyXG4gICAgICAgIGlmIChucyA9PT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICd0ZXh0YXJlYScgfHwgdGFnID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBSQ0RBVEEgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzUmF3VGV4dENvbnRhaW5lcih0YWcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBSQVdURVhUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwIC8qIERBVEEgKi87XHJcbiAgICB9XHJcbn07XG5cbi8vIFBhcnNlIGlubGluZSBDU1Mgc3RyaW5ncyBmb3Igc3RhdGljIHN0eWxlIGF0dHJpYnV0ZXMgaW50byBhbiBvYmplY3QuXHJcbi8vIFRoaXMgaXMgYSBOb2RlVHJhbnNmb3JtIHNpbmNlIGl0IHdvcmtzIG9uIHRoZSBzdGF0aWMgYHN0eWxlYCBhdHRyaWJ1dGUgYW5kXHJcbi8vIGNvbnZlcnRzIGl0IGludG8gYSBkeW5hbWljIGVxdWl2YWxlbnQ6XHJcbi8vIHN0eWxlPVwiY29sb3I6IHJlZFwiIC0+IDpzdHlsZT0neyBcImNvbG9yXCI6IFwicmVkXCIgfSdcclxuLy8gSXQgaXMgdGhlbiBwcm9jZXNzZWQgYnkgYHRyYW5zZm9ybUVsZW1lbnRgIGFuZCBpbmNsdWRlZCBpbiB0aGUgZ2VuZXJhdGVkXHJcbi8vIHByb3BzLlxyXG5jb25zdCB0cmFuc2Zvcm1TdHlsZSA9IG5vZGUgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgbm9kZS5wcm9wcy5mb3JFYWNoKChwLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovICYmIHAubmFtZSA9PT0gJ3N0eWxlJyAmJiBwLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHAgd2l0aCBhbiBleHByZXNzaW9uIG5vZGVcclxuICAgICAgICAgICAgICAgIG5vZGUucHJvcHNbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBESVJFQ1RJVkUgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYGJpbmRgLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZzogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgc3R5bGVgLCB0cnVlLCBwLmxvYyksXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwOiBwYXJzZUlubGluZUNTUyhwLnZhbHVlLmNvbnRlbnQsIHAubG9jKSxcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvYzogcC5sb2NcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuY29uc3QgcGFyc2VJbmxpbmVDU1MgPSAoY3NzVGV4dCwgbG9jKSA9PiB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KTtcclxuICAgIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWQpLCBmYWxzZSwgbG9jLCAzIC8qIENBTl9TVFJJTkdJRlkgKi8pO1xyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVET01Db21waWxlckVycm9yKGNvZGUsIGxvYykge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUgPyBET01FcnJvck1lc3NhZ2VzIDogdW5kZWZpbmVkKTtcclxufVxyXG5jb25zdCBET01FcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgWzQ5IC8qIFhfVl9IVE1MX05PX0VYUFJFU1NJT04gKi9dOiBgdi1odG1sIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzUwIC8qIFhfVl9IVE1MX1dJVEhfQ0hJTERSRU4gKi9dOiBgdi1odG1sIHdpbGwgb3ZlcnJpZGUgZWxlbWVudCBjaGlsZHJlbi5gLFxyXG4gICAgWzUxIC8qIFhfVl9URVhUX05PX0VYUFJFU1NJT04gKi9dOiBgdi10ZXh0IGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzUyIC8qIFhfVl9URVhUX1dJVEhfQ0hJTERSRU4gKi9dOiBgdi10ZXh0IHdpbGwgb3ZlcnJpZGUgZWxlbWVudCBjaGlsZHJlbi5gLFxyXG4gICAgWzUzIC8qIFhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBjYW4gb25seSBiZSB1c2VkIG9uIDxpbnB1dD4sIDx0ZXh0YXJlYT4gYW5kIDxzZWxlY3Q+IGVsZW1lbnRzLmAsXHJcbiAgICBbNTQgLyogWF9WX01PREVMX0FSR19PTl9FTEVNRU5UICovXTogYHYtbW9kZWwgYXJndW1lbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBwbGFpbiBlbGVtZW50cy5gLFxyXG4gICAgWzU1IC8qIFhfVl9NT0RFTF9PTl9GSUxFX0lOUFVUX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiBmaWxlIGlucHV0cyBzaW5jZSB0aGV5IGFyZSByZWFkLW9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuYCxcclxuICAgIFs1NiAvKiBYX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUUgKi9dOiBgVW5uZWNlc3NhcnkgdmFsdWUgYmluZGluZyB1c2VkIGFsb25nc2lkZSB2LW1vZGVsLiBJdCB3aWxsIGludGVyZmVyZSB3aXRoIHYtbW9kZWwncyBiZWhhdmlvci5gLFxyXG4gICAgWzU3IC8qIFhfVl9TSE9XX05PX0VYUFJFU1NJT04gKi9dOiBgdi1zaG93IGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzU4IC8qIFhfVFJBTlNJVElPTl9JTlZBTElEX0NISUxEUkVOICovXTogYDxUcmFuc2l0aW9uPiBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQgb3IgY29tcG9uZW50LmAsXHJcbiAgICBbNTkgLyogWF9JR05PUkVEX1NJREVfRUZGRUNUX1RBRyAqL106IGBUYWdzIHdpdGggc2lkZSBlZmZlY3QgKDxzY3JpcHQ+IGFuZCA8c3R5bGU+KSBhcmUgaWdub3JlZCBpbiBjbGllbnQgY29tcG9uZW50IHRlbXBsYXRlcy5gXHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVZIdG1sID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xyXG4gICAgaWYgKCFleHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig0OSAvKiBYX1ZfSFRNTF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUwIC8qIFhfVl9IVE1MX1dJVEhfQ0hJTERSRU4gKi8sIGxvYykpO1xyXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgaW5uZXJIVE1MYCwgdHJ1ZSwgbG9jKSwgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUpKVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVZUZXh0ID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xyXG4gICAgaWYgKCFleHApIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MSAvKiBYX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUyIC8qIFhfVl9URVhUX1dJVEhfQ0hJTERSRU4gKi8sIGxvYykpO1xyXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IFtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdGV4dENvbnRlbnRgLCB0cnVlKSwgZXhwXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyU3RyaW5nKFRPX0RJU1BMQVlfU1RSSU5HKSwgW2V4cF0sIGxvYylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSkpXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCBiYXNlUmVzdWx0ID0gdHJhbnNmb3JtTW9kZWwkMShkaXIsIG5vZGUsIGNvbnRleHQpO1xyXG4gICAgLy8gYmFzZSB0cmFuc2Zvcm0gaGFzIGVycm9ycyBPUiBjb21wb25lbnQgdi1tb2RlbCAob25seSBuZWVkIHByb3BzKVxyXG4gICAgaWYgKCFiYXNlUmVzdWx0LnByb3BzLmxlbmd0aCB8fCBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLmFyZykge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU0IC8qIFhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVCAqLywgZGlyLmFyZy5sb2MpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlZFZhbHVlKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmluZFByb3Aobm9kZSwgJ3ZhbHVlJyk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU2IC8qIFhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRSAqLywgdmFsdWUubG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0YWcgfSA9IG5vZGU7XHJcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBjb250ZXh0LmlzQ3VzdG9tRWxlbWVudCh0YWcpO1xyXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fFxyXG4gICAgICAgIHRhZyA9PT0gJ3RleHRhcmVhJyB8fFxyXG4gICAgICAgIHRhZyA9PT0gJ3NlbGVjdCcgfHxcclxuICAgICAgICBpc0N1c3RvbUVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1RFWFQ7XHJcbiAgICAgICAgbGV0IGlzSW52YWxpZFR5cGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8IGlzQ3VzdG9tRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZmluZFByb3Aobm9kZSwgYHR5cGVgKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gOnR5cGU9XCJmb29cIlxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZS52YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9SQURJTztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfQ0hFQ0tCT1g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmlsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWRUeXBlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU1IC8qIFhfVl9NT0RFTF9PTl9GSUxFX0lOUFVUX0VMRU1FTlQgKi8sIGRpci5sb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNEeW5hbWljS2V5VkJpbmQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaGFzIGJpbmRpbmdzIHdpdGggZHluYW1pYyBrZXlzLCB3aGljaCBjYW4gcG9zc2libHkgY29udGFpblxyXG4gICAgICAgICAgICAgICAgLy8gXCJ0eXBlXCIuXHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRleHQgdHlwZVxyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfU0VMRUNUO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGV4dGFyZWFcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCBydW50aW1lIGRpcmVjdGl2ZVxyXG4gICAgICAgIC8vIGJ5IHJldHVybmluZyB0aGUgaGVscGVyIHN5bWJvbCB2aWEgbmVlZFJ1bnRpbWVcclxuICAgICAgICAvLyB0aGUgaW1wb3J0IHdpbGwgcmVwbGFjZWQgYSByZXNvbHZlRGlyZWN0aXZlIGNhbGwuXHJcbiAgICAgICAgaWYgKCFpc0ludmFsaWRUeXBlKSB7XHJcbiAgICAgICAgICAgIGJhc2VSZXN1bHQubmVlZFJ1bnRpbWUgPSBjb250ZXh0LmhlbHBlcihkaXJlY3RpdmVUb1VzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTMgLyogWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xyXG4gICAgfVxyXG4gICAgLy8gbmF0aXZlIHZtb2RlbCBkb2Vzbid0IG5lZWQgdGhlIGBtb2RlbFZhbHVlYCBwcm9wcyBzaW5jZSB0aGV5IGFyZSBhbHNvXHJcbiAgICAvLyBwYXNzZWQgdG8gdGhlIHJ1bnRpbWUgYXMgYGJpbmRpbmcudmFsdWVgLiByZW1vdmluZyBpdCByZWR1Y2VzIGNvZGUgc2l6ZS5cclxuICAgIGJhc2VSZXN1bHQucHJvcHMgPSBiYXNlUmVzdWx0LnByb3BzLmZpbHRlcihwID0+ICEocC5rZXkudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJlxyXG4gICAgICAgIHAua2V5LmNvbnRlbnQgPT09ICdtb2RlbFZhbHVlJykpO1xyXG4gICAgcmV0dXJuIGJhc2VSZXN1bHQ7XHJcbn07XG5cbmNvbnN0IGlzRXZlbnRPcHRpb25Nb2RpZmllciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgcGFzc2l2ZSxvbmNlLGNhcHR1cmVgKTtcclxuY29uc3QgaXNOb25LZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcclxuLy8gZXZlbnQgcHJvcGFnYXRpb24gbWFuYWdlbWVudFxyXG5gc3RvcCxwcmV2ZW50LHNlbGYsYCArXHJcbiAgICAvLyBzeXN0ZW0gbW9kaWZpZXJzICsgZXhhY3RcclxuICAgIGBjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0LGAgK1xyXG4gICAgLy8gbW91c2VcclxuICAgIGBtaWRkbGVgKTtcclxuLy8gbGVmdCAmIHJpZ2h0IGNvdWxkIGJlIG1vdXNlIG9yIGtleSBtb2RpZmllcnMgYmFzZWQgb24gZXZlbnQgdHlwZVxyXG5jb25zdCBtYXliZUtleU1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdsZWZ0LHJpZ2h0Jyk7XHJcbmNvbnN0IGlzS2V5Ym9hcmRFdmVudCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgb25rZXl1cCxvbmtleWRvd24sb25rZXlwcmVzc2AsIHRydWUpO1xyXG5jb25zdCByZXNvbHZlTW9kaWZpZXJzID0gKGtleSwgbW9kaWZpZXJzKSA9PiB7XHJcbiAgICBjb25zdCBrZXlNb2RpZmllcnMgPSBbXTtcclxuICAgIGNvbnN0IG5vbktleU1vZGlmaWVycyA9IFtdO1xyXG4gICAgY29uc3QgZXZlbnRPcHRpb25Nb2RpZmllcnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBtb2RpZmllcnNbaV07XHJcbiAgICAgICAgaWYgKGlzRXZlbnRPcHRpb25Nb2RpZmllcihtb2RpZmllcikpIHtcclxuICAgICAgICAgICAgLy8gZXZlbnRPcHRpb25Nb2RpZmllcnM6IG1vZGlmaWVycyBmb3IgYWRkRXZlbnRMaXN0ZW5lcigpIG9wdGlvbnMsXHJcbiAgICAgICAgICAgIC8vIGUuZy4gLnBhc3NpdmUgJiAuY2FwdHVyZVxyXG4gICAgICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWVNb2RpZmllcnM6IG1vZGlmaWVycyB0aGF0IG5lZWRzIHJ1bnRpbWUgZ3VhcmRzXHJcbiAgICAgICAgICAgIGlmIChtYXliZUtleU1vZGlmaWVyKG1vZGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RhdGljRXhwKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc05vbktleU1vZGlmaWVyKG1vZGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAga2V5TW9kaWZpZXJzLFxyXG4gICAgICAgIG5vbktleU1vZGlmaWVycyxcclxuICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVyc1xyXG4gICAgfTtcclxufTtcclxuY29uc3QgdHJhbnNmb3JtQ2xpY2sgPSAoa2V5LCBldmVudCkgPT4ge1xyXG4gICAgY29uc3QgaXNTdGF0aWNDbGljayA9IGlzU3RhdGljRXhwKGtleSkgJiYga2V5LmNvbnRlbnQudG9Mb3dlckNhc2UoKSA9PT0gJ29uY2xpY2snO1xyXG4gICAgcmV0dXJuIGlzU3RhdGljQ2xpY2tcclxuICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oZXZlbnQsIHRydWUpXHJcbiAgICAgICAgOiBrZXkudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqL1xyXG4gICAgICAgICAgICA/IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgICAgICBgKGAsXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBgKSA9PT0gXCJvbkNsaWNrXCIgPyBcIiR7ZXZlbnR9XCIgOiAoYCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGApYFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICA6IGtleTtcclxufTtcclxuY29uc3QgdHJhbnNmb3JtT24gPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtT24kMShkaXIsIG5vZGUsIGNvbnRleHQsIGJhc2VSZXN1bHQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgbW9kaWZpZXJzIH0gPSBkaXI7XHJcbiAgICAgICAgaWYgKCFtb2RpZmllcnMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxuICAgICAgICBsZXQgeyBrZXksIHZhbHVlOiBoYW5kbGVyRXhwIH0gPSBiYXNlUmVzdWx0LnByb3BzWzBdO1xyXG4gICAgICAgIGNvbnN0IHsga2V5TW9kaWZpZXJzLCBub25LZXlNb2RpZmllcnMsIGV2ZW50T3B0aW9uTW9kaWZpZXJzIH0gPSByZXNvbHZlTW9kaWZpZXJzKGtleSwgbW9kaWZpZXJzKTtcclxuICAgICAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdyaWdodCcpKSB7XHJcbiAgICAgICAgICAgIGtleSA9IHRyYW5zZm9ybUNsaWNrKGtleSwgYG9uQ29udGV4dG1lbnVgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5pbmNsdWRlcygnbWlkZGxlJykpIHtcclxuICAgICAgICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Nb3VzZXVwYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfTU9ESUZJRVJTKSwgW1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlckV4cCxcclxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5vbktleU1vZGlmaWVycylcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIC8vIGlmIGV2ZW50IG5hbWUgaXMgZHluYW1pYywgYWx3YXlzIHdyYXAgd2l0aCBrZXlzIGd1YXJkXHJcbiAgICAgICAgICAgICghaXNTdGF0aWNFeHAoa2V5KSB8fCBpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQpKSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX0tFWVMpLCBbXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyRXhwLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoa2V5TW9kaWZpZXJzKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50T3B0aW9uTW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllclBvc3RmaXggPSBldmVudE9wdGlvbk1vZGlmaWVycy5tYXAoY2FwaXRhbGl6ZSkuam9pbignJyk7XHJcbiAgICAgICAgICAgIGtleSA9IGlzU3RhdGljRXhwKGtleSlcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXkuY29udGVudH0ke21vZGlmaWVyUG9zdGZpeH1gLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2AoYCwga2V5LCBgKSArIFwiJHttb2RpZmllclBvc3RmaXh9XCJgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoa2V5LCBoYW5kbGVyRXhwKV1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVNob3cgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU3IC8qIFhfVl9TSE9XX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW10sXHJcbiAgICAgICAgbmVlZFJ1bnRpbWU6IGNvbnRleHQuaGVscGVyKFZfU0hPVylcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHdhcm5UcmFuc2l0aW9uQ2hpbGRyZW4gPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbnRleHQuaXNCdWlsdEluQ29tcG9uZW50KG5vZGUudGFnKTtcclxuICAgICAgICBpZiAoY29tcG9uZW50ID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgaGFzTXVsdGlwbGVDaGlsZHJlbihub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU4IC8qIFhfVFJBTlNJVElPTl9JTlZBTElEX0NISUxEUkVOICovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkge1xyXG4gICAgLy8gIzEzNTIgZmlsdGVyIG91dCBwb3RlbnRpYWwgY29tbWVudCBub2Rlcy5cclxuICAgIGNvbnN0IGNoaWxkcmVuID0gKG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKSk7XHJcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgcmV0dXJuIChjaGlsZHJlbi5sZW5ndGggIT09IDEgfHxcclxuICAgICAgICBjaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8gfHxcclxuICAgICAgICAoY2hpbGQudHlwZSA9PT0gOSAvKiBJRiAqLyAmJiBjaGlsZC5icmFuY2hlcy5zb21lKGhhc011bHRpcGxlQ2hpbGRyZW4pKSk7XHJcbn1cblxuY29uc3QgaWdub3JlU2lkZUVmZmVjdFRhZ3MgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAobm9kZS50YWcgPT09ICdzY3JpcHQnIHx8IG5vZGUudGFnID09PSAnc3R5bGUnKSkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU5IC8qIFhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi8sIG5vZGUubG9jKSk7XHJcbiAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKCk7XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IERPTU5vZGVUcmFuc2Zvcm1zID0gW1xyXG4gICAgdHJhbnNmb3JtU3R5bGUsXHJcbiAgICAuLi4oKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gW3dhcm5UcmFuc2l0aW9uQ2hpbGRyZW5dIDogW10pXHJcbl07XHJcbmNvbnN0IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7XHJcbiAgICBjbG9hazogbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSxcclxuICAgIGh0bWw6IHRyYW5zZm9ybVZIdG1sLFxyXG4gICAgdGV4dDogdHJhbnNmb3JtVlRleHQsXHJcbiAgICBtb2RlbDogdHJhbnNmb3JtTW9kZWwsXHJcbiAgICBvbjogdHJhbnNmb3JtT24sXHJcbiAgICBzaG93OiB0cmFuc2Zvcm1TaG93XHJcbn07XHJcbmZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgcmV0dXJuIGJhc2VDb21waWxlKHRlbXBsYXRlLCBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMsIHtcclxuICAgICAgICBub2RlVHJhbnNmb3JtczogW1xyXG4gICAgICAgICAgICAvLyBpZ25vcmUgPHNjcmlwdD4gYW5kIDx0YWc+XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHB1dCBpbnNpZGUgRE9NTm9kZVRyYW5zZm9ybXMgYmVjYXVzZSB0aGF0IGxpc3QgaXMgdXNlZFxyXG4gICAgICAgICAgICAvLyBieSBjb21waWxlci1zc3IgdG8gZ2VuZXJhdGUgdm5vZGUgZmFsbGJhY2sgYnJhbmNoZXNcclxuICAgICAgICAgICAgaWdub3JlU2lkZUVmZmVjdFRhZ3MsXHJcbiAgICAgICAgICAgIC4uLkRPTU5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSlcclxuICAgICAgICBdLFxyXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgRE9NRGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9KSxcclxuICAgICAgICB0cmFuc2Zvcm1Ib2lzdDogbnVsbCBcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gYmFzZVBhcnNlKHRlbXBsYXRlLCBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMpKTtcclxufVxuXG5leHBvcnQgeyBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBET01Ob2RlVHJhbnNmb3JtcywgVFJBTlNJVElPTiwgVFJBTlNJVElPTl9HUk9VUCwgVl9NT0RFTF9DSEVDS0JPWCwgVl9NT0RFTF9EWU5BTUlDLCBWX01PREVMX1JBRElPLCBWX01PREVMX1NFTEVDVCwgVl9NT0RFTF9URVhULCBWX09OX1dJVEhfS0VZUywgVl9PTl9XSVRIX01PRElGSUVSUywgVl9TSE9XLCBjb21waWxlLCBjcmVhdGVET01Db21waWxlckVycm9yLCBwYXJzZSwgcGFyc2VyT3B0aW9ucywgdHJhbnNmb3JtU3R5bGUgfTtcbiIsImltcG9ydCB7IEVNUFRZX09CSiwgaXNBcnJheSwgaXNNYXAsIGlzSW50ZWdlcktleSwgaXNTeW1ib2wsIGV4dGVuZCwgaGFzT3duLCBpc09iamVjdCwgaGFzQ2hhbmdlZCwgbWFrZU1hcCwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBkZWYsIGlzRnVuY3Rpb24sIE5PT1AgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHRhcmdldE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IGVmZmVjdFN0YWNrID0gW107XHJcbmxldCBhY3RpdmVFZmZlY3Q7XHJcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdpdGVyYXRlJyA6ICcnKTtcclxuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcclxuZnVuY3Rpb24gaXNFZmZlY3QoZm4pIHtcclxuICAgIHJldHVybiBmbiAmJiBmbi5faXNFZmZlY3QgPT09IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XHJcbiAgICBpZiAoaXNFZmZlY3QoZm4pKSB7XHJcbiAgICAgICAgZm4gPSBmbi5yYXc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlZmZlY3QgPSBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucyk7XHJcbiAgICBpZiAoIW9wdGlvbnMubGF6eSkge1xyXG4gICAgICAgIGVmZmVjdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVmZmVjdDtcclxufVxyXG5mdW5jdGlvbiBzdG9wKGVmZmVjdCkge1xyXG4gICAgaWYgKGVmZmVjdC5hY3RpdmUpIHtcclxuICAgICAgICBjbGVhbnVwKGVmZmVjdCk7XHJcbiAgICAgICAgaWYgKGVmZmVjdC5vcHRpb25zLm9uU3RvcCkge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5vblN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWZmZWN0LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmxldCB1aWQgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgZWZmZWN0ID0gZnVuY3Rpb24gcmVhY3RpdmVFZmZlY3QoKSB7XHJcbiAgICAgICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNjaGVkdWxlciA/IHVuZGVmaW5lZCA6IGZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0KSkge1xyXG4gICAgICAgICAgICBjbGVhbnVwKGVmZmVjdCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0U3RhY2sucHVzaChlZmZlY3QpO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdFN0YWNrW2VmZmVjdFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGVmZmVjdC5pZCA9IHVpZCsrO1xyXG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XHJcbiAgICBlZmZlY3QuX2lzRWZmZWN0ID0gdHJ1ZTtcclxuICAgIGVmZmVjdC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgZWZmZWN0LnJhdyA9IGZuO1xyXG4gICAgZWZmZWN0LmRlcHMgPSBbXTtcclxuICAgIGVmZmVjdC5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHJldHVybiBlZmZlY3Q7XHJcbn1cclxuZnVuY3Rpb24gY2xlYW51cChlZmZlY3QpIHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG5jb25zdCB0cmFja1N0YWNrID0gW107XHJcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGFzdDtcclxufVxyXG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xyXG4gICAgaWYgKCFzaG91bGRUcmFjayB8fCBhY3RpdmVFZmZlY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIChkZXBzTWFwID0gbmV3IE1hcCgpKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcclxuICAgIGlmICghZGVwKSB7XHJcbiAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gbmV3IFNldCgpKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWRlcC5oYXMoYWN0aXZlRWZmZWN0KSkge1xyXG4gICAgICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcclxuICAgICAgICBhY3RpdmVFZmZlY3QuZGVwcy5wdXNoKGRlcCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhY3RpdmVFZmZlY3Qub3B0aW9ucy5vblRyYWNrKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2soe1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVFZmZlY3QsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAga2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xyXG4gICAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgIC8vIG5ldmVyIGJlZW4gdHJhY2tlZFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGVmZmVjdHMgPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBhZGQgPSAoZWZmZWN0c1RvQWRkKSA9PiB7XHJcbiAgICAgICAgaWYgKGVmZmVjdHNUb0FkZCkge1xyXG4gICAgICAgICAgICBlZmZlY3RzVG9BZGQuZm9yRWFjaChlZmZlY3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdC5hbGxvd1JlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzLmFkZChlZmZlY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIiAvKiBDTEVBUiAqLykge1xyXG4gICAgICAgIC8vIGNvbGxlY3Rpb24gYmVpbmcgY2xlYXJlZFxyXG4gICAgICAgIC8vIHRyaWdnZXIgYWxsIGVmZmVjdHMgZm9yIHRhcmdldFxyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaChhZGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiBpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZW5ndGgnIHx8IGtleSA+PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGRlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNjaGVkdWxlIHJ1bnMgZm9yIFNFVCB8IEFERCB8IERFTEVURVxyXG4gICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsc28gcnVuIGZvciBpdGVyYXRpb24ga2V5IG9uIEFERCB8IERFTEVURSB8IE1hcC5TRVRcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImFkZFwiIC8qIEFERCAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBpbmRleCBhZGRlZCB0byBhcnJheSAtPiBsZW5ndGggY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldCgnbGVuZ3RoJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIiAvKiBERUxFVEUgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZXRcIiAvKiBTRVQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcnVuID0gKGVmZmVjdCkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZWZmZWN0Lm9wdGlvbnMub25UcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vcHRpb25zLm9uVHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3QsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcclxuICAgICAgICAgICAgICAgIG9sZFRhcmdldFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVmZmVjdC5vcHRpb25zLnNjaGVkdWxlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5zY2hlZHVsZXIoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVmZmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBlZmZlY3RzLmZvckVhY2gocnVuKTtcclxufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xyXG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKVxyXG4gICAgLm1hcChrZXkgPT4gU3ltYm9sW2tleV0pXHJcbiAgICAuZmlsdGVyKGlzU3ltYm9sKSk7XHJcbmNvbnN0IGdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcihmYWxzZSwgdHJ1ZSk7XHJcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUsIHRydWUpO1xyXG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7fTtcclxuWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XHJcbiAgICBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogR0VUICovLCBpICsgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3ZSBydW4gdGhlIG1ldGhvZCB1c2luZyB0aGUgb3JpZ2luYWwgYXJncyBmaXJzdCAod2hpY2ggbWF5IGJlIHJlYWN0aXZlKVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IG1ldGhvZC5hcHBseShhcnIsIGFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhhdCBkaWRuJ3Qgd29yaywgcnVuIGl0IGFnYWluIHVzaW5nIHJhdyB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoYXJyLCBhcmdzLm1hcCh0b1JhdykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KTtcclxuWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZSddLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGNvbnN0IG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZVtrZXldO1xyXG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59KTtcclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLyAmJlxyXG4gICAgICAgICAgICByZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkgPyByZWFkb25seU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgaWYgKGlzU3ltYm9sKGtleSlcclxuICAgICAgICAgICAgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KVxyXG4gICAgICAgICAgICA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICAgICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYocmVzKSkge1xyXG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIGRvZXMgbm90IGFwcGx5IGZvciBBcnJheSArIGludGVnZXIga2V5LlxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRVbndyYXAgPSAhdGFyZ2V0SXNBcnJheSB8fCAhaXNJbnRlZ2VyS2V5KGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRVbndyYXAgPyByZXMudmFsdWUgOiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgaW50byBhIHByb3h5IGFzIHdlbGwuIHdlIGRvIHRoZSBpc09iamVjdCBjaGVja1xyXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGF2b2lkIGludmFsaWQgdmFsdWUgd2FybmluZy4gQWxzbyBuZWVkIHRvIGxhenkgYWNjZXNzIHJlYWRvbmx5XHJcbiAgICAgICAgICAgIC8vIGFuZCByZWFjdGl2ZSBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5ID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IHNldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcih0cnVlKTtcclxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoIXNoYWxsb3cpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpXHJcbiAgICAgICAgICAgID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoXHJcbiAgICAgICAgICAgIDogaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIHRhcmdldCBpcyBzb21ldGhpbmcgdXAgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBvcmlnaW5hbFxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xyXG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XHJcbiAgICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzQXJyYXkodGFyZ2V0KSA/ICdsZW5ndGgnIDogSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG59XHJcbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcclxuICAgIGdldCxcclxuICAgIHNldCxcclxuICAgIGRlbGV0ZVByb3BlcnR5LFxyXG4gICAgaGFzLFxyXG4gICAgb3duS2V5c1xyXG59O1xyXG5jb25zdCByZWFkb25seUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiByZWFkb25seUdldCxcclxuICAgIHNldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IGV4dGVuZCh7fSwgbXV0YWJsZUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXHJcbiAgICBzZXQ6IHNoYWxsb3dTZXRcclxufSk7XHJcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxyXG4vLyByZWZzIChpbiBvcmRlciB0byBhbGxvdyByZWZzIHRvIGJlIGV4cGxpY2l0bHkgcGFzc2VkIGRvd24pLCBidXQgc2hvdWxkXHJcbi8vIHJldGFpbiB0aGUgcmVhY3Rpdml0eSBvZiB0aGUgbm9ybWFsIHJlYWRvbmx5IG9iamVjdC5cclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSBleHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XHJcbn0pO1xuXG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XHJcbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XHJcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XHJcbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAvLyAjMTc3MjogcmVhZG9ubHkocmVhY3RpdmUoTWFwKSkgc2hvdWxkIHJldHVybiByZWFkb25seSArIHJlYWN0aXZlIHZlcnNpb25cclxuICAgIC8vIG9mIHRoZSB2YWx1ZVxyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCByYXdLZXkpO1xyXG4gICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XHJcbiAgICBjb25zdCB3cmFwID0gaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiB0b1JlYWN0aXZlO1xyXG4gICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCByYXdLZXkpO1xyXG4gICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5XHJcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcclxuICAgICAgICA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XHJcbn1cclxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCAnc2l6ZScsIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywgdmFsdWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIHNldCQxKGtleSwgdmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xyXG4gICAgaWYgKGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XHJcbiAgICBjb25zdCBvbGRUYXJnZXQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IGlzTWFwKHRhcmdldClcclxuICAgICAgICAgICAgPyBuZXcgTWFwKHRhcmdldClcclxuICAgICAgICAgICAgOiBuZXcgU2V0KHRhcmdldClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcclxuICAgIGlmIChoYWRJdGVtcykge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIgLyogQ0xFQVIgKi8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogbWFrZSBzdXJlIHRoZSBjYWxsYmFjayBpc1xyXG4gICAgICAgICAgICAvLyAxLiBpbnZva2VkIHdpdGggdGhlIHJlYWN0aXZlIG1hcCBhcyBgdGhpc2AgYW5kIDNyZCBhcmdcclxuICAgICAgICAgICAgLy8gMi4gdGhlIHZhbHVlIHJlY2VpdmVkIHNob3VsZCBiZSBhIGNvcnJlc3BvbmRpbmcgcmVhY3RpdmUvcmVhZG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09ICdlbnRyaWVzJyB8fCAobWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXApO1xyXG4gICAgICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gJ2tleXMnICYmIHRhcmdldElzTWFwO1xyXG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmXHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcclxuICAgICAgICAvLyByZXR1cm4gYSB3cmFwcGVkIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgb2JzZXJ2ZWQgdmVyc2lvbnMgb2YgdGhlXHJcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgICAgICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxyXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiAvKiBERUxFVEUgKi8gPyBmYWxzZSA6IHRoaXM7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xyXG4gICAgfSxcclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGhhczogaGFzJDEsXHJcbiAgICBhZGQsXHJcbiAgICBzZXQ6IHNldCQxLFxyXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgIGNsZWFyLFxyXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBoYXM6IGhhcyQxLFxyXG4gICAgYWRkLFxyXG4gICAgc2V0OiBzZXQkMSxcclxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXHJcbiAgICBjbGVhcixcclxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXHJcbn07XHJcbmNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcycsIFN5bWJvbC5pdGVyYXRvcl07XHJcbml0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XHJcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcclxuICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcclxufSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XHJcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvd1xyXG4gICAgICAgID8gc2hhbGxvd0luc3RydW1lbnRhdGlvbnNcclxuICAgICAgICA6IGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcclxuICAgIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0XHJcbiAgICAgICAgICAgID8gaW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcclxufTtcclxuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgYCArXHJcbiAgICAgICAgICAgIGB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgYCArXHJcbiAgICAgICAgICAgIGB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIGAgK1xyXG4gICAgICAgICAgICBgQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgYCArXHJcbiAgICAgICAgICAgIGBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcclxuICAgIHN3aXRjaCAocmF3VHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ09iamVjdCc6XHJcbiAgICAgICAgY2FzZSAnQXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XHJcbiAgICAgICAgY2FzZSAnTWFwJzpcclxuICAgICAgICBjYXNlICdTZXQnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtTZXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBTS0lQICovXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSlcclxuICAgICAgICA/IDAgLyogSU5WQUxJRCAqL1xyXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cclxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0W1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIHNoYWxsb3dseS1yZWFjdGl2ZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3RcclxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcclxuICogcm9vdCBsZXZlbCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcmVhZG9ubHkgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LiBOb3RlIHRoZSByZXR1cm5lZCBjb3B5IGlzIG5vdFxyXG4gKiBtYWRlIHJlYWN0aXZlLCBidXQgYHJlYWRvbmx5YCBjYW4gYmUgY2FsbGVkIG9uIGFuIGFscmVhZHkgcmVhY3RpdmUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcclxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxyXG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMpIHtcclxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cclxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XHJcbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL10gJiZcclxuICAgICAgICAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XHJcbiAgICBjb25zdCBwcm94eU1hcCA9IGlzUmVhZG9ubHkgPyByZWFkb25seU1hcCA6IHJlYWN0aXZlTWFwO1xyXG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgYSB3aGl0ZWxpc3Qgb2YgdmFsdWUgdHlwZXMgY2FuIGJlIG9ic2VydmVkLlxyXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnMpO1xyXG4gICAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcclxuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcclxuICAgIHJldHVybiAoKG9ic2VydmVkICYmIHRvUmF3KG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pKSB8fCBvYnNlcnZlZCk7XHJcbn1cclxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xyXG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogU0tJUCAqLywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuY29uc3QgY29udmVydCA9ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgPyByZWFjdGl2ZSh2YWwpIDogdmFsO1xyXG5mdW5jdGlvbiBpc1JlZihyKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiByZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xyXG59XHJcbmNsYXNzIFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX3Jhd1ZhbHVlLCBfc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBfcmF3VmFsdWU7XHJcbiAgICAgICAgdGhpcy5fc2hhbGxvdyA9IF9zaGFsbG93O1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF9zaGFsbG93ID8gX3Jhd1ZhbHVlIDogY29udmVydChfcmF3VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRyYWNrKHRvUmF3KHRoaXMpLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHRvUmF3KG5ld1ZhbCksIHRoaXMuX3Jhd1ZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9zaGFsbG93ID8gbmV3VmFsIDogY29udmVydChuZXdWYWwpO1xyXG4gICAgICAgICAgICB0cmlnZ2VyKHRvUmF3KHRoaXMpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJywgbmV3VmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcmF3VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XHJcbiAgICB0cmlnZ2VyKHRvUmF3KHJlZiksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyByZWYudmFsdWUgOiB2b2lkIDApO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVmKHJlZikge1xyXG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XHJcbn1cclxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcclxuICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpXHJcbiAgICAgICAgPyBvYmplY3RXaXRoUmVmc1xyXG4gICAgICAgIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xyXG59XHJcbmNsYXNzIEN1c3RvbVJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHRyYWNrKHRoaXMsIFwiZ2V0XCIgLyogR0VUICovLCAndmFsdWUnKSwgKCkgPT4gdHJpZ2dlcih0aGlzLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJykpO1xyXG4gICAgICAgIHRoaXMuX2dldCA9IGdldDtcclxuICAgICAgICB0aGlzLl9zZXQgPSBzZXQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NldChuZXdWYWwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmNsYXNzIE9iamVjdFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvUmVmKG9iamVjdCwga2V5KSB7XHJcbiAgICByZXR1cm4gaXNSZWYob2JqZWN0W2tleV0pXHJcbiAgICAgICAgPyBvYmplY3Rba2V5XVxyXG4gICAgICAgIDogbmV3IE9iamVjdFJlZkltcGwob2JqZWN0LCBrZXkpO1xyXG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHkpIHtcclxuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBlZmZlY3QoZ2V0dGVyLCB7XHJcbiAgICAgICAgICAgIGxhenk6IHRydWUsXHJcbiAgICAgICAgICAgIHNjaGVkdWxlcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKHRvUmF3KHRoaXMpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10gPSBpc1JlYWRvbmx5O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuZWZmZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrKHRvUmF3KHRoaXMpLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMpIHtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgc2V0dGVyO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcclxuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcclxuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSB8fCAhZ2V0dGVyT3JPcHRpb25zLnNldCk7XHJcbn1cblxuZXhwb3J0IHsgSVRFUkFURV9LRVksIGNvbXB1dGVkLCBjdXN0b21SZWYsIGVmZmVjdCwgZW5hYmxlVHJhY2tpbmcsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBtYXJrUmF3LCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIiwiaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUmVhY3RpdmUsIGVmZmVjdCwgc3RvcCwgcmVmLCBpc1Byb3h5LCBwcm94eVJlZnMsIHRvUmVmLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBjdXN0b21SZWYsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBtYXJrUmF3LCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIGV4dGVuZCwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09uLCBoYXNPd24sIGlzTW9kZWxMaXN0ZW5lciwgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCBpc09iamVjdCwgY2FwaXRhbGl6ZSwgdG9SYXdUeXBlLCBtYWtlTWFwLCByZW1vdmUsIE5PT1AsIGhhc0NoYW5nZWQsIGlzU2V0LCBpc01hcCwgaW52b2tlQXJyYXlGbnMsIE5PLCBnZXRHbG9iYWxUaGlzLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XHJcbiAgICBzdGFjay5wdXNoKHZub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcclxuICAgIHN0YWNrLnBvcCgpO1xyXG59XHJcbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICAvLyBhdm9pZCBwcm9wcyBmb3JtYXR0aW5nIG9yIHdhcm4gaGFuZGxlciB0cmFja2luZyBkZXBzIHRoYXQgbWlnaHQgYmUgbXV0YXRlZFxyXG4gICAgLy8gZHVyaW5nIHBhdGNoLCBsZWFkaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcclxuICAgIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XHJcbiAgICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XHJcbiAgICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwV2FybkhhbmRsZXIsIGluc3RhbmNlLCAxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovLCBbXHJcbiAgICAgICAgICAgIG1zZyArIGFyZ3Muam9pbignJyksXHJcbiAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmApXHJcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyksXHJcbiAgICAgICAgICAgIHRyYWNlXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHRyYWNlLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xyXG4gICAgICAgICAgICAhZmFsc2UpIHtcclxuICAgICAgICAgICAgd2FybkFyZ3MucHVzaChgXFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcclxuICAgIH1cclxuICAgIHJlc2V0VHJhY2tpbmcoKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcclxuICAgIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgIGlmICghY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgLy8gd2UgY2FuJ3QganVzdCB1c2UgdGhlIHN0YWNrIGJlY2F1c2UgaXQgd2lsbCBiZSBpbmNvbXBsZXRlIGR1cmluZyB1cGRhdGVzXHJcbiAgICAvLyB0aGF0IGRpZCBub3Qgc3RhcnQgZnJvbSB0aGUgcm9vdC4gUmUtY29uc3RydWN0IHRoZSBwYXJlbnQgY2hhaW4gdXNpbmdcclxuICAgIC8vIGluc3RhbmNlIHBhcmVudCBwb2ludGVycy5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xyXG4gICAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxyXG4gICAgICAgICAgICAgICAgcmVjdXJzZUNvdW50OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XHJcbiAgICAgICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XHJcbiAgICBjb25zdCBsb2dzID0gW107XHJcbiAgICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgIGxvZ3MucHVzaCguLi4oaSA9PT0gMCA/IFtdIDogW2BcXG5gXSksIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGxvZ3M7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xyXG4gICAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcclxuICAgIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xyXG4gICAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bm9kZS5jb21wb25lbnQsIHZub2RlLnR5cGUsIGlzUm9vdCl9YDtcclxuICAgIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcclxuICAgIHJldHVybiB2bm9kZS5wcm9wc1xyXG4gICAgICAgID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdXHJcbiAgICAgICAgOiBbb3BlbiArIGNsb3NlXTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xyXG4gICAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMykge1xyXG4gICAgICAgIHJlcy5wdXNoKGAgLi4uYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxyXG4gICAgICAgIHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XHJcbiAgICB9XHJcbn1cblxuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IHtcclxuICAgIFtcImJjXCIgLyogQkVGT1JFX0NSRUFURSAqL106ICdiZWZvcmVDcmVhdGUgaG9vaycsXHJcbiAgICBbXCJjXCIgLyogQ1JFQVRFRCAqL106ICdjcmVhdGVkIGhvb2snLFxyXG4gICAgW1wiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi9dOiAnYmVmb3JlTW91bnQgaG9vaycsXHJcbiAgICBbXCJtXCIgLyogTU9VTlRFRCAqL106ICdtb3VudGVkIGhvb2snLFxyXG4gICAgW1wiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovXTogJ2JlZm9yZVVwZGF0ZSBob29rJyxcclxuICAgIFtcInVcIiAvKiBVUERBVEVEICovXTogJ3VwZGF0ZWQnLFxyXG4gICAgW1wiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi9dOiAnYmVmb3JlVW5tb3VudCBob29rJyxcclxuICAgIFtcInVtXCIgLyogVU5NT1VOVEVEICovXTogJ3VubW91bnRlZCBob29rJyxcclxuICAgIFtcImFcIiAvKiBBQ1RJVkFURUQgKi9dOiAnYWN0aXZhdGVkIGhvb2snLFxyXG4gICAgW1wiZGFcIiAvKiBERUFDVElWQVRFRCAqL106ICdkZWFjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi9dOiAnZXJyb3JDYXB0dXJlZCBob29rJyxcclxuICAgIFtcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovXTogJ3JlbmRlclRyYWNrZWQgaG9vaycsXHJcbiAgICBbXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovXTogJ3JlbmRlclRyaWdnZXJlZCBob29rJyxcclxuICAgIFswIC8qIFNFVFVQX0ZVTkNUSU9OICovXTogJ3NldHVwIGZ1bmN0aW9uJyxcclxuICAgIFsxIC8qIFJFTkRFUl9GVU5DVElPTiAqL106ICdyZW5kZXIgZnVuY3Rpb24nLFxyXG4gICAgWzIgLyogV0FUQ0hfR0VUVEVSICovXTogJ3dhdGNoZXIgZ2V0dGVyJyxcclxuICAgIFszIC8qIFdBVENIX0NBTExCQUNLICovXTogJ3dhdGNoZXIgY2FsbGJhY2snLFxyXG4gICAgWzQgLyogV0FUQ0hfQ0xFQU5VUCAqL106ICd3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb24nLFxyXG4gICAgWzUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi9dOiAnbmF0aXZlIGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi9dOiAnY29tcG9uZW50IGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzcgLyogVk5PREVfSE9PSyAqL106ICd2bm9kZSBob29rJyxcclxuICAgIFs4IC8qIERJUkVDVElWRV9IT09LICovXTogJ2RpcmVjdGl2ZSBob29rJyxcclxuICAgIFs5IC8qIFRSQU5TSVRJT05fSE9PSyAqL106ICd0cmFuc2l0aW9uIGhvb2snLFxyXG4gICAgWzEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovXTogJ2FwcCBlcnJvckhhbmRsZXInLFxyXG4gICAgWzExIC8qIEFQUF9XQVJOX0hBTkRMRVIgKi9dOiAnYXBwIHdhcm5IYW5kbGVyJyxcclxuICAgIFsxMiAvKiBGVU5DVElPTl9SRUYgKi9dOiAncmVmIGZ1bmN0aW9uJyxcclxuICAgIFsxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovXTogJ2FzeW5jIGNvbXBvbmVudCBsb2FkZXInLFxyXG4gICAgWzE0IC8qIFNDSEVEVUxFUiAqL106ICdzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuICcgK1xyXG4gICAgICAgICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvdnVlLW5leHQnXHJcbn07XHJcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGxldCByZXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlcyA9IGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xyXG4gICAgICAgICAgICByZXMuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xyXG4gICAgICAgIC8vIHRoZSBleHBvc2VkIGluc3RhbmNlIGlzIHRoZSByZW5kZXIgcHJveHkgdG8ga2VlcCBpdCBjb25zaXN0ZW50IHdpdGggMi54XHJcbiAgICAgICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICAgICAgLy8gaW4gcHJvZHVjdGlvbiB0aGUgaG9vayByZWNlaXZlcyBvbmx5IHRoZSBlcnJvciBjb2RlXHJcbiAgICAgICAgY29uc3QgZXJyb3JJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXSA6IHR5cGU7XHJcbiAgICAgICAgd2hpbGUgKGN1cikge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhcHAtbGV2ZWwgaGFuZGxpbmdcclxuICAgICAgICBjb25zdCBhcHBFcnJvckhhbmRsZXIgPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5lcnJvckhhbmRsZXI7XHJcbiAgICAgICAgaWYgKGFwcEVycm9ySGFuZGxlcikge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwRXJyb3JIYW5kbGVyLCBudWxsLCAxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqLywgW2VyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm9dKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2KTtcclxufVxyXG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXTtcclxuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3YXJuKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcclxuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyYXNoIGluIGRldiBieSBkZWZhdWx0IHNvIGl0J3MgbW9yZSBub3RpY2VhYmxlXHJcbiAgICAgICAgaWYgKHRocm93SW5EZXYpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHJlY292ZXIgaW4gcHJvZCB0byByZWR1Y2UgdGhlIGltcGFjdCBvbiBlbmQtdXNlclxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgIH1cclxufVxuXG5sZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xyXG5sZXQgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuY29uc3QgcXVldWUgPSBbXTtcclxubGV0IGZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCBwZW5kaW5nUHJlRmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHByZUZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XHJcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xyXG5jb25zdCByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcclxubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xyXG5sZXQgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gbnVsbDtcclxuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xyXG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xyXG4gICAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xyXG4gICAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcclxufVxyXG4vLyAjMjc2OFxyXG4vLyBVc2UgYmluYXJ5LXNlYXJjaCB0byBmaW5kIGEgc3VpdGFibGUgcG9zaXRpb24gaW4gdGhlIHF1ZXVlLFxyXG4vLyBzbyB0aGF0IHRoZSBxdWV1ZSBtYWludGFpbnMgdGhlIGluY3JlYXNpbmcgb3JkZXIgb2Ygam9iJ3MgaWQsXHJcbi8vIHdoaWNoIGNhbiBwcmV2ZW50IHRoZSBqb2IgZnJvbSBiZWluZyBza2lwcGVkIGFuZCBhbHNvIGNhbiBhdm9pZCByZXBlYXRlZCBwYXRjaGluZy5cclxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGpvYikge1xyXG4gICAgLy8gdGhlIHN0YXJ0IGluZGV4IHNob3VsZCBiZSBgZmx1c2hJbmRleCArIDFgXHJcbiAgICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcclxuICAgIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XHJcbiAgICBjb25zdCBqb2JJZCA9IGdldElkKGpvYik7XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICBjb25zdCBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQocXVldWVbbWlkZGxlXSk7XHJcbiAgICAgICAgbWlkZGxlSm9iSWQgPCBqb2JJZCA/IChzdGFydCA9IG1pZGRsZSArIDEpIDogKGVuZCA9IG1pZGRsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhcnQ7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XHJcbiAgICAvLyB0aGUgZGVkdXBlIHNlYXJjaCB1c2VzIHRoZSBzdGFydEluZGV4IGFyZ3VtZW50IG9mIEFycmF5LmluY2x1ZGVzKClcclxuICAgIC8vIGJ5IGRlZmF1bHQgdGhlIHNlYXJjaCBpbmRleCBpbmNsdWRlcyB0aGUgY3VycmVudCBqb2IgdGhhdCBpcyBiZWluZyBydW5cclxuICAgIC8vIHNvIGl0IGNhbm5vdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiBhZ2Fpbi5cclxuICAgIC8vIGlmIHRoZSBqb2IgaXMgYSB3YXRjaCgpIGNhbGxiYWNrLCB0aGUgc2VhcmNoIHdpbGwgc3RhcnQgd2l0aCBhICsxIGluZGV4IHRvXHJcbiAgICAvLyBhbGxvdyBpdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiAtIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG9cclxuICAgIC8vIGVuc3VyZSBpdCBkb2Vzbid0IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wLlxyXG4gICAgaWYgKCghcXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgIXF1ZXVlLmluY2x1ZGVzKGpvYiwgaXNGbHVzaGluZyAmJiBqb2IuYWxsb3dSZWN1cnNlID8gZmx1c2hJbmRleCArIDEgOiBmbHVzaEluZGV4KSkgJiZcclxuICAgICAgICBqb2IgIT09IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYikge1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRJbnNlcnRpb25JbmRleChqb2IpO1xyXG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xyXG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UocG9zLCAwLCBqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChqb2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZUZsdXNoKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcclxuICAgIGlmICghaXNGbHVzaGluZyAmJiAhaXNGbHVzaFBlbmRpbmcpIHtcclxuICAgICAgICBpc0ZsdXNoUGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW52YWxpZGF0ZUpvYihqb2IpIHtcclxuICAgIGNvbnN0IGkgPSBxdWV1ZS5pbmRleE9mKGpvYik7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlQ2IoY2IsIGFjdGl2ZVF1ZXVlLCBwZW5kaW5nUXVldWUsIGluZGV4KSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoY2IpKSB7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVRdWV1ZSB8fFxyXG4gICAgICAgICAgICAhYWN0aXZlUXVldWUuaW5jbHVkZXMoY2IsIGNiLmFsbG93UmVjdXJzZSA/IGluZGV4ICsgMSA6IGluZGV4KSkge1xyXG4gICAgICAgICAgICBwZW5kaW5nUXVldWUucHVzaChjYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgY2IgaXMgYW4gYXJyYXksIGl0IGlzIGEgY29tcG9uZW50IGxpZmVjeWNsZSBob29rIHdoaWNoIGNhbiBvbmx5IGJlXHJcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5IGEgam9iLCB3aGljaCBpcyBhbHJlYWR5IGRlZHVwZWQgaW4gdGhlIG1haW4gcXVldWUsIHNvXHJcbiAgICAgICAgLy8gd2UgY2FuIHNraXAgZHVwbGljYXRlIGNoZWNrIGhlcmUgdG8gaW1wcm92ZSBwZXJmXHJcbiAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goLi4uY2IpO1xyXG4gICAgfVxyXG4gICAgcXVldWVGbHVzaCgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUHJlRmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUHJlRmx1c2hDYnMsIHBlbmRpbmdQcmVGbHVzaENicywgcHJlRmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUG9zdEZsdXNoQ2JzLCBwZW5kaW5nUG9zdEZsdXNoQ2JzLCBwb3N0Rmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhzZWVuLCBwYXJlbnRKb2IgPSBudWxsKSB7XHJcbiAgICBpZiAocGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgIGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IHBhcmVudEpvYjtcclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQcmVGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHByZUZsdXNoSW5kZXggPSAwOyBwcmVGbHVzaEluZGV4IDwgYWN0aXZlUHJlRmx1c2hDYnMubGVuZ3RoOyBwcmVGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbiAgICAgICAgcHJlRmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gbnVsbDtcclxuICAgICAgICAvLyByZWN1cnNpdmVseSBmbHVzaCB1bnRpbCBpdCBkcmFpbnNcclxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKHNlZW4sIHBhcmVudEpvYik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xyXG4gICAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gIzE5NDcgYWxyZWFkeSBoYXMgYWN0aXZlIHF1ZXVlLCBuZXN0ZWQgZmx1c2hQb3N0Rmx1c2hDYnMgY2FsbFxyXG4gICAgICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcclxuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xyXG4gICAgICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoc2Vlbik7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXHJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXHJcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcclxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXHJcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoam9iKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBTQ0hFRFVMRVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcclxuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcclxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cclxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZsdXNoSm9icyhzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XHJcbiAgICBpZiAoIXNlZW4uaGFzKGZuKSkge1xyXG4gICAgICAgIHNlZW4uc2V0KGZuLCAxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pO1xyXG4gICAgICAgIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGAgK1xyXG4gICAgICAgICAgICAgICAgYGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3IgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZWVuLnNldChmbiwgY291bnQgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XHJcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IG5ldyBTZXQoKTtcclxuLy8gRXhwb3NlIHRoZSBITVIgcnVudGltZSBvbiB0aGUgZ2xvYmFsIG9iamVjdFxyXG4vLyBUaGlzIG1ha2VzIGl0IGVudGlyZWx5IHRyZWUtc2hha2FibGUgd2l0aG91dCBwb2xsdXRpbmcgdGhlIGV4cG9ydHMgYW5kIG1ha2VzXHJcbi8vIGl0IGVhc2llciB0byBiZSB1c2VkIGluIHRvb2xpbmdzIGxpa2UgdnVlLWxvYWRlclxyXG4vLyBOb3RlOiBmb3IgYSBjb21wb25lbnQgdG8gYmUgZWxpZ2libGUgZm9yIEhNUiBpdCBhbHNvIG5lZWRzIHRoZSBfX2htcklkIG9wdGlvblxyXG4vLyB0byBiZSBzZXQgc28gdGhhdCBpdHMgaW5zdGFuY2VzIGNhbiBiZSByZWdpc3RlcmVkIC8gcmVtb3ZlZC5cclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgY29uc3QgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICA/IGdsb2JhbFxyXG4gICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgOiB7fTtcclxuICAgIGdsb2JhbE9iamVjdC5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxyXG4gICAgICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcclxuICAgICAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxyXG4gICAgfTtcclxufVxyXG5jb25zdCBtYXAgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcclxuICAgIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKSB7XHJcbiAgICAgICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIH1cclxuICAgIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBjb21wb25lbnQpIHtcclxuICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgd2FybihgSE1SIEFQSSB1c2FnZSBpcyBvdXQgb2YgZGF0ZS5cXG5gICtcclxuICAgICAgICAgICAgYFBsZWFzZSB1cGdyYWRlIHZ1ZS1sb2FkZXIvdml0ZS9yb2xsdXAtcGx1Z2luLXZ1ZSBvciBvdGhlciByZWxldmFudCBgICtcclxuICAgICAgICAgICAgYGRlcGVuZGVuY3kgdGhhdCBoYW5kbGVzIFZ1ZSBTRkMgY29tcGlsYXRpb24uYCk7XHJcbiAgICAgICAgY29tcG9uZW50ID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAobWFwLmhhcyhpZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtYXAuc2V0KGlkLCB7XHJcbiAgICAgICAgY29tcG9uZW50OiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50LFxyXG4gICAgICAgIGluc3RhbmNlczogbmV3IFNldCgpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcclxuICAgIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgaWYgKCFyZWNvcmQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKG5ld1JlbmRlcilcclxuICAgICAgICByZWNvcmQuY29tcG9uZW50LnJlbmRlciA9IG5ld1JlbmRlcjtcclxuICAgIC8vIEFycmF5LmZyb20gY3JlYXRlcyBhIHNuYXBzaG90IHdoaWNoIGF2b2lkcyB0aGUgc2V0IGJlaW5nIG11dGF0ZWQgZHVyaW5nXHJcbiAgICAvLyB1cGRhdGVzXHJcbiAgICBBcnJheS5mcm9tKHJlY29yZC5pbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChuZXdSZW5kZXIpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xyXG4gICAgICAgIC8vIHRoaXMgZmxhZyBmb3JjZXMgY2hpbGQgY29tcG9uZW50cyB3aXRoIHNsb3QgY29udGVudCB0byB1cGRhdGVcclxuICAgICAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcclxuICAgIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgaWYgKCFyZWNvcmQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gQXJyYXkuZnJvbSBjcmVhdGVzIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmdcclxuICAgIC8vIHVwZGF0ZXNcclxuICAgIGNvbnN0IHsgY29tcG9uZW50LCBpbnN0YW5jZXMgfSA9IHJlY29yZDtcclxuICAgIGlmICghaG1yRGlydHlDb21wb25lbnRzLmhhcyhjb21wb25lbnQpKSB7XHJcbiAgICAgICAgLy8gMS4gVXBkYXRlIGV4aXN0aW5nIGNvbXAgZGVmaW5pdGlvbiB0byBtYXRjaCBuZXcgb25lXHJcbiAgICAgICAgbmV3Q29tcCA9IGlzQ2xhc3NDb21wb25lbnQobmV3Q29tcCkgPyBuZXdDb21wLl9fdmNjT3B0cyA6IG5ld0NvbXA7XHJcbiAgICAgICAgZXh0ZW5kKGNvbXBvbmVudCwgbmV3Q29tcCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdDb21wKSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDIuIE1hcmsgY29tcG9uZW50IGRpcnR5LiBUaGlzIGZvcmNlcyB0aGUgcmVuZGVyZXIgdG8gcmVwbGFjZSB0aGUgY29tcG9uZW50XHJcbiAgICAgICAgLy8gb24gcGF0Y2guXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChjb21wb25lbnQpO1xyXG4gICAgICAgIC8vIDMuIE1ha2Ugc3VyZSB0byB1bm1hcmsgdGhlIGNvbXBvbmVudCBhZnRlciB0aGUgcmVsb2FkLlxyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKGNvbXBvbmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBBcnJheS5mcm9tKGluc3RhbmNlcykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyA0LiBGb3JjZSB0aGUgcGFyZW50IGluc3RhbmNlIHRvIHJlLXJlbmRlci4gVGhpcyB3aWxsIGNhdXNlIGFsbCB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGZvcmNpbmcgdGhlIHNhbWUgcGFyZW50IHRvIHJlLXJlbmRlciBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgbW91bnRlZCB2aWEgY3JlYXRlQXBwKCkgaGFzIGEgcmVsb2FkIG1ldGhvZFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xyXG4gICAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxubGV0IGRldnRvb2xzO1xyXG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2soaG9vaykge1xyXG4gICAgZGV2dG9vbHMgPSBob29rO1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcclxuICAgIC8vIFRPRE8gcXVldWUgaWYgZGV2dG9vbHMgaXMgdW5kZWZpbmVkXHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcclxuICAgICAgICBGcmFnbWVudCxcclxuICAgICAgICBUZXh0LFxyXG4gICAgICAgIENvbW1lbnQsXHJcbiAgICAgICAgU3RhdGljXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqLyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcyk7XHJcbn1cblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcclxuICAgIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IHsgZW1pdHNPcHRpb25zLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoZW1pdHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGFyZ3MgPSByYXdBcmdzO1xyXG4gICAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aCgndXBkYXRlOicpO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFwcGx5IG1vZGlmaWVycyBvbiBhcmdzXHJcbiAgICBjb25zdCBtb2RlbEFyZyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBldmVudC5zbGljZSg3KTtcclxuICAgIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSAnbW9kZWxWYWx1ZScgPyAnbW9kZWwnIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcclxuICAgICAgICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gcHJvcHNbbW9kaWZpZXJzS2V5XSB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGEgPT4gYS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1iZXIpIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKHRvTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcclxuICAgICAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBgICtcclxuICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcclxuICAgICAgICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXHJcbiAgICAgICAgICAgICAgICBgWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY29udmVydCBoYW5kbGVyIG5hbWUgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcclxuICAgIGxldCBoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpO1xyXG4gICAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZV07XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYWxzbyB0cmlnZ2VyIGtlYmFiLWNhc2UgZXF1aXZhbGVudFxyXG4gICAgLy8gZm9yIHByb3BzIHBhc3NlZCB2aWEga2ViYWItY2FzZVxyXG4gICAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xyXG4gICAgICAgIGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpO1xyXG4gICAgICAgIGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZV07XHJcbiAgICB9XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xyXG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5lbWl0dGVkID0ge30pW2hhbmRsZXJOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcob25jZUhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIWFwcENvbnRleHQuZGVvcHQgJiYgY29tcC5fX2VtaXRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY29tcC5fX2VtaXRzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcclxuICAgIGxldCBub3JtYWxpemVkID0ge307XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIHJldHVybiAoY29tcC5fX2VtaXRzID0gbnVsbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgcmF3LmZvckVhY2goa2V5ID0+IChub3JtYWxpemVkW2tleV0gPSBudWxsKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY29tcC5fX2VtaXRzID0gbm9ybWFsaXplZCk7XHJcbn1cclxuLy8gQ2hlY2sgaWYgYW4gaW5jb21pbmcgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyLlxyXG4vLyBlLmcuIFdpdGggYGVtaXRzOiB7IGNsaWNrOiBudWxsIH1gLCBwcm9wcyBuYW1lZCBgb25DbGlja2AgYW5kIGBvbmNsaWNrYCBhcmVcclxuLy8gYm90aCBjb25zaWRlcmVkIG1hdGNoZWQgbGlzdGVuZXJzLlxyXG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgJycpO1xyXG4gICAgcmV0dXJuIChoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBrZXkpKTtcclxufVxuXG4vKipcclxuICogbWFyayB0aGUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2UgZm9yIGFzc2V0IHJlc29sdXRpb24gKGUuZy5cclxuICogcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSkgZHVyaW5nIHJlbmRlclxyXG4gKi9cclxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgdG8gdHJhY2sgd2hldGhlciAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlci5cclxuICogSWYgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIgdGhlbiB0aGUgd2FybmluZyBmb3IgZmFpbGVkIGF0dHJzXHJcbiAqIGZhbGx0aHJvdWdoIGNhbiBiZSBzdXBwcmVzc2VkLlxyXG4gKi9cclxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XHJcbiAgICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCwgdm5vZGUsIHByb3h5LCB3aXRoUHJveHksIHByb3BzLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLCBzbG90cywgYXR0cnMsIGVtaXQsIHJlbmRlciwgcmVuZGVyQ2FjaGUsIGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgZmFsbHRocm91Z2hBdHRycztcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxyXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xyXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhdHRyIG1lcmdpbmdcclxuICAgICAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcclxuICAgICAgICAvLyB0byBoYXZlIGNvbW1lbnRzIGFsb25nIHNpZGUgdGhlIHJvb3QgZWxlbWVudCB3aGljaCBtYWtlcyBpdCBhIGZyYWdtZW50XHJcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQ7XHJcbiAgICAgICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmluaGVyaXRBdHRycyAhPT0gZmFsc2UgJiYgZmFsbHRocm91Z2hBdHRycykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xyXG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSB2LW1vZGVsIGxpc3RlbmVyIChvblVwZGF0ZTp4eHgpIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjbGFyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcCwgaXQgaW5kaWNhdGVzIHRoaXMgY29tcG9uZW50IGV4cGVjdHMgdG8gaGFuZGxlIHYtbW9kZWwgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBub3QgZmFsbHRocm91Z2guXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0ZWQ6ICMxNTQzLCAjMTY0MywgIzE5ODlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKGZhbGx0aHJvdWdoQXR0cnMsIHByb3BzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGhhbmRsZXJzIHdoZW4gdGhleSBmYWlsIHRvIGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V2ZW50QXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgICAgIGlmICh2bm9kZS5kaXJzKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaGVyaXQgdHJhbnNpdGlvbiBkYXRhXHJcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0Um9vdCkge1xyXG4gICAgICAgICAgICBzZXRSb290KHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcm9vdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqIEluIGRldiBtb2RlLCB0ZW1wbGF0ZSByb290IGxldmVsIGNvbW1lbnRzIGFyZSByZW5kZXJlZCwgd2hpY2ggdHVybnMgdGhlXHJcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XHJcbiAqIHJvb3QgZm9yIGF0dHJzIGFuZCBzY29wZSBpZCBwcm9jZXNzaW5nLlxyXG4gKi9cclxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XHJcbiAgICBpZiAoIWNoaWxkUm9vdCkge1xyXG4gICAgICAgIHJldHVybiBbdm5vZGUsIHVuZGVmaW5lZF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcclxuICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcclxuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcclxuICAgICAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcclxufTtcclxuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xyXG4gICAgbGV0IHNpbmdsZVJvb3Q7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gJ3YtaWYnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBtb3JlIHRoYW4gMSBub24tY29tbWVudCBjaGlsZCwgcmV0dXJuIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzaW5nbGVSb290O1xyXG59XHJcbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xyXG4gICAgbGV0IHJlcztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcclxuICAgIHJldHVybiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gfHxcclxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICB2bm9kZS50eXBlID09PSBDb21tZW50IC8vIHBvdGVudGlhbCB2LWlmIGJyYW5jaCBzd2l0Y2hcclxuICAgICk7XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xyXG4gICAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcclxuICAgIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcclxuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXHJcbiAgICAvLyBjYXVzZWQgdGhlIGNoaWxkIGNvbXBvbmVudCdzIHNsb3RzIGNvbnRlbnQgdG8gaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmb3JjZSB0aGUgY2hpbGQgdG8gdXBkYXRlIGFzIHdlbGwuXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxyXG4gICAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLykge1xyXG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgdGhhdCByZWZlcmVuY2VzIHZhbHVlcyB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHRha2VuIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xyXG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcclxuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcclxuKSB7XHJcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XHJcbi8vIFN1c3BlbnNlIGV4cG9zZXMgYSBjb21wb25lbnQtbGlrZSBBUEksIGFuZCBpcyB0cmVhdGVkIGxpa2UgYSBjb21wb25lbnRcclxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3NcclxuLy8gZGlyZWN0bHkgaW50byB0aGUgcmVuZGVyZXIuXHJcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcclxuICAgIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcclxuICAgIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXHJcbiAgICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcclxuICAgIC8vIGludGVybmFscy5cclxuICAgIF9faXNTdXNwZW5zZTogdHJ1ZSxcclxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgXHJcbiAgICAvLyBwbGF0Zm9ybS1zcGVjaWZpYyBpbXBsIHBhc3NlZCBmcm9tIHJlbmRlcmVyXHJcbiAgICByZW5kZXJlckludGVybmFscykge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50U3VzcGVuc2UobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxyXG4gICAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5XHJcbn07XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbFxyXG4gICAgKTtcclxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpKTtcclxuICAgIC8vIHN0YXJ0IG1vdW50aW5nIHRoZSBjb250ZW50IHN1YnRyZWUgaW4gYW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgIHBhdGNoKG51bGwsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbnkgYXN5bmMgZGVwc1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XHJcbiAgICAgICAgLy8gaGFzIGFzeW5jXHJcbiAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgIGlzU1ZHKTtcclxuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU3VzcGVuc2UgaGFzIG5vIGFzeW5jIGRlcHMuIEp1c3QgcmVzb2x2ZS5cclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAobjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZSk7XHJcbiAgICBzdXNwZW5zZS52bm9kZSA9IG4yO1xyXG4gICAgbjIuZWwgPSBuMS5lbDtcclxuICAgIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcclxuICAgIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcclxuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcclxuICAgIGlmIChwZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gc2FtZSByb290IHR5cGUgYnV0IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgcGF0Y2gocGVuZGluZ0JyYW5jaCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2dnbGVkIGJlZm9yZSBwZW5kaW5nIHRyZWUgaXMgcmVzb2x2ZWRcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdG9nZ2xlZCBiZWZvcmUgaHlkcmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgY3VycmVudCBET00gdHJlZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHZhbGlkLiBzZXQgaXQgYXMgdGhlIGFjdGl2ZSBicmFuY2ggc28gaXQgd2lsbCBiZSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGVuZGluZyBJRC4gdGhpcyBpcyB1c2VkIHRvIGludmFsaWRhdGUgYXN5bmMgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHN1c3BlbnNlIHN0YXRlXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGVmZmVjdHMgZnJvbSBwZW5kaW5nIGJyYW5jaFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGluIGZhbGxiYWNrIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGVkIFwiYmFja1wiIHRvIGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSByZXNvbHZlXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoZWQgdG8gYSAzcmQgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyByb290IGRpZCBub3QgY2hhbmdlLCBqdXN0IG5vcm1hbCBwYXRjaFxyXG4gICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBub2RlIHRvZ2dsZWRcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBwZW5kaW5nIGV2ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUGVuZGluZyA9IG4yLnByb3BzICYmIG4yLnByb3BzLm9uUGVuZGluZztcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25QZW5kaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgb25QZW5kaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbW91bnQgcGVuZGluZyBicmFuY2ggaW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGJyYW5jaCBoYXMgbm8gYXN5bmMgZGVwcywgcmVzb2x2ZSBub3cuXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnQsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY29uc29sZS5pbmZvYCBjYW5ub3QgYmUgbnVsbCBlcnJvclxyXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiB1bm1vdW50LCBuOiBuZXh0LCBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSB0b051bWJlcih2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50aW1lb3V0KTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0ge1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgaXNTVkcsXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGhpZGRlbkNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgZGVwczogMCxcclxuICAgICAgICBwZW5kaW5nSWQ6IDAsXHJcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxyXG4gICAgICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcclxuICAgICAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcclxuICAgICAgICBpc0h5ZHJhdGluZyxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgZWZmZWN0czogW10sXHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBwZW5kaW5nSWQsIGVmZmVjdHMsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbml0aWFsIGFuY2hvciBvbiBtb3VudFxyXG4gICAgICAgICAgICAgICAgbGV0IHsgYW5jaG9yIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmYWxsYmFjayB0cmVlIHdhcyBtb3VudGVkLCBpdCBtYXkgaGF2ZSBiZWVuIG1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBjb250ZW50IGZyb20gb2ZmLWRvbSBjb250YWluZXIgdG8gYWN0dWFsIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlXHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGF0IHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIGZsdXNoIGFsbCBqb2JzXHJcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEByZXNvbHZlIGV2ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUmVzb2x2ZSA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uUmVzb2x2ZTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25SZXNvbHZlKSkge1xyXG4gICAgICAgICAgICAgICAgb25SZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaXNTVkcgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRmFsbGJhY2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vbkZhbGxiYWNrO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvbkZhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgb25GYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIGZhbGxiYWNrVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcclxuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHR5cGUpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcclxuICAgICAgICAgICAgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luY1NldHVwUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIHVubW91bnRlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgZnJvbSB0aGlzIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkIGlmIGFuIHVwZGF0ZSBoYXBwZW5lZCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgZGVwIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksIHN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlLmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gc3VzcGVuc2U7XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBub2RlLnBhcmVudE5vZGUsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBudWxsLCBpc1NWRywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pKTtcclxuICAgIC8vIHRoZXJlIGFyZSB0d28gcG9zc2libGUgc2NlbmFyaW9zIGZvciBzZXJ2ZXItcmVuZGVyZWQgc3VzcGVuc2U6XHJcbiAgICAvLyAtIHN1Y2Nlc3M6IHNzciBjb250ZW50IHNob3VsZCBiZSBmdWxseSByZXNvbHZlZFxyXG4gICAgLy8gLSBmYWlsdXJlOiBzc3IgY29udGVudCBzaG91bGQgYmUgdGhlIGZhbGxiYWNrIGJyYW5jaC5cclxuICAgIC8vIGhvd2V2ZXIsIG9uIHRoZSBjbGllbnQgd2UgZG9uJ3QgcmVhbGx5IGtub3cgaWYgaXQgaGFzIGZhaWxlZCBvciBub3RcclxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgRE9NIGFzc3VtaW5nIGl0IGhhcyBzdWNjZWVkZWQsIGJ1dCB3ZSBzdGlsbFxyXG4gICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBzdXNwZW5zZSBib3VuZGFyeSBmaXJzdFxyXG4gICAgY29uc3QgcmVzdWx0ID0gaHlkcmF0ZU5vZGUobm9kZSwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICBsZXQgZmFsbGJhY2s7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmRlZmF1bHQpO1xyXG4gICAgICAgIGZhbGxiYWNrID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4pO1xyXG4gICAgICAgIGZhbGxiYWNrID0gbm9ybWFsaXplVk5vZGUobnVsbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgZmFsbGJhY2tcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgcyA9IHMoKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHMpKSB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xyXG4gICAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShmbikpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcclxuICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XHJcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XHJcbiAgICAvLyBpbiBjYXNlIHN1c3BlbnNlIGlzIHRoZSByb290IG5vZGUgb2YgYSBjb21wb25lbnQsXHJcbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdGhlIEhPQyBlbFxyXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcclxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XHJcbiAgICB9XHJcbn1cblxubGV0IGlzUmVuZGVyaW5nQ29tcGlsZWRTbG90ID0gMDtcclxuY29uc3Qgc2V0Q29tcGlsZWRTbG90UmVuZGVyaW5nID0gKG4pID0+IChpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdCArPSBuKTtcclxuLyoqXHJcbiAqIENvbXBpbGVyIHJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgYDxzbG90Lz5gXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBcclxuLy8gdGhpcyBpcyBub3QgYSB1c2VyLWZhY2luZyBmdW5jdGlvbiwgc28gdGhlIGZhbGxiYWNrIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnlcclxuLy8gdGhlIGNvbXBpbGVyIGFuZCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5XHJcbmZhbGxiYWNrKSB7XHJcbiAgICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIGAgK1xyXG4gICAgICAgICAgICBgcGFyZW50IHRlbXBsYXRlLmApO1xyXG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcclxuICAgIH1cclxuICAgIC8vIGEgY29tcGlsZWQgc2xvdCBkaXNhYmxlcyBibG9jayB0cmFja2luZyBieSBkZWZhdWx0IHRvIGF2b2lkIG1hbnVhbFxyXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cclxuICAgIC8vIGByZW5kZXJTbG90YCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3MgdGVtcGxhdGUtYmFzZWQgc28gd2UgY2FuIGZvcmNlXHJcbiAgICAvLyBlbmFibGUgaXQuXHJcbiAgICBpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdCsrO1xyXG4gICAgb3BlbkJsb2NrKCk7XHJcbiAgICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcclxuICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soRnJhZ21lbnQsIHsga2V5OiBwcm9wcy5rZXkgfHwgYF8ke25hbWV9YCB9LCB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi9cclxuICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgIDogLTIgLyogQkFJTCAqLyk7XHJcbiAgICBpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdC0tO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVkO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XHJcbiAgICByZXR1cm4gdm5vZGVzLnNvbWUoY2hpbGQgPT4ge1xyXG4gICAgICAgIGlmICghaXNWTm9kZShjaGlsZCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSlcclxuICAgICAgICA/IHZub2Rlc1xyXG4gICAgICAgIDogbnVsbDtcclxufVxuXG4vKipcclxuICogV3JhcCBhIHNsb3QgZnVuY3Rpb24gdG8gbWVtb2l6ZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAvLyBJZiBhIHVzZXIgY2FsbHMgYSBjb21waWxlZCBzbG90IGluc2lkZSBhIHRlbXBsYXRlIGV4cHJlc3Npb24gKCMxNzQ1KSwgaXRcclxuICAgICAgICAvLyBjYW4gbWVzcyB1cCBibG9jayB0cmFja2luZywgc28gYnkgZGVmYXVsdCB3ZSBuZWVkIHRvIHB1c2ggYSBudWxsIGJsb2NrIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgdGhhdC4gVGhpcyBpc24ndCBuZWNlc3NhcnkgaWYgcmVuZGVyaW5nIGEgY29tcGlsZWQgYDxzbG90PmAuXHJcbiAgICAgICAgaWYgKCFpc1JlbmRlcmluZ0NvbXBpbGVkU2xvdCkge1xyXG4gICAgICAgICAgICBvcGVuQmxvY2sodHJ1ZSAvKiBudWxsIGJsb2NrIHRoYXQgZGlzYWJsZXMgdHJhY2tpbmcgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcclxuICAgICAgICBjb25zdCByZXMgPSBmbiguLi5hcmdzKTtcclxuICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uob3duZXIpO1xyXG4gICAgICAgIGlmICghaXNSZW5kZXJpbmdDb21waWxlZFNsb3QpIHtcclxuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XHJcbn1cblxuLy8gU0ZDIHNjb3BlZCBzdHlsZSBJRCBtYW5hZ2VtZW50LlxyXG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG5jb25zdCBzY29wZUlkU3RhY2sgPSBbXTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xyXG4gICAgc2NvcGVJZFN0YWNrLnB1c2goKGN1cnJlbnRTY29wZUlkID0gaWQpKTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XHJcbiAgICBzY29wZUlkU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IHNjb3BlSWRTdGFja1tzY29wZUlkU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhTY29wZUlkKGlkKSB7XHJcbiAgICByZXR1cm4gKChmbikgPT4gd2l0aEN0eChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHVzaFNjb3BlSWQoaWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcG9wU2NvcGVJZCgpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9KSk7XHJcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgLy8gcmVzdWx0IG9mIGJpdHdpc2UgZmxhZyBjb21wYXJpc29uXHJcbmlzU1NSID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHByb3BzID0ge307XHJcbiAgICBjb25zdCBhdHRycyA9IHt9O1xyXG4gICAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XHJcbiAgICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xyXG4gICAgLy8gdmFsaWRhdGlvblxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmIChpc1N0YXRlZnVsKSB7XHJcbiAgICAgICAgLy8gc3RhdGVmdWxcclxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gb3B0aW9uYWwgcHJvcHMsIHByb3BzID09PSBhdHRyc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBkZWNsYXJlZCBwcm9wc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wcywgYXR0cnMsIHZub2RlOiB7IHBhdGNoRmxhZyB9IH0gPSBpbnN0YW5jZTtcclxuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGlmIChcclxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XHJcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxyXG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcclxuICAgICEoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgKGluc3RhbmNlLnR5cGUuX19obXJJZCB8fFxyXG4gICAgICAgICAgICAoaW5zdGFuY2UucGFyZW50ICYmIGluc3RhbmNlLnBhcmVudC50eXBlLl9faG1ySWQpKSkgJiZcclxuICAgICAgICAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmXHJcbiAgICAgICAgIShwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXBpbGVyLWdlbmVyYXRlZCBwcm9wcyAmIG5vIGtleXMgY2hhbmdlLCBqdXN0IHNldCB0aGUgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyB0aGUgcHJvcHMuXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgIC8vIFBST1BTIGZsYWcgZ3VhcmFudGVlcyByYXdQcm9wcyB0byBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyIC8gcHJvcHMgc2VwYXJhdGlvbiB3YXMgZG9uZSBvbiBpbml0IGFuZCB3aWxsIGJlIGNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNvZGUgcGF0aCwgc28ganVzdCBjaGVjayBpZiBhdHRycyBoYXZlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBjYW1lbGl6ZWRLZXksIHZhbHVlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZnVsbCBwcm9wcyB1cGRhdGUuXHJcbiAgICAgICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcclxuICAgICAgICAvLyBpbiBjYXNlIG9mIGR5bmFtaWMgcHJvcHMsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIGtleXMgZnJvbVxyXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcclxuICAgICAgICBsZXQga2ViYWJLZXk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcclxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXHJcbiAgICAgICAgICAgICAgICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3UHJvcHMgfHwgRU1QVFlfT0JKLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bmN0aW9uYWwgY29tcG9uZW50IHcvbyBwcm9wcyBkZWNsYXJhdGlvbiwgcHJvcHMgYW5kXHJcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHRyaWdnZXIgdXBkYXRlcyBmb3IgJGF0dHJzIGluIGNhc2UgaXQncyB1c2VkIGluIGNvbXBvbmVudCBzbG90c1xyXG4gICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiAvKiBTRVQgKi8sICckYXR0cnMnKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcmF3UHJvcHMpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XHJcbiAgICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcCBvcHRpb24gbmFtZXMgYXJlIGNhbWVsaXplZCBkdXJpbmcgbm9ybWFsaXphdGlvbiwgc28gdG8gc3VwcG9ydFxyXG4gICAgICAgICAgICAvLyBrZWJhYiAtPiBjYW1lbCBjb252ZXJzaW9uIGhlcmUgd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUga2V5LlxyXG4gICAgICAgICAgICBsZXQgY2FtZWxLZXk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAoY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFueSBub24tZGVjbGFyZWQgKGVpdGhlciBhcyBhIHByb3Agb3IgYW4gZW1pdHRlZCBldmVudCkgcHJvcHMgYXJlIHB1dFxyXG4gICAgICAgICAgICAgICAgLy8gaW50byBhIHNlcGFyYXRlIGBhdHRyc2Agb2JqZWN0IGZvciBzcHJlYWRpbmcuIE1ha2Ugc3VyZSB0byBwcmVzZXJ2ZVxyXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwga2V5IGNhc2luZ1xyXG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRDYXN0S2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCByYXdDdXJyZW50UHJvcHNba2V5XSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgaWYgKG9wdCAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXNcclxuICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xyXG4gICAgICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093bihwcm9wcywga2V5KSAmJiAhaGFzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiZcclxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGlmICghYXBwQ29udGV4dC5kZW9wdCAmJiBjb21wLl9fcHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gY29tcC5fX3Byb3BzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChrZXlzKVxyXG4gICAgICAgICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2goLi4ua2V5cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIHJldHVybiAoY29tcC5fX3Byb3BzID0gRU1QVFlfQVJSKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyYXcpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IChub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID1cclxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IG9wdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wIG5lZWRzIGJvb2xlYW4gY2FzdGluZyBvciBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoY29tcC5fX3Byb3BzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c10pO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XHJcbiAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXHJcbi8vIHNvIHRoYXQgaXQgd29ya3MgYWNyb3NzIHZtcyAvIGlmcmFtZXMuXHJcbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHByb3BzLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcmF3VmFsdWVzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIGlmIChvcHQgPT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wKGtleSwgcmF3VmFsdWVzW2tleV0sIG9wdCwgIWhhc093bihyYXdWYWx1ZXMsIGtleSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yIH0gPSBwcm9wO1xyXG4gICAgLy8gcmVxdWlyZWQhXHJcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcclxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtaXNzaW5nIGJ1dCBvcHRpb25hbFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0eXBlIGNoZWNrXHJcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xyXG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xyXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIGxldCB2YWxpZDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcclxuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcclxuICAgICAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xyXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpfWA7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXHJcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXHJcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xyXG4gICAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XHJcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xyXG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xyXG4gICAgICAgIC8vIGNhY2hlIHRoZSBlcnJvciBoYW5kbGluZyB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZSBob29rXHJcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXHJcbiAgICAgICAgLy8gaGFuZGxpbmdcIi5cclxuICAgICAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHxcclxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50SW5zdGFuY2UgZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgaG9vayBkb2VzIG5vdCBzeW5jaHJvbm91c2x5IHRyaWdnZXIgb3RoZXIgaG9va3MsIHdoaWNoXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcmVwZW5kKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cmFwcGVkSG9vaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5nc1t0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCAnJykpO1xyXG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcclxuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXHJcbiAgICAgICAgICAgIGBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArXHJcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxyXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUlxyXG4haXNJblNTUkNvbXBvbmVudFNldHVwICYmIGluamVjdEhvb2sobGlmZWN5Y2xlLCBob29rLCB0YXJnZXQpO1xyXG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIgLyogQkVGT1JFX01PVU5UICovKTtcclxuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIiAvKiBNT1VOVEVEICovKTtcclxuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFwiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovKTtcclxuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIiAvKiBVUERBVEVEICovKTtcclxuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovKTtcclxuY29uc3Qgb25Vbm1vdW50ZWQgPSBjcmVhdGVIb29rKFwidW1cIiAvKiBVTk1PVU5URUQgKi8pO1xyXG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovKTtcclxuY29uc3Qgb25FcnJvckNhcHR1cmVkID0gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xyXG4gICAgaW5qZWN0SG9vayhcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi8sIGhvb2ssIHRhcmdldCk7XHJcbn07XG5cbi8vIFNpbXBsZSBlZmZlY3QuXHJcbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcclxufVxyXG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xyXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcclxuICAgICAgICB3YXJuKGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcclxuICAgICAgICAgICAgYHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25UcmFjaywgb25UcmlnZ2VyIH0gPSBFTVBUWV9PQkosIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsIHMsIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBgICtcclxuICAgICAgICAgICAgYGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gKTtcclxuICAgIH07XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gISFzb3VyY2UuX3NoYWxsb3c7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLywgW1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLywgW1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHlcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbb25JbnZhbGlkYXRlXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gTk9PUDtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcclxuICAgIH1cclxuICAgIGlmIChjYiAmJiBkZWVwKSB7XHJcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNsZWFudXA7XHJcbiAgICBjb25zdCBvbkludmFsaWRhdGUgPSAoZm4pID0+IHtcclxuICAgICAgICBjbGVhbnVwID0gcnVubmVyLm9wdGlvbnMub25TdG9wID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0IC8qIFdBVENIX0NMRUFOVVAgKi8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgbGV0IG9sZFZhbHVlID0gaXNBcnJheShzb3VyY2UpID8gW10gOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XHJcbiAgICBjb25zdCBqb2IgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFydW5uZXIuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcnVubmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdW5kZWZpbmVkIDogb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25JbnZhbGlkYXRlXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XHJcbiAgICAgICAgICAgIHJ1bm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBpbXBvcnRhbnQ6IG1hcmsgdGhlIGpvYiBhcyBhIHdhdGNoZXIgY2FsbGJhY2sgc28gdGhhdCBzY2hlZHVsZXIga25vd3NcclxuICAgIC8vIGl0IGlzIGFsbG93ZWQgdG8gc2VsZi10cmlnZ2VyICgjMTcyNylcclxuICAgIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xyXG4gICAgbGV0IHNjaGVkdWxlcjtcclxuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gam9iO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRlZmF1bHQ6ICdwcmUnXHJcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8IGluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQcmVGbHVzaENiKGpvYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aXRoICdwcmUnIG9wdGlvbiwgdGhlIGZpcnN0IGNhbGwgbXVzdCBoYXBwZW4gYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgc28gaXQgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkuXHJcbiAgICAgICAgICAgICAgICBqb2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW5uZXIgPSBlZmZlY3QoZ2V0dGVyLCB7XHJcbiAgICAgICAgbGF6eTogdHJ1ZSxcclxuICAgICAgICBvblRyYWNrLFxyXG4gICAgICAgIG9uVHJpZ2dlcixcclxuICAgICAgICBzY2hlZHVsZXJcclxuICAgIH0pO1xyXG4gICAgcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChydW5uZXIsIGluc3RhbmNlKTtcclxuICAgIC8vIGluaXRpYWwgcnVuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSBydW5uZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHJ1bm5lciwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcnVubmVyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHN0b3AocnVubmVyKTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmVtb3ZlKGluc3RhbmNlLmVmZmVjdHMsIHJ1bm5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyB0aGlzLiR3YXRjaFxyXG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xyXG4gICAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKVxyXG4gICAgICAgID8gKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdXHJcbiAgICAgICAgOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzKTtcclxuICAgIHJldHVybiBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucywgdGhpcyk7XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIHNlZW4gPSBuZXcgU2V0KCkpIHtcclxuICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHNlZW4uaGFzKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNlZW4uYWRkKHZhbHVlKTtcclxuICAgIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcclxuICAgIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNMZWF2aW5nOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGxlYXZpbmdWTm9kZXM6IG5ldyBNYXAoKVxyXG4gICAgfTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbn1cclxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcclxuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xyXG4gICAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbW9kZTogU3RyaW5nLFxyXG4gICAgICAgIGFwcGVhcjogQm9vbGVhbixcclxuICAgICAgICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXHJcbiAgICAgICAgLy8gZW50ZXJcclxuICAgICAgICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGxlYXZlXHJcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBhcHBlYXJcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYWNrIHJlYWN0aXZpdHkgZm9yIHRoZXNlIHByb3BzIHNvIHVzZSB0aGUgcmF3XHJcbiAgICAgICAgICAgIC8vIHByb3BzIGZvciBhIGJpdCBiZXR0ZXIgcGVyZlxyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgbW9kZVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1vZGUgJiYgIVsnaW4tb3V0JywgJ291dC1pbicsICdkZWZhdWx0J10uaW5jbHVkZXMobW9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGNoaWxkcmVuIGhhcyBhIGd1YXJhbnRlZWQgbGVuZ3RoIG9mIDEuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0S2VlcEFsaXZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcclxuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbktleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXHJcbiAgICAgICAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmXHJcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiZcclxuICAgICAgICAgICAgICAgICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvbGQgdHJlZSdzIGhvb2tzIGluIGNhc2Ugb2YgZHluYW1pYyB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBiZXR3ZWVuIGRpZmZlcmVudCB2aWV3c1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCBvbGRJbm5lckNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFybHkgcmVtb3ZhbCBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xyXG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xyXG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcclxuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcclxuICAgIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcclxufVxyXG4vLyBUaGUgdHJhbnNpdGlvbiBob29rcyBhcmUgYXR0YWNoZWQgdG8gdGhlIHZub2RlIGFzIHZub2RlLnRyYW5zaXRpb25cclxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgYXBwZWFyLCBtb2RlLCBwZXJzaXN0ZWQgPSBmYWxzZSwgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25BZnRlckVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkJlZm9yZUxlYXZlLCBvbkxlYXZlLCBvbkFmdGVyTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyLCBvbkFwcGVhciwgb25BZnRlckFwcGVhciwgb25BcHBlYXJDYW5jZWxsZWQgfSA9IHByb3BzO1xyXG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XHJcbiAgICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgaG9vayAmJlxyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGhvb2tzID0ge1xyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgcGVyc2lzdGVkLFxyXG4gICAgICAgIGJlZm9yZUVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3Igc2FtZSBlbGVtZW50ICh2LXNob3cpXHJcbiAgICAgICAgICAgIGlmIChlbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciB0b2dnbGVkIGVsZW1lbnQgd2l0aCBzYW1lIGtleSAodi1pZilcclxuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBlYXJseSByZW1vdmFsIChub3QgY2FuY2VsbGVkKVxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2VudGVyQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAgICAgaG9vayhlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVhdmUoZWwsIHJlbW92ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzVW5tb3VudGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9IHZub2RlO1xyXG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgb25MZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob25MZWF2ZS5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmUodm5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gaG9va3M7XHJcbn1cclxuLy8gdGhlIHBsYWNlaG9sZGVyIHJlYWxseSBvbmx5IGhhbmRsZXMgb25lIHNwZWNpYWwgY2FzZTogS2VlcEFsaXZlXHJcbi8vIGluIHRoZSBjYXNlIG9mIGEgS2VlcEFsaXZlIGluIGEgbGVhdmUgcGhhc2Ugd2UgbmVlZCB0byByZXR1cm4gYSBLZWVwQWxpdmVcclxuLy8gcGxhY2Vob2xkZXIgd2l0aCBlbXB0eSBjb250ZW50IHRvIGF2b2lkIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZnJvbSBiZWluZ1xyXG4vLyB1bm1vdW50ZWQuXHJcbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcclxuICAgIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcclxuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcclxuICAgIHJldHVybiBpc0tlZXBBbGl2ZSh2bm9kZSlcclxuICAgICAgICA/IHZub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgID8gdm5vZGUuY2hpbGRyZW5bMF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgICA6IHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyAmJiB2bm9kZS5jb21wb25lbnQpIHtcclxuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcclxuICAgICAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UpIHtcclxuICAgIGxldCByZXQgPSBbXTtcclxuICAgIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLylcclxuICAgICAgICAgICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29tbWVudCBwbGFjZWhvbGRlcnMgc2hvdWxkIGJlIHNraXBwZWQsIGUuZy4gdi1pZlxyXG4gICAgICAgIGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICMxMTI2IGlmIGEgdHJhbnNpdGlvbiBjaGlsZHJlbiBsaXN0IGNvbnRhaW5zIG11bHRpcGxlIHN1YiBmcmFnbWVudHMsIHRoZXNlXHJcbiAgICAvLyBmcmFnbWVudHMgd2lsbCBiZSBtZXJnZWQgaW50byBhIGZsYXQgY2hpbGRyZW4gYXJyYXkuIFNpbmNlIGVhY2ggdi1mb3JcclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXHJcbiAgICAvLyB0aGVzZSBjaGlsZHJlbiB0byBmb3JjZSBmdWxsIGRpZmZzIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLlxyXG4gICAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTIgLyogQkFJTCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XHJcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XHJcbiAgICBuYW1lOiBgS2VlcEFsaXZlYCxcclxuICAgIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XHJcbiAgICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxyXG4gICAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxyXG4gICAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXHJcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcclxuICAgICAgICAvLyBLZWVwQWxpdmUgY29tbXVuaWNhdGVzIHdpdGggdGhlIGluc3RhbnRpYXRlZCByZW5kZXJlciB2aWEgdGhlXHJcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcclxuICAgICAgICAvLyBhbmQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBleHBvc2VzIGFjdGl2YXRlL2RlYWN0aXZhdGUgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgIC8vIFRoZSB3aG9sZSBwb2ludCBvZiB0aGlzIGlzIHRvIGF2b2lkIGltcG9ydGluZyBLZWVwQWxpdmUgZGlyZWN0bHkgaW4gdGhlXHJcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXHJcbiAgICAgICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcclxuICAgICAgICBjb25zdCB7IHJlbmRlcmVyOiB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogX3VubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gfSA9IHNoYXJlZENvbnRleHQ7XHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICBwYXRjaChpbnN0YW5jZS52bm9kZSwgdm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5hKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEgLyogTEVBVkUgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc2hhcGVGbGFnIHNvIGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IGNhY2hlZC50eXBlICE9PSBjdXJyZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBpbnN0YW5jZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGtlcHQtYWxpdmUuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1bm1vdW50IGl0IG5vdyBidXQgaXQgbWlnaHQgYmUgbGF0ZXIsIHNvIHJlc2V0IGl0cyBmbGFnIG5vdy5cclxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcnVuZSBjYWNoZSBvbiBpbmNsdWRlL2V4Y2x1ZGUgcHJvcCBjaGFuZ2VcclxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcclxuICAgICAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgIHsgZmx1c2g6ICdwb3N0JywgZGVlcDogdHJ1ZSB9KTtcclxuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcclxuICAgICAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goY2FjaGVkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXApO1xyXG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgLy8gY2xvbmUgdm5vZGUgaWYgaXQncyByZXVzZWQgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gbXV0YXRlIGl0XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAjMTUxMyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgcmV0dXJuZWQgdm5vZGUgdG8gYmUgY2xvbmVkIGR1ZSB0byBhdHRyXHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xyXG4gICAgICAgICAgICAvLyBrZXkgYW5kIGNhY2hlIGBpbnN0YW5jZS5zdWJUcmVlYCAodGhlIG5vcm1hbGl6ZWQgdm5vZGUpIGluXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcclxuICAgICAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMga2V5IHRoZSBmcmVzaGVzdFxyXG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xyXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcclxuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0dGVybi50ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIERFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIC8vIGNhY2hlIHRoZSBkZWFjdGl2YXRlIGJyYW5jaCBjaGVjayB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZVxyXG4gICAgLy8gaG9vayBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2RjXCIgc3RhbmRzIGZvciBcIndpdGhcclxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxyXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8XHJcbiAgICAgICAgKGhvb2suX193ZGMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvb2soKTtcclxuICAgICAgICB9KTtcclxuICAgIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XHJcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcclxuICAgIC8vIGNoYWluIGFuZCByZWdpc3RlciBpdCBvbiBhbGwgYW5jZXN0b3IgaW5zdGFuY2VzIHRoYXQgYXJlIGtlZXAtYWxpdmUgcm9vdHMuXHJcbiAgICAvLyBUaGlzIGF2b2lkcyB0aGUgbmVlZCB0byB3YWxrIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUgd2hlbiBpbnZva2luZyB0aGVzZVxyXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxyXG4gICAgLy8gYXJyYXlzLlxyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XHJcbiAgICAvLyBpbmplY3RIb29rIHdyYXBzIHRoZSBvcmlnaW5hbCBmb3IgZXJyb3IgaGFuZGxpbmcsIHNvIG1ha2Ugc3VyZSB0byByZW1vdmVcclxuICAgIC8vIHRoZSB3cmFwcGVkIHZlcnNpb24uXHJcbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcclxuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xyXG4gICAgfSwgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xyXG4gICAgbGV0IHNoYXBlRmxhZyA9IHZub2RlLnNoYXBlRmxhZztcclxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLztcclxuICAgIH1cclxuICAgIHZub2RlLnNoYXBlRmxhZyA9IHNoYXBlRmxhZztcclxufVxyXG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XHJcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gJ18nIHx8IGtleSA9PT0gJyRzdGFibGUnO1xyXG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpXHJcbiAgICA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSlcclxuICAgIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XHJcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHdpdGhDdHgoKHByb3BzKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHdhcm4oYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogYCArXHJcbiAgICAgICAgICAgIGB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBgICtcclxuICAgICAgICAgICAgYEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KHByb3BzKSk7XHJcbn0sIGN0eCk7XHJcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cykgPT4ge1xyXG4gICAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XHJcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSkge1xyXG4gICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBgICtcclxuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XHJcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgLy8gbWFrZSBjb21waWxlciBtYXJrZXIgbm9uLWVudW1lcmFibGVcclxuICAgICAgICAgICAgZGVmKGNoaWxkcmVuLCAnXycsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIChpbnN0YW5jZS5zbG90cyA9IHt9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlZihpbnN0YW5jZS5zbG90cywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG59O1xyXG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XHJcbiAgICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gY29tcGlsZWQgc2xvdHMuXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IHdhcyBITVIgdXBkYXRlZCBzbyBzbG90IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBzbG90cyBhbmQgbWFyayBpbnN0YW5jZSBmb3IgaG1yIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBBTkQgc3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUsIGFuZCBza2lwIHN0YWxlIHNsb3RzIHJlbW92YWwuXHJcbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgYnV0IGR5bmFtaWMgKHYtaWYvdi1mb3Igb24gc2xvdHMpIC0gdXBkYXRlIHNsb3RzLCBidXQgc2tpcFxyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gbm9uIHNsb3Qgb2JqZWN0IGNoaWxkcmVuIChkaXJlY3QgdmFsdWUpIHBhc3NlZCB0byBhIGNvbXBvbmVudFxyXG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcclxuICAgIH1cclxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xyXG4gICAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbi8qKlxyXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxyXG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcclxuY29uc3QgZm9vID0gcmVzb2x2ZURpcmVjdGl2ZSgnZm9vJylcclxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcclxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xyXG4gIFtmb28sIHRoaXMueF0sXHJcbiAgW2JhciwgdGhpcy55XVxyXG5dKVxyXG4qL1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xyXG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcclxuICAgICAgICAgICAgZGlyID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRlZDogZGlyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogZGlyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJpbmRpbmdzLnB1c2goe1xyXG4gICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XHJcbiAgICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XHJcbiAgICAgICAgaWYgKG9sZEJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xyXG4gICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4IC8qIERJUkVDVElWRV9IT09LICovLCBbXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCxcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICAgIHByZXZWTm9kZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXBwOiBudWxsLFxyXG4gICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICBpc05hdGl2ZVRhZzogTk8sXHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXHJcbiAgICAgICAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXHJcbiAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudDogTk8sXHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB3YXJuSGFuZGxlcjogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXhpbnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHt9LFxyXG4gICAgICAgIHByb3ZpZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXHJcbiAgICB9O1xyXG59XHJcbmxldCB1aWQgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcclxuICAgICAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xyXG4gICAgICAgICAgICByb290UHJvcHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IChjb250ZXh0LmFwcCA9IHtcclxuICAgICAgICAgICAgX3VpZDogdWlkKyssXHJcbiAgICAgICAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXHJcbiAgICAgICAgICAgIF9wcm9wczogcm9vdFByb3BzLFxyXG4gICAgICAgICAgICBfY29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgICAgICBfY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgdmVyc2lvbixcclxuICAgICAgICAgICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IGNvbmZpZyh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1peGluKG1peGluKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnbG9iYWwgbWl4aW4gd2l0aCBwcm9wcy9lbWl0cyBkZS1vcHRpbWl6ZXMgcHJvcHMvZW1pdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiBjYWNoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW4ucHJvcHMgfHwgbWl4aW4uZW1pdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGVvcHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6ICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwIGNvbnRleHQgb24gdGhlIHJvb3QgVk5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHNldCBvbiB0aGUgcm9vdCBpbnN0YW5jZSBvbiBpbml0aWFsIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhNUiByb290IHJlbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50LnByb3h5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5tb3VudCgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IGFsbG93IHN5bWJvbHMgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNDU4N1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgIH07XHJcbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XHJcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gL3N2Zy8udGVzdChjb250YWluZXIubmFtZXNwYWNlVVJJKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDT01NRU5UICovO1xyXG4vLyBOb3RlOiBoeWRyYXRpb24gaXMgRE9NLXNwZWNpZmljXHJcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xyXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4vLyBIeWRyYXRpb24gYWxzbyBkZXBlbmRzIG9uIHNvbWUgcmVuZGVyZXIgaW50ZXJuYWwgbG9naWMgd2hpY2ggbmVlZHMgdG8gYmVcclxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBtdDogbW91bnRDb21wb25lbnQsIHA6IHBhdGNoLCBvOiB7IHBhdGNoUHJvcCwgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHJlbW92ZSwgaW5zZXJ0LCBjcmVhdGVDb21tZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBpZiAoaGFzTWlzbWF0Y2ggJiYgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgZXJyb3Igc2hvdWxkIHNob3cgdXAgaW4gcHJvZHVjdGlvblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XHJcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc0ZyYWdtZW50U3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGNvbnN0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xyXG4gICAgICAgIHZub2RlLmVsID0gbm9kZTtcclxuICAgICAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMyAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gQ2xpZW50OiAke0pTT04uc3RyaW5naWZ5KG5vZGUuZGF0YSl9YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLyB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgYW5jaG9yLCBhZG9wdCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0aWMgdm5vZGUgaGFzIGl0cyBjb250ZW50IHN0cmlwcGVkIGR1cmluZyBidWlsZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZG9wdCBpdCBmcm9tIHRoZSBzZXJ2ZXItcmVuZGVyZWQgSFRNTC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUub3V0ZXJIVE1MO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnR5cGUgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyB1cCB0aGUgcmVuZGVyIGVmZmVjdCwgaWYgdGhlIGluaXRpYWwgdm5vZGUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyAuZWwgc2V0LCB0aGUgY29tcG9uZW50IHdpbGwgcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGl0cyBzdWItdHJlZS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkQXN5bmMgPSB2bm9kZS50eXBlLl9fYXN5bmNMb2FkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRBc3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkQXN5bmMoKS50aGVuKGh5ZHJhdGVDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZUNvbXBvbmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGJlIGFzeW5jLCBzbyBpbiB0aGUgY2FzZSBvZiBmcmFnbWVudHMgd2UgY2Fubm90IHJlbHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBjb21wb25lbnQncyByZW5kZXJlZCBvdXRwdXQgdG8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCwgd2UgZG8gYSBsb29rYWhlYWQgdG8gZmluZCB0aGUgZW5kIGFuY2hvciBub2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaXNGcmFnbWVudFN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIocGFyZW50Tm9kZShub2RlKSksIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSG9zdFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gc2tpcCBwcm9wcyAmIGNoaWxkcmVuIGlmIHRoaXMgaXMgaG9pc3RlZCBzdGF0aWMgbm9kZXNcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGltaXplZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiBpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGNsaWNrIGxpc3RlbmVycyAod2hpY2ggaXMgbW9zdCBvZnRlbikgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpbmcgdGhyb3VnaCBwcm9wcy5cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdm5vZGUgLyBkaXJlY3RpdmUgaG9va3NcclxuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxyXG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKGVsLmZpcnN0Q2hpbGQsIHZub2RlLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbltpXVxyXG4gICAgICAgICAgICAgICAgOiAoY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke2NvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgU1NSZWQgRE9NIGRpZG4ndCBjb250YWluIGVub3VnaCBub2Rlcy4gTW91bnQgdGhlIG1pc3Npbmcgb25lcy5cclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcclxuICAgICAgICAgICAgLy8gYmFjay4gVGhpcyBzaG91bGQgaGF2ZSBsZWQgdG8gbm9kZS9jaGlsZHJlbiBtaXNtYXRjaCB3YXJuaW5ncy5cclxuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XHJcbiAgICAgICAgICAgIGluc2VydCgodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApKSwgY29udGFpbmVyLCBuZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc0ZyYWdtZW50KSA9PiB7XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcXG4tIENsaWVudCB2bm9kZTpgLCB2bm9kZS50eXBlLCBgXFxuLSBTZXJ2ZXIgcmVuZGVyZWQgRE9NOmAsIG5vZGUsIG5vZGUubm9kZVR5cGUgPT09IDMgLyogVEVYVCAqL1xyXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxyXG4gICAgICAgICAgICAgICAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWydcclxuICAgICAgICAgICAgICAgICAgICA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYFxyXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xyXG4gICAgICAgIHZub2RlLmVsID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNGcmFnbWVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIHJlbW92ZShub2RlKTtcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpKTtcclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3IgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICdbJylcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xyXG59XG5cbmxldCBzdXBwb3J0ZWQ7XHJcbmxldCBwZXJmO1xyXG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XHJcbiAgICAgICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XHJcbiAgICAgICAgcGVyZi5tYXJrKGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5tZWFzdXJlKGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xyXG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcclxuICAgIH1cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgaW4gZXNtLWJ1bmRsZXIgYnVpbGRzLlxyXG4gKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHJlbmRlcmVyIGlzIGNyZWF0ZWQsIGluIGBiYXNlQ3JlYXRlUmVuZGVyZXJgIHNvIHRoYXRcclxuICogaW1wb3J0aW5nIHJ1bnRpbWUtY29yZSBpcyBzaWRlLWVmZmVjdHMgZnJlZS5cclxuICpcclxuICogaXN0YW5idWwtaWdub3JlLW5leHRcclxuICovXHJcbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XHJcbiAgICBsZXQgbmVlZFdhcm4gPSBmYWxzZTtcclxuICAgIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgbmVlZFdhcm4gPSB0cnVlO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBuZWVkV2FybiA9IHRydWU7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGAgK1xyXG4gICAgICAgICAgICBgY29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBleHBsaWNpdGx5IHJlcGxhY2UgZmVhdHVyZSBmbGFnIGdsb2JhbHMgYCArXHJcbiAgICAgICAgICAgIGB3aXRoIGJvb2xlYW4gbGl0ZXJhbHMgdG8gZ2V0IHByb3BlciB0cmVlLXNoYWtpbmcgaW4gdGhlIGZpbmFsIGJ1bmRsZS4gYCArXHJcbiAgICAgICAgICAgIGBTZWUgaHR0cDovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MgZm9yIG1vcmUgZGV0YWlscy5gKTtcclxuICAgIH1cclxufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcclxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8geyBzZXR1cDogb3B0aW9ucywgbmFtZTogb3B0aW9ucy5uYW1lIH0gOiBvcHRpb25zO1xyXG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxyXG4gICAgc3VzcGVuc2libGUgPSB0cnVlLCBvbkVycm9yOiB1c2VyT25FcnJvciB9ID0gc291cmNlO1xyXG4gICAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgIGxldCByZXNvbHZlZENvbXA7XHJcbiAgICBsZXQgcmV0cmllcyA9IDA7XHJcbiAgICBjb25zdCByZXRyeSA9ICgpID0+IHtcclxuICAgICAgICByZXRyaWVzKys7XHJcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBsb2FkKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcclxuICAgICAgICBsZXQgdGhpc1JlcXVlc3Q7XHJcbiAgICAgICAgcmV0dXJuIChwZW5kaW5nUmVxdWVzdCB8fFxyXG4gICAgICAgICAgICAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9IGxvYWRlcigpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKGNvbXApID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcclxuICAgICAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxyXG4gICAgICAgIG5hbWU6ICdBc3luY0NvbXBvbmVudFdyYXBwZXInLFxyXG4gICAgICAgIHNldHVwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovLCAhZXJyb3JDb21wb25lbnQgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqLyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxyXG4gICAgICAgICAgICBpZiAoKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihjb21wID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCB7IHZub2RlOiB7IHJlZiwgcHJvcHMsIGNoaWxkcmVuIH0gfSkge1xyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgLy8gZW5zdXJlIGlubmVyIGNvbXBvbmVudCBpbmhlcml0cyB0aGUgYXN5bmMgd3JhcHBlcidzIHJlZiBvd25lclxyXG4gICAgdm5vZGUucmVmID0gcmVmO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XG5cbmNvbnN0IHByb2RFZmZlY3RPcHRpb25zID0ge1xyXG4gICAgc2NoZWR1bGVyOiBxdWV1ZUpvYixcclxuICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXHJcbiAgICBhbGxvd1JlY3Vyc2U6IHRydWVcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2RWZmZWN0T3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY2hlZHVsZXI6IHF1ZXVlSm9iLFxyXG4gICAgICAgIGFsbG93UmVjdXJzZTogdHJ1ZSxcclxuICAgICAgICBvblRyYWNrOiBpbnN0YW5jZS5ydGMgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDAsXHJcbiAgICAgICAgb25UcmlnZ2VyOiBpbnN0YW5jZS5ydGcgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDBcclxuICAgIH07XHJcbn1cclxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2VcclxuICAgIDtcclxuY29uc3Qgc2V0UmVmID0gKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpID0+IHtcclxuICAgIGlmIChpc0FycmF5KHJhd1JlZikpIHtcclxuICAgICAgICByYXdSZWYuZm9yRWFjaCgociwgaSkgPT4gc2V0UmVmKHIsIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSwgcGFyZW50U3VzcGVuc2UsIHZub2RlKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbHVlO1xyXG4gICAgaWYgKCF2bm9kZSB8fCBpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2bm9kZS5jb21wb25lbnQuZXhwb3NlZCB8fCB2bm9kZS5jb21wb25lbnQucHJveHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZub2RlLmVsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhb3duZXIpIHtcclxuICAgICAgICB3YXJuKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xyXG4gICAgICAgICAgICBgQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xyXG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcclxuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xyXG4gICAgLy8gdW5zZXQgb2xkIHJlZlxyXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdHJpbmcocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gIzE3ODk6IGZvciBub24tbnVsbCB2YWx1ZXMsIHNldCB0aGVtIGFmdGVyIHJlbmRlclxyXG4gICAgICAgIC8vIG51bGwgdmFsdWVzIG1lYW5zIHRoaXMgaXMgdW5tb3VudCBhbmQgaXQgc2hvdWxkIG5vdCBvdmVyd3JpdGUgYW5vdGhlclxyXG4gICAgICAgIC8vIHJlZiB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyIC8qIEZVTkNUSU9OX1JFRiAqLywgW3ZhbHVlLCByZWZzXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHZhbHVlLCBgKCR7dHlwZW9mIHZhbHVlfSlgKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFRoZSBjcmVhdGVSZW5kZXJlciBmdW5jdGlvbiBhY2NlcHRzIHR3byBnZW5lcmljIGFyZ3VtZW50czpcclxuICogSG9zdE5vZGUgYW5kIEhvc3RFbGVtZW50LCBjb3JyZXNwb25kaW5nIHRvIE5vZGUgYW5kIEVsZW1lbnQgdHlwZXMgaW4gdGhlXHJcbiAqIGhvc3QgZW52aXJvbm1lbnQuIEZvciBleGFtcGxlLCBmb3IgcnVudGltZS1kb20sIEhvc3ROb2RlIHdvdWxkIGJlIHRoZSBET01cclxuICogYE5vZGVgIGludGVyZmFjZSBhbmQgSG9zdEVsZW1lbnQgd291bGQgYmUgdGhlIERPTSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBDdXN0b20gcmVuZGVyZXJzIGNhbiBwYXNzIGluIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyB0eXBlcyBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBjb25zdCB7IHJlbmRlciwgY3JlYXRlQXBwIH0gPSBjcmVhdGVSZW5kZXJlcjxOb2RlLCBFbGVtZW50Pih7XHJcbiAqICAgcGF0Y2hQcm9wLFxyXG4gKiAgIC4uLm5vZGVPcHNcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xyXG59XHJcbi8vIFNlcGFyYXRlIEFQSSBmb3IgY3JlYXRpbmcgaHlkcmF0aW9uLWVuYWJsZWQgcmVuZGVyZXIuXHJcbi8vIEh5ZHJhdGlvbiBsb2dpYyBpcyBvbmx5IHVzZWQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG1ha2luZyBpdFxyXG4vLyB0cmVlLXNoYWthYmxlLlxyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgLy8gY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgY2hlY2tcclxuICAgIHtcclxuICAgICAgICBpbml0RmVhdHVyZUZsYWdzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcclxuICAgICAgICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XHJcbiAgICAgICAgc2V0RGV2dG9vbHNIb29rKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgaW5zZXJ0OiBob3N0SW5zZXJ0LCByZW1vdmU6IGhvc3RSZW1vdmUsIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCwgZm9yY2VQYXRjaFByb3A6IGhvc3RGb3JjZVBhdGNoUHJvcCwgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCwgc2V0VGV4dDogaG9zdFNldFRleHQsIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLCBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLCBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsIGNsb25lTm9kZTogaG9zdENsb25lTm9kZSwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XHJcbiAgICAvLyBOb3RlOiBmdW5jdGlvbnMgaW5zaWRlIHRoaXMgY2xvc3VyZSBzaG91bGQgdXNlIGBjb25zdCB4eHggPSAoKSA9PiB7fWBcclxuICAgIC8vIHN0eWxlIGluIG9yZGVyIHRvIHByZXZlbnQgYmVpbmcgaW5saW5lZCBieSBtaW5pZmllcnMuXHJcbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxyXG4gICAgICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcclxuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG4xID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogQkFJTCAqLykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NGcmFnbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8ICcnKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gc3VwcG9ydCBmb3IgZHluYW1pYyBjb21tZW50c1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV2IC8gSE1SIG9ubHlcclxuICAgICAqL1xyXG4gICAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIC8vIHN0YXRpYyBub2RlcyBhcmUgb25seSBwYXRjaGVkIGR1cmluZyBkZXYgZm9yIEhNUlxyXG4gICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcclxuICAgICAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoZWwpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBuMi50eXBlID09PSAnc3ZnJztcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudEVsZW1lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoRWxlbWVudChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGVsO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBzY29wZUlkLCBwYXRjaEZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHZub2RlLmVsICYmXHJcbiAgICAgICAgICAgIGhvc3RDbG9uZU5vZGUgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgLy8gSWYgYSB2bm9kZSBoYXMgbm9uLW51bGwgZWwsIGl0IG1lYW5zIGl0J3MgYmVpbmcgcmV1c2VkLlxyXG4gICAgICAgICAgICAvLyBPbmx5IHN0YXRpYyB2bm9kZXMgY2FuIGJlIHJldXNlZCwgc28gaXRzIG1vdW50ZWQgRE9NIG5vZGVzIHNob3VsZCBiZVxyXG4gICAgICAgICAgICAvLyBleGFjdGx5IHRoZSBzYW1lLCBhbmQgd2UgY2FuIHNpbXBseSBkbyBhIGNsb25lIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpbiBwcm9kdWN0aW9uIHNpbmNlIGNsb25lZCB0cmVlcyBjYW5ub3QgYmUgSE1SIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q2xvbmVOb2RlKHZub2RlLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudCh2bm9kZS50eXBlLCBpc1NWRywgcHJvcHMgJiYgcHJvcHMuaXMpO1xyXG4gICAgICAgICAgICAvLyBtb3VudCBjaGlsZHJlbiBmaXJzdCwgc2luY2Ugc29tZSBwcm9wcyBtYXkgcmVseSBvbiBjaGlsZCBjb250ZW50XHJcbiAgICAgICAgICAgIC8vIGJlaW5nIGFscmVhZHkgcmVuZGVyZWQsIGUuZy4gYDxzZWxlY3QgdmFsdWU+YFxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbih2bm9kZS5jaGlsZHJlbiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHICYmIHR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jywgb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2NvcGVJZFxyXG4gICAgICAgICAgICBzZXRTY29wZUlkKGVsLCBzY29wZUlkLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192bm9kZScsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzE1ODMgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIG5vdCByZXNvbHZlZCBjYXNlLCBlbnRlciBob29rIHNob3VsZCBjYWxsIHdoZW4gc3VzcGVuc2UgcmVzb2x2ZWRcclxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XHJcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8XHJcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XHJcbiAgICAgICAgICAgIGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgc2NvcGVJZCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChzY29wZUlkKSB7XHJcbiAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmVlT3duZXJJZCA9IHBhcmVudENvbXBvbmVudC50eXBlLl9fc2NvcGVJZDtcclxuICAgICAgICAgICAgLy8gdm5vZGUncyBvd24gc2NvcGVJZCBhbmQgdGhlIGN1cnJlbnQgcGF0Y2hlZCBjb21wb25lbnQncyBzY29wZUlkIGlzXHJcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCAtIHRoaXMgaXMgYSBzbG90IGNvbnRlbnQgbm9kZS5cclxuICAgICAgICAgICAgaWYgKHRyZWVPd25lcklkICYmIHRyZWVPd25lcklkICE9PSBzY29wZUlkKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgdHJlZU93bmVySWQgKyAnLXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHN1YlRyZWUudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcclxuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudENvbXBvbmVudC52bm9kZS5zY29wZUlkLCBwYXJlbnRDb21wb25lbnQudm5vZGUsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IChjaGlsZHJlbltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgY2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcclxuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXHJcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcclxuICAgICAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgYW5kIGNhbiB0YWtlIHRoZSBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxyXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBwcm9wcyBjb250YWluIGR5bmFtaWMga2V5cywgZnVsbCBkaWZmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMiAvKiBDTEFTUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQgLyogU1RZTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnc3R5bGUnLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHByb3AvYXR0ciBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSBkeW5hbWljIGtleXMgbGlrZSA6W2Zvb109XCJiYXJcIiB3aWxsIGNhdXNlIHRoaXMgb3B0aW1pemF0aW9uIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCBuMS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIG9ubHkgZHluYW1pYyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRyk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ3VwZGF0ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUaGUgZmFzdCBwYXRoIGZvciBibG9ja3MuXHJcbiAgICBjb25zdCBwYXRjaEJsb2NrQ2hpbGRyZW4gPSAob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBmYWxsYmFja0NvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY29udGFpbmVyIChwYXJlbnQgZWxlbWVudCkgZm9yIHRoZSBwYXRjaC5cclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gXHJcbiAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XHJcbiAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovXHJcbiAgICAgICAgICAgICAgICA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tDb250YWluZXI7XHJcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIHZub2RlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCB2YWxpZCBwcm9wXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChob3N0Rm9yY2VQYXRjaFByb3AgJiYgaG9zdEZvcmNlUGF0Y2hQcm9wKGVsLCBrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBvbGRQcm9wc1trZXldLCBudWxsLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IChuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50RW5kQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vIGEgZnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBhcnJheSBjaGlsZHJlblxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciwgb3IgaW1wbGljaXRseSBjcmVhdGVkXHJcbiAgICAgICAgICAgIC8vIGZyb20gYXJyYXlzLlxyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIHN0YWJsZSBmcmFnbWVudCAodGVtcGxhdGUgcm9vdCBvciA8dGVtcGxhdGUgdi1mb3I+KSBkb2Vzbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGNoaWxkcmVuIG9yZGVyLCBidXQgaXQgbWF5IGNvbnRhaW4gZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxyXG4gICAgICAgICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cclxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cclxuICAgICAgICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUgLyogc2hhbGxvdyAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXllZCAvIHVua2V5ZWQsIG9yIG1hbnVhbCBmcmFnbWVudHMuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGJsb2NrIHNvIHRoZSBmcmFnbWVudCB3aWxsIG5ldmVyXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKGluaXRpYWxWTm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSkpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IHJlbmRlcmVyIGludGVybmFscyBmb3Iga2VlcEFsaXZlXHJcbiAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNvbHZlIHByb3BzIGFuZCBzbG90cyBmb3Igc2V0dXAgY29udGV4dFxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCgpIGlzIGFzeW5jLiBUaGlzIGNvbXBvbmVudCByZWxpZXMgb24gYXN5bmMgbG9naWMgdG8gYmUgcmVzb2x2ZWRcclxuICAgICAgICAvLyBiZWZvcmUgcHJvY2VlZGluZ1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xyXG4gICAgICAgICAgICAvLyBHaXZlIGl0IGEgcGxhY2Vob2xkZXIgaWYgdGhpcyBpcyBub3QgaHlkcmF0aW9uXHJcbiAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIHNlbGYtZGVmaW5lZCBmYWxsYmFja1xyXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jICYgc3RpbGwgcGVuZGluZyAtIGp1c3QgdXBkYXRlIHByb3BzIGFuZCBzbG90c1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgY29tcG9uZW50IGlzIGFsc28gcXVldWVkLCByZW1vdmUgaXQgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZSB1cGRhdGluZyB0aGUgc2FtZSBjaGlsZCBjb21wb25lbnQgaW4gdGhlIHNhbWUgZmx1c2guXHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS51cGRhdGUgaXMgdGhlIHJlYWN0aXZlIGVmZmVjdCBydW5uZXIuXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gdXBkYXRlIG5lZWRlZC4ganVzdCBjb3B5IG92ZXIgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIC8vIGNyZWF0ZSByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlcmluZ1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSA9IGVmZmVjdChmdW5jdGlvbiBjb21wb25lbnRFZmZlY3QoKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVNb3VudCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlTW91bnRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IChpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVOb2RlKGluaXRpYWxWTm9kZS5lbCwgc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBzdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZU1vdW50ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGEgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChhLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChidSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVVcGRhdGVcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XHJcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRGV2RWZmZWN0T3B0aW9ucyhpbnN0YW5jZSkgOiBwcm9kRWZmZWN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcclxuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcclxuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcclxuICAgICAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbik7XHJcbiAgICAgICAgLy8gcHJvcHMgdXBkYXRlIG1heSBoYXZlIHRyaWdnZXJlZCBwcmUtZmx1c2ggd2F0Y2hlcnMuXHJcbiAgICAgICAgLy8gZmx1c2ggdGhlbSBiZWZvcmUgdGhlIHJlbmRlciB1cGRhdGUuXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyh1bmRlZmluZWQsIGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XHJcbiAgICAgICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICAvLyBmYXN0IHBhdGhcclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGVpdGhlciBmdWxseS1rZXllZCBvciBtaXhlZCAoc29tZSBrZXllZCBzb21lIG5vdClcclxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gdW5rZXllZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hpbGRyZW4gaGFzIDMgcG9zc2liaWxpdGllczogdGV4dCwgYXJyYXkgb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAvLyB0ZXh0IGNoaWxkcmVuIGZhc3QgcGF0aFxyXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gYzEpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR3byBhcnJheXMsIGNhbm5vdCBhc3N1bWUgYW55dGhpbmcsIGRvIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5ldyBjaGlsZHJlbiwganVzdCB1bm1vdW50IG9sZFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyB0ZXh0IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBjaGlsZHJlbiBpcyBhcnJheSBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ldyBpZiBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChjMVtpXSwgbmV4dENoaWxkLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGRcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlLCBmYWxzZSwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGFsbC1rZXllZCBvciBtaXhlZFxyXG4gICAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTsgLy8gcHJldiBlbmRpbmcgaW5kZXhcclxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgLy8gMS4gc3luYyBmcm9tIHN0YXJ0XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpIGQgZVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtpXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBzeW5jIGZyb20gZW5kXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIGQgZSAoYiBjKVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtlMV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUxLS07XHJcbiAgICAgICAgICAgIGUyLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIGNvbW1vbiBzZXF1ZW5jZSArIG1vdW50XHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyAoYSBiKSBjXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gMSwgZTIgPSAyXHJcbiAgICAgICAgLy8gKGEgYilcclxuICAgICAgICAvLyBjIChhIGIpXHJcbiAgICAgICAgLy8gaSA9IDAsIGUxID0gLTEsIGUyID0gMFxyXG4gICAgICAgIGlmIChpID4gZTEpIHtcclxuICAgICAgICAgICAgaWYgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNC4gY29tbW9uIHNlcXVlbmNlICsgdW5tb3VudFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDIsIGUyID0gMVxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyAoYiBjKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IDAsIGUyID0gLTFcclxuICAgICAgICBlbHNlIGlmIChpID4gZTIpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDUuIHVua25vd24gc2VxdWVuY2VcclxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXHJcbiAgICAgICAgLy8gW2kgLi4uIGUyICsgMV06IGEgYiBbZSBkIGMgaF0gZiBnXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gNCwgZTIgPSA1XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMxID0gaTsgLy8gcHJldiBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICBjb25zdCBzMiA9IGk7IC8vIG5leHQgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLCBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSwgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMiBsb29wIHRocm91Z2ggb2xkIGNoaWxkcmVuIGxlZnQgdG8gYmUgcGF0Y2hlZCBhbmQgdHJ5IHRvIHBhdGNoXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIG5vZGVzICYgcmVtb3ZlIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50XHJcbiAgICAgICAgICAgIGxldCBqO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55IG5vZGUgaGFzIG1vdmVkXHJcbiAgICAgICAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcclxuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cclxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9sZEluZGV4IGlzIG9mZnNldCBieSArMVxyXG4gICAgICAgICAgICAvLyBhbmQgb2xkSW5kZXggPSAwIGlzIGEgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBuZXcgbm9kZSBoYXNcclxuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cclxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2VcclxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG5ldyBjaGlsZHJlbiBoYXZlIGJlZW4gcGF0Y2hlZCBzbyB0aGlzIGNhbiBvbmx5IGJlIGEgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5LWxlc3Mgbm9kZSwgdHJ5IHRvIGxvY2F0ZSBhIGtleS1sZXNzIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKHByZXZDaGlsZCwgYzJbbmV3SW5kZXhdLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjMgbW92ZSBhbmQgbW91bnRcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2Ugb25seSB3aGVuIG5vZGVzIGhhdmUgbW92ZWRcclxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApXHJcbiAgICAgICAgICAgICAgICA6IEVNUFRZX0FSUjtcclxuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIC8vIGxvb3BpbmcgYmFja3dhcmRzIHNvIHRoYXQgd2UgY2FuIHVzZSBsYXN0IHBhdGNoZWQgbm9kZSBhcyBhbmNob3JcclxuICAgICAgICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzdGFibGUgc3Vic2VxdWVuY2UgKGUuZy4gYSByZXZlcnNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SIGN1cnJlbnQgbm9kZSBpcyBub3QgYW1vbmcgdGhlIHN0YWJsZSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcclxuICAgICAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyIC8qIFJFT1JERVIgKi8gJiZcclxuICAgICAgICAgICAgc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb247XHJcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBFTlRFUiAqLykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmUgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIHNoYXBlRmxhZywgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyB1bnNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgZGlycztcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XHJcbiAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZVVubW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcclxuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggZm9yIGJsb2NrIG5vZGVzOiBvbmx5IG5lZWQgdG8gdW5tb3VudCBkeW5hbWljIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGR5bmFtaWNDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgKHBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSkgfHxcclxuICAgICAgICAgICAgICAgICghb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbiB1bm1vdW50ZWQgdGVsZXBvcnQgc2hvdWxkIGFsd2F5cyByZW1vdmUgaXRzIGNoaWxkcmVuIGlmIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKHZub2RlLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxyXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShlbmQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJ1bSwgZWZmZWN0cywgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gYmVmb3JlVW5tb3VudCBob29rXHJcbiAgICAgICAgaWYgKGJ1bSkge1xyXG4gICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0b3AoZWZmZWN0c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgc3RvcCh1cGRhdGUpO1xyXG4gICAgICAgICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgIGlmICh1bSkge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5fdm5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoKGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGludGVybmFscyA9IHtcclxuICAgICAgICBwOiBwYXRjaCxcclxuICAgICAgICB1bTogdW5tb3VudCxcclxuICAgICAgICBtOiBtb3ZlLFxyXG4gICAgICAgIHI6IHJlbW92ZSxcclxuICAgICAgICBtdDogbW91bnRDb21wb25lbnQsXHJcbiAgICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXHJcbiAgICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXHJcbiAgICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXHJcbiAgICAgICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxyXG4gICAgICAgIG86IG9wdGlvbnNcclxuICAgIH07XHJcbiAgICBsZXQgaHlkcmF0ZTtcclxuICAgIGxldCBoeWRyYXRlTm9kZTtcclxuICAgIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcclxuICAgICAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKGludGVybmFscyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbmRlcixcclxuICAgICAgICBoeWRyYXRlLFxyXG4gICAgICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcgLyogVk5PREVfSE9PSyAqLywgW1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHByZXZWTm9kZVxyXG4gICAgXSk7XHJcbn1cclxuLyoqXHJcbiAqICMxMTU2XHJcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgSE1SLWVuYWJsZWQsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHN0YXRpYyBub2Rlc1xyXG4gKiBpbnNpZGUgYSBibG9jayBhbHNvIGluaGVyaXQgdGhlIERPTSBlbGVtZW50IGZyb20gdGhlIHByZXZpb3VzIHRyZWUgc28gdGhhdFxyXG4gKiBITVIgdXBkYXRlcyAod2hpY2ggYXJlIGZ1bGwgdXBkYXRlcykgY2FuIHJldHJpZXZlIHRoZSBlbGVtZW50IGZvciBwYXRjaGluZy5cclxuICpcclxuICogIzIwODBcclxuICogSW5zaWRlIGtleWVkIGB0ZW1wbGF0ZWAgZnJhZ21lbnQgc3RhdGljIGNoaWxkcmVuLCBpZiBhIGZyYWdtZW50IGlzIG1vdmVkLFxyXG4gKiB0aGUgY2hpbGRyZW4gd2lsbCBhbHdheXMgbW92ZWQgc28gdGhhdCBuZWVkIGluaGVyaXQgZWwgZm9ybSBwcmV2aW91cyBub2Rlc1xyXG4gKiB0byBlbnN1cmUgY29ycmVjdCBtb3ZlZCBwb3NpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XHJcbiAgICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBjYWxsZWQgaW4gdGhlIG9wdGltaXplZCBwYXRoIHNvIGFycmF5IGNoaWxkcmVuIGFyZVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIGJlIHZub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2gyW2ldO1xyXG4gICAgICAgICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNoYWxsb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gaW5oZXJpdCBmb3IgY29tbWVudCBub2RlcywgYnV0IG5vdCBwbGFjZWhvbGRlcnMgKGUuZy4gdi1pZiB3aGljaFxyXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlIHJlY2VpdmVkIC5lbCBkdXJpbmcgYmxvY2sgcGF0Y2gpXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcclxuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXHJcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xyXG4gICAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xyXG4gICAgbGV0IGksIGosIHUsIHYsIGM7XHJcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJySSA9IGFycltpXTtcclxuICAgICAgICBpZiAoYXJySSAhPT0gMCkge1xyXG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgIHBbaV0gPSBqO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1ID0gMDtcclxuICAgICAgICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAodSA8IHYpIHtcclxuICAgICAgICAgICAgICAgIGMgPSAoKHUgKyB2KSAvIDIpIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gYyArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdFt1XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1ID0gcmVzdWx0Lmxlbmd0aDtcclxuICAgIHYgPSByZXN1bHRbdSAtIDFdO1xyXG4gICAgd2hpbGUgKHUtLSA+IDApIHtcclxuICAgICAgICByZXN1bHRbdV0gPSB2O1xyXG4gICAgICAgIHYgPSBwW3ZdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xyXG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gJycpO1xyXG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xyXG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XHJcbiAgICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XHJcbiAgICAgICAgaWYgKCFzZWxlY3QpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcclxuICAgIF9faXNUZWxlcG9ydDogdHJ1ZSxcclxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuY2hvcnMgaW4gdGhlIG1haW4gdmlld1xyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChuMi5lbCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBzdGFydCcpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IChuMi5hbmNob3IgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tbWVudCgndGVsZXBvcnQgZW5kJylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gKG4yLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIC8vICMyNjUyIHdlIGNvdWxkIGJlIHRlbGVwb3J0aW5nIGZyb20gYSBub24tU1ZHIHRyZWUgaW50byBhbiBTVkcgdHJlZVxyXG4gICAgICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCAqYWx3YXlzKiBoYXMgQXJyYXkgY2hpbGRyZW4uIFRoaXMgaXMgZW5mb3JjZWQgaW4gYm90aCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVyIGFuZCB2bm9kZSBjaGlsZHJlbiBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gbjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IG4xLnRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcclxuICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAobjIuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggd2hlbiB0aGUgdGVsZXBvcnQgaGFwcGVucyB0byBiZSBhIGJsb2NrIHJvb3RcclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIG4yLmR5bmFtaWNDaGlsZHJlbiwgY3VycmVudENvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSB0ZWxlcG9ydCBpbmhlcml0IHByZXZpb3VzIERPTSByZWZlcmVuY2VzIHNvIHRoYXQgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCAtPiBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byB0ZWxlcG9ydCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmUodm5vZGUsIHsgcjogcmVtb3ZlLCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0pIHtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciB9ID0gdm5vZGU7XHJcbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxyXG59O1xyXG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFJFT1JERVIgKi8pIHtcclxuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cclxuICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBUQVJHRVRfQ0hBTkdFICovKSB7XHJcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBSRU9SREVSICovO1xyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoaXMgaXMgYSByZS1vcmRlciBhbmQgdGVsZXBvcnQgaXMgZW5hYmxlZCAoY29udGVudCBpcyBpbiB0YXJnZXQpXHJcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xyXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXHJcbiAgICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH0gfSwgaHlkcmF0ZUNoaWxkcmVuKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSAodm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldCh2bm9kZS5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIHRlbGVwb3J0cyByZW5kZXJlZCB0byB0aGUgc2FtZSB0YXJnZXQgZWxlbWVudCwgd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vIHBpY2sgdXAgZnJvbSB3aGVyZSB0aGUgbGFzdCB0ZWxlcG9ydCBmaW5pc2hlZCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBub2RlXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgcGFyZW50Tm9kZShub2RlKSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbih0YXJnZXROb2RlLCB2bm9kZSwgdGFyZ2V0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcclxufVxyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcclxuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSkgfHwgbmFtZTtcclxufVxyXG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKCk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaW52YWxpZCB0eXBlcyB3aWxsIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZVZOb2RlIGFuZCByYWlzZSB3YXJuaW5nXHJcbiAgICAgICAgcmV0dXJuIChjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgICAgICAvLyBzZWxmIG5hbWUgaGFzIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIHNlbGYgcmVmZXJlbmNpbmcgY2FsbCBnZW5lcmF0ZWQgYnkgY29tcGlsZXJcclxuICAgICAgICAgICAgLy8gaW5mZXJyZWQgZnJvbSBTRkMgZmlsZW5hbWVcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IGBfc2VsZmApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChzZWxmTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgKHNlbGZOYW1lID09PSBuYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBcclxuICAgICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCBmb3IgY29tcG9uZW50cyB3aXRoIG1peGluIG9yIGV4dGVuZHMuXHJcbiAgICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBgICtcclxuICAgICAgICAgICAgYGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKHJlZ2lzdHJ5ICYmXHJcbiAgICAgICAgKHJlZ2lzdHJ5W25hbWVdIHx8XHJcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pKTtcclxufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnRnJhZ21lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgVGV4dCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnVGV4dCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBDb21tZW50ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdDb21tZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XHJcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XHJcbi8vIGNoYW5nZSwgb25jZSB3ZSBjb25zaWRlciB2LWlmIGJyYW5jaGVzIGFuZCBlYWNoIHYtZm9yIGZyYWdtZW50IGEgYmxvY2ssIHdlXHJcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxyXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xyXG4vLyBhbmQgb25seSB3b3JyeSBhYm91dCB0aGUgZHluYW1pYyBub2RlcyAoaW5kaWNhdGVkIGJ5IHBhdGNoIGZsYWdzKS5cclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuLyoqXHJcbiAqIE9wZW4gYSBibG9jay5cclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxyXG4gKiBiZWNhdXNlIHRoZSBjaGlsZHJlbiBvZiB0aGUgYmxvY2sgYXJlIGV2YWx1YXRlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYCBpdHNlbGZcclxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcclxuICogfVxyXG4gKiBgYGBcclxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXHJcbiAqIGZyYWdtZW50IGFsd2F5cyBkaWZmcyBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcclxuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICAgIGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxyXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcclxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxyXG5sZXQgc2hvdWxkVHJhY2sgPSAxO1xyXG4vKipcclxuICogQmxvY2sgdHJhY2tpbmcgc29tZXRpbWVzIG5lZWRzIHRvIGJlIGRpc2FibGVkLCBmb3IgZXhhbXBsZSBkdXJpbmcgdGhlXHJcbiAqIGNyZWF0aW9uIG9mIGEgdHJlZSB0aGF0IG5lZWRzIHRvIGJlIGNhY2hlZCBieSB2LW9uY2UuIFRoZSBjb21waWxlciBnZW5lcmF0ZXNcclxuICogY29kZSBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBfY2FjaGVbMV0gfHwgKFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoLTEpLFxyXG4gKiAgIF9jYWNoZVsxXSA9IGNyZWF0ZVZOb2RlKC4uLiksXHJcbiAqICAgc2V0QmxvY2tUcmFja2luZygxKSxcclxuICogICBfY2FjaGVbMV1cclxuICogKVxyXG4gKiBgYGBcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcclxuICAgIHNob3VsZFRyYWNrICs9IHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBibG9jayByb290IHZub2RlLiBUYWtlcyB0aGUgc2FtZSBleGFjdCBhcmd1bWVudHMgYXMgYGNyZWF0ZVZOb2RlYC5cclxuICogQSBibG9jayByb290IGtlZXBzIHRyYWNrIG9mIGR5bmFtaWMgbm9kZXMgd2l0aGluIHRoZSBibG9jayBpbiB0aGVcclxuICogYGR5bmFtaWNDaGlsZHJlbmAgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHRydWUgLyogaXNCbG9jazogcHJldmVudCBhIGJsb2NrIGZyb20gdHJhY2tpbmcgaXRzZWxmICovKTtcclxuICAgIC8vIHNhdmUgY3VycmVudCBibG9jayBjaGlsZHJlbiBvbiB0aGUgYmxvY2sgdm5vZGVcclxuICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlI7XHJcbiAgICAvLyBjbG9zZSBibG9ja1xyXG4gICAgY2xvc2VCbG9jaygpO1xyXG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcclxuICAgIC8vIHBhcmVudCBibG9ja1xyXG4gICAgaWYgKHNob3VsZFRyYWNrID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgbjIuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiZcclxuICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG4yLnR5cGUpKSB7XHJcbiAgICAgICAgLy8gSE1SIG9ubHk6IGlmIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaG90LXVwZGF0ZWQsIGZvcmNlIGEgcmVsb2FkLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xyXG59XHJcbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcclxuLyoqXHJcbiAqIEludGVybmFsIEFQSSBmb3IgcmVnaXN0ZXJpbmcgYW4gYXJndW1lbnRzIHRyYW5zZm9ybSBmb3IgY3JlYXRlVk5vZGVcclxuICogdXNlZCBmb3IgY3JlYXRpbmcgc3R1YnMgaW4gdGhlIHRlc3QtdXRpbHNcclxuICogSXQgaXMgKmludGVybmFsKiBidXQgbmVlZHMgdG8gYmUgZXhwb3NlZCBmb3IgdGVzdC11dGlscyB0byBwaWNrIHVwIHByb3BlclxyXG4gKiB0eXBpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcclxuICAgIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XHJcbn1cclxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICByZXR1cm4gX2NyZWF0ZVZOb2RlKC4uLih2bm9kZUFyZ3NUcmFuc2Zvcm1lclxyXG4gICAgICAgID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKVxyXG4gICAgICAgIDogYXJncykpO1xyXG59O1xyXG5jb25zdCBJbnRlcm5hbE9iamVjdEtleSA9IGBfX3ZJbnRlcm5hbGA7XHJcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XHJcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7IHJlZiB9KSA9PiB7XHJcbiAgICByZXR1cm4gKHJlZiAhPSBudWxsXHJcbiAgICAgICAgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpXHJcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiB9XHJcbiAgICAgICAgICAgIDogcmVmXHJcbiAgICAgICAgOiBudWxsKTtcclxufTtcclxuY29uc3QgY3JlYXRlVk5vZGUgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm1cclxuICAgIDogX2NyZWF0ZVZOb2RlKTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVk5vZGUodHlwZSkpIHtcclxuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgLy8gPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiLz5cclxuICAgICAgICAvLyAjMjA3OCBtYWtlIHN1cmUgdG8gbWVyZ2UgcmVmcyBkdXJpbmcgdGhlIGNsb25lIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXRcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyBjb21wb25lbnQgbm9ybWFsaXphdGlvbi5cclxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xyXG4gICAgfVxyXG4gICAgLy8gY2xhc3MgJiBzdHlsZSBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgLy8gZm9yIHJlYWN0aXZlIG9yIHByb3h5IG9iamVjdHMsIHdlIG5lZWQgdG8gY2xvbmUgaXQgdG8gZW5hYmxlIG11dGF0aW9uLlxyXG4gICAgICAgIGlmIChpc1Byb3h5KHByb3BzKSB8fCBJbnRlcm5hbE9iamVjdEtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICAgICAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAvLyByZWFjdGl2ZSBzdGF0ZSBvYmplY3RzIG5lZWQgdG8gYmUgY2xvbmVkIHNpbmNlIHRoZXkgYXJlIGxpa2VseSB0byBiZVxyXG4gICAgICAgICAgICAvLyBtdXRhdGVkXHJcbiAgICAgICAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZW5jb2RlIHRoZSB2bm9kZSB0eXBlIGluZm9ybWF0aW9uIGludG8gYSBiaXRtYXBcclxuICAgIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpXHJcbiAgICAgICAgPyAxIC8qIEVMRU1FTlQgKi9cclxuICAgICAgICA6IGlzU3VzcGVuc2UodHlwZSlcclxuICAgICAgICAgICAgPyAxMjggLyogU1VTUEVOU0UgKi9cclxuICAgICAgICAgICAgOiBpc1RlbGVwb3J0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICA/IDY0IC8qIFRFTEVQT1JUICovXHJcbiAgICAgICAgICAgICAgICA6IGlzT2JqZWN0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbih0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDIgLyogRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLyAmJiBpc1Byb3h5KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xyXG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXHJcbiAgICAgICAgICAgIGBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgYCArXHJcbiAgICAgICAgICAgIGBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgYCArXHJcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdm5vZGUgPSB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgW1wiX192X3NraXBcIiAvKiBTS0lQICovXTogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgICAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXHJcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXHJcbiAgICAgICAgY2hpbGRyZW46IG51bGwsXHJcbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxyXG4gICAgICAgIHN1c3BlbnNlOiBudWxsLFxyXG4gICAgICAgIHNzQ29udGVudDogbnVsbCxcclxuICAgICAgICBzc0ZhbGxiYWNrOiBudWxsLFxyXG4gICAgICAgIGRpcnM6IG51bGwsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogbnVsbCxcclxuICAgICAgICBlbDogbnVsbCxcclxuICAgICAgICBhbmNob3I6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICAgIHRhcmdldEFuY2hvcjogbnVsbCxcclxuICAgICAgICBzdGF0aWNDb3VudDogMCxcclxuICAgICAgICBzaGFwZUZsYWcsXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXHJcbiAgICAgICAgYXBwQ29udGV4dDogbnVsbFxyXG4gICAgfTtcclxuICAgIC8vIHZhbGlkYXRlIGtleVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xyXG4gICAgICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcclxuICAgIH1cclxuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbik7XHJcbiAgICAvLyBub3JtYWxpemUgc3VzcGVuc2UgY2hpbGRyZW5cclxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnQsIGZhbGxiYWNrIH0gPSBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKTtcclxuICAgICAgICB2bm9kZS5zc0NvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sgPSBmYWxsYmFjaztcclxuICAgIH1cclxuICAgIGlmIChzaG91bGRUcmFjayA+IDAgJiZcclxuICAgICAgICAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcclxuICAgICAgICAhaXNCbG9ja05vZGUgJiZcclxuICAgICAgICAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcclxuICAgICAgICBjdXJyZW50QmxvY2sgJiZcclxuICAgICAgICAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xyXG4gICAgICAgIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cclxuICAgICAgICAocGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcclxuICAgICAgICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxyXG4gICAgICAgIHBhdGNoRmxhZyAhPT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IE5PVCB1c2luZyBzcHJlYWQgb3IgZXh0ZW5kIHRvIGF2b2lkIHRoZSBydW50aW1lXHJcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cclxuICAgIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dOiB0cnVlLFxyXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IG1lcmdlZFByb3BzLFxyXG4gICAgICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcclxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcclxuICAgICAgICAgICAgPyAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcclxuICAgICAgICAgICAgICAgIG1lcmdlUmVmICYmIHJlZlxyXG4gICAgICAgICAgICAgICAgICAgID8gaXNBcnJheShyZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXHJcbiAgICAgICAgICAgIDogcmVmLFxyXG4gICAgICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXHJcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8gJiYgaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXHJcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXHJcbiAgICAgICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxyXG4gICAgICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxyXG4gICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXHJcbiAgICAgICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cclxuICAgICAgICAvLyBub3RlOiBwZXJzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgLy8gZmFzdCBwYXRocyBvbmx5LlxyXG4gICAgICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudFxyXG4gICAgICAgICAgICA/IHBhdGNoRmxhZyA9PT0gLTEgLy8gaG9pc3RlZCBub2RlXHJcbiAgICAgICAgICAgICAgICA/IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgICAgIDogcGF0Y2hGbGFnIHwgMTYgLyogRlVMTF9QUk9QUyAqL1xyXG4gICAgICAgICAgICA6IHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcclxuICAgICAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxyXG4gICAgICAgIGRpcnM6IHZub2RlLmRpcnMsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogdm5vZGUudHJhbnNpdGlvbixcclxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcclxuICAgICAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcclxuICAgICAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXHJcbiAgICAgICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcclxuICAgICAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXHJcbiAgICAgICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcclxuICAgICAgICBlbDogdm5vZGUuZWwsXHJcbiAgICAgICAgYW5jaG9yOiB2bm9kZS5hbmNob3JcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIERldiBvbmx5LCBmb3IgSE1SIG9mIGhvaXN0ZWQgdm5vZGVzIHJldXNlZCBpbiB2LWZvclxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzIwMjJcclxuICovXHJcbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XHJcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSAnICcsIGZsYWcgPSAwKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XHJcbiAgICAvLyBBIHN0YXRpYyB2bm9kZSBjYW4gY29udGFpbiBtdWx0aXBsZSBzdHJpbmdpZmllZCBlbGVtZW50cywgYW5kIHRoZSBudW1iZXJcclxuICAgIC8vIG9mIGVsZW1lbnRzIGlzIG5lY2Vzc2FyeSBmb3IgaHlkcmF0aW9uLlxyXG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xyXG4gICAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSAnJywgXHJcbi8vIHdoZW4gdXNlZCBhcyB0aGUgdi1lbHNlIGJyYW5jaCwgdGhlIGNvbW1lbnQgbm9kZSBtdXN0IGJlIGNyZWF0ZWQgYXMgYVxyXG4vLyBibG9jayB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzLlxyXG5hc0Jsb2NrID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBhc0Jsb2NrXHJcbiAgICAgICAgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xyXG4gICAgICAgIC8vIGZyYWdtZW50XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKEZyYWdtZW50LCBudWxsLCBjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSB2bm9kZSwgdGhpcyBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHNpbmNlIGNvbXBpbGVkIHRlbXBsYXRlc1xyXG4gICAgICAgIC8vIGFsd2F5cyBwcm9kdWNlIGFsbC12bm9kZSBjaGlsZHJlbiBhcnJheXNcclxuICAgICAgICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3RyaW5ncyBhbmQgbnVtYmVyc1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcclxuICAgIH1cclxufVxyXG4vLyBvcHRpbWl6ZWQgbm9ybWFsaXphdGlvbiBmb3IgdGVtcGxhdGUtY29tcGlsZWQgcmVuZGVyIGZuc1xyXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcclxuICAgIGxldCB0eXBlID0gMDtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fCBzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgc2xvdCB0byBwbGFpbiBjaGlsZHJlbiBmb3IgcGxhaW4gZWxlbWVudCBhbmQgVGVsZXBvcnRcclxuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBfYyBtYXJrZXIgaXMgYWRkZWQgYnkgd2l0aEN0eCgpIGluZGljYXRpbmcgdGhpcyBpcyBhIGNvbXBpbGVkIHNsb3RcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgc2V0Q29tcGlsZWRTbG90UmVuZGVyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIHNldENvbXBpbGVkU2xvdFJlbmRlcmluZygtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgLyogRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9yd2FyZGVkIHNsb3RzIGZyb20gdGhlIHBhcmVudC5cclxuICAgICAgICAgICAgICAgIC8vIGl0cyBzbG90IHR5cGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgcGFyZW50J3Mgc2xvdCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS52bm9kZS5wYXRjaEZsYWcgJiAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMiAvKiBEWU5BTUlDICovO1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMSAvKiBTVEFCTEUgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XHJcbiAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIGZvcmNlIHRlbGVwb3J0IGNoaWxkcmVuIHRvIGFycmF5IHNvIGl0IGNhbiBiZSBtb3ZlZCBhcm91bmRcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSA4IC8qIFRFWFRfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xyXG4gICAgY29uc3QgcmV0ID0gZXh0ZW5kKHt9LCBhcmdzWzBdKTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZyAhPT0gaW5jb21pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCB0b01lcmdlW2tleV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jb21pbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcclxuICAgICAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcclxuICAgICAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xyXG4gICAgICAgIC8vIG93biBwcm92aWRlcyBvYmplY3QgdXNpbmcgcGFyZW50IHByb3ZpZGVzIG9iamVjdCBhcyBwcm90b3R5cGUuXHJcbiAgICAgICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcclxuICAgICAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxyXG4gICAgICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XHJcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxyXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gIzI0MDBcclxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxyXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnRhbmNlIGlzIGF0IHJvb3RcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlLnBhcmVudCA9PSBudWxsXHJcbiAgICAgICAgICAgID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzXHJcbiAgICAgICAgICAgIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlKClcclxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAodHlwZSwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5sZXQgaXNJbkJlZm9yZUNyZWF0ZSA9IGZhbHNlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMsIGRlZmVycmVkRGF0YSA9IFtdLCBkZWZlcnJlZFdhdGNoID0gW10sIGRlZmVycmVkUHJvdmlkZSA9IFtdLCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgXHJcbiAgICAvLyBjb21wb3NpdGlvblxyXG4gICAgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucywgXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBcclxuICAgIC8vIGxpZmVjeWNsZVxyXG4gICAgYmVmb3JlTW91bnQsIG1vdW50ZWQsIGJlZm9yZVVwZGF0ZSwgdXBkYXRlZCwgYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCwgYmVmb3JlRGVzdHJveSwgYmVmb3JlVW5tb3VudCwgZGVzdHJveWVkLCB1bm1vdW50ZWQsIHJlbmRlciwgcmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJpZ2dlcmVkLCBlcnJvckNhcHR1cmVkLCBcclxuICAgIC8vIHB1YmxpYyBBUElcclxuICAgIGV4cG9zZSB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcclxuICAgIGNvbnN0IGdsb2JhbE1peGlucyA9IGluc3RhbmNlLmFwcENvbnRleHQubWl4aW5zO1xyXG4gICAgaWYgKGFzTWl4aW4gJiYgcmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIH1cclxuICAgIC8vIGFwcGx5T3B0aW9ucyBpcyBjYWxsZWQgbm9uLWFzLW1peGluIG9uY2UgcGVyIGluc3RhbmNlXHJcbiAgICBpZiAoIWFzTWl4aW4pIHtcclxuICAgICAgICBpc0luQmVmb3JlQ3JlYXRlID0gdHJ1ZTtcclxuICAgICAgICBjYWxsU3luY0hvb2soJ2JlZm9yZUNyZWF0ZScsIFwiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovLCBvcHRpb25zLCBpbnN0YW5jZSwgZ2xvYmFsTWl4aW5zKTtcclxuICAgICAgICBpc0luQmVmb3JlQ3JlYXRlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBmaXJzdFxyXG4gICAgICAgIGFwcGx5TWl4aW5zKGluc3RhbmNlLCBnbG9iYWxNaXhpbnMsIGRlZmVycmVkRGF0YSwgZGVmZXJyZWRXYXRjaCwgZGVmZXJyZWRQcm92aWRlKTtcclxuICAgIH1cclxuICAgIC8vIGV4dGVuZGluZyBhIGJhc2UgY29tcG9uZW50Li4uXHJcbiAgICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UsIGV4dGVuZHNPcHRpb25zLCBkZWZlcnJlZERhdGEsIGRlZmVycmVkV2F0Y2gsIGRlZmVycmVkUHJvdmlkZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBsb2NhbCBtaXhpbnNcclxuICAgIGlmIChtaXhpbnMpIHtcclxuICAgICAgICBhcHBseU1peGlucyhpbnN0YW5jZSwgbWl4aW5zLCBkZWZlcnJlZERhdGEsIGRlZmVycmVkV2F0Y2gsIGRlZmVycmVkUHJvdmlkZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb3B0aW9ucyBpbml0aWFsaXphdGlvbiBvcmRlciAodG8gYmUgY29uc2lzdGVudCB3aXRoIFZ1ZSAyKTpcclxuICAgIC8vIC0gcHJvcHMgKGFscmVhZHkgZG9uZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24pXHJcbiAgICAvLyAtIGluamVjdFxyXG4gICAgLy8gLSBtZXRob2RzXHJcbiAgICAvLyAtIGRhdGEgKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxyXG4gICAgLy8gLSBjb21wdXRlZFxyXG4gICAgLy8gLSB3YXRjaCAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICBpZiAoaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0T3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaW5qZWN0T3B0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3RPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSwgb3B0LmRlZmF1bHQsIHRydWUgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KG9wdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiBkZXYgbW9kZSwgd2UgdXNlIHRoZSBgY3JlYXRlUmVuZGVyQ29udGV4dGAgZnVuY3Rpb24gdG8gZGVmaW5lIG1ldGhvZHMgdG8gdGhlIHByb3h5IHRhcmdldCxcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aG9zZSBhcmUgcmVhZC1vbmx5IGJ1dCByZWNvbmZpZ3VyYWJsZSwgc28gaXQgbmVlZHMgdG8gYmUgcmVkZWZpbmVkIGhlcmVcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghYXNNaXhpbikge1xyXG4gICAgICAgIGlmIChkZWZlcnJlZERhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkRGF0YS5mb3JFYWNoKGRhdGFGbiA9PiByZXNvbHZlRGF0YShpbnN0YW5jZSwgZGF0YUZuLCBwdWJsaWNUaGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhT3B0aW9ucykge1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIGRhdGFPcHRpb25zIGlzIG5vdCBmdWxseSB0eXBlIHNhZmVcclxuICAgICAgICAgICAgcmVzb2x2ZURhdGEoaW5zdGFuY2UsIGRhdGFPcHRpb25zLCBwdWJsaWNUaGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zdCByYXdEYXRhID0gdG9SYXcoaW5zdGFuY2UuZGF0YSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlIGRhdGEgb24gY3R4IGR1cmluZyBkZXZcclxuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICckJyAmJiBrZXlbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcmF3RGF0YVtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRhdGFPcHRpb25zKSB7XHJcbiAgICAgICAgZGVmZXJyZWREYXRhLnB1c2goZGF0YU9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24ob3B0LmdldClcclxuICAgICAgICAgICAgICAgICAgICA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBnZXQgPT09IE5PT1ApIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldClcclxuICAgICAgICAgICAgICAgID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XHJcbiAgICAgICAgICAgICAgICBnZXQsXHJcbiAgICAgICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHNldDogdiA9PiAoYy52YWx1ZSA9IHYpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgIGRlZmVycmVkV2F0Y2gucHVzaCh3YXRjaE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhc01peGluICYmIGRlZmVycmVkV2F0Y2gubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVmZXJyZWRXYXRjaC5mb3JFYWNoKHdhdGNoT3B0aW9ucyA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcclxuICAgICAgICBkZWZlcnJlZFByb3ZpZGUucHVzaChwcm92aWRlT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFzTWl4aW4gJiYgZGVmZXJyZWRQcm92aWRlLmxlbmd0aCkge1xyXG4gICAgICAgIGRlZmVycmVkUHJvdmlkZS5mb3JFYWNoKHByb3ZpZGVPcHRpb25zID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IHByb3ZpZGVPcHRpb25zO1xyXG4gICAgICAgICAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBhc3NldCBvcHRpb25zLlxyXG4gICAgLy8gVG8gcmVkdWNlIG1lbW9yeSB1c2FnZSwgb25seSBjb21wb25lbnRzIHdpdGggbWl4aW5zIG9yIGV4dGVuZHMgd2lsbCBoYXZlXHJcbiAgICAvLyByZXNvbHZlZCBhc3NldCByZWdpc3RyeSBhdHRhY2hlZCB0byBpbnN0YW5jZS5cclxuICAgIGlmIChhc01peGluKSB7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKGluc3RhbmNlLmNvbXBvbmVudHMgfHxcclxuICAgICAgICAgICAgICAgIChpbnN0YW5jZS5jb21wb25lbnRzID0gZXh0ZW5kKHt9LCBpbnN0YW5jZS50eXBlLmNvbXBvbmVudHMpKSwgY29tcG9uZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChpbnN0YW5jZS5kaXJlY3RpdmVzIHx8XHJcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGV4dGVuZCh7fSwgaW5zdGFuY2UudHlwZS5kaXJlY3RpdmVzKSksIGRpcmVjdGl2ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGxpZmVjeWNsZSBvcHRpb25zXHJcbiAgICBpZiAoIWFzTWl4aW4pIHtcclxuICAgICAgICBjYWxsU3luY0hvb2soJ2NyZWF0ZWQnLCBcImNcIiAvKiBDUkVBVEVEICovLCBvcHRpb25zLCBpbnN0YW5jZSwgZ2xvYmFsTWl4aW5zKTtcclxuICAgIH1cclxuICAgIGlmIChiZWZvcmVNb3VudCkge1xyXG4gICAgICAgIG9uQmVmb3JlTW91bnQoYmVmb3JlTW91bnQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgIG9uTW91bnRlZChtb3VudGVkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGJlZm9yZVVwZGF0ZSkge1xyXG4gICAgICAgIG9uQmVmb3JlVXBkYXRlKGJlZm9yZVVwZGF0ZS5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmICh1cGRhdGVkKSB7XHJcbiAgICAgICAgb25VcGRhdGVkKHVwZGF0ZWQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgb25BY3RpdmF0ZWQoYWN0aXZhdGVkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgb25EZWFjdGl2YXRlZChkZWFjdGl2YXRlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmIChlcnJvckNhcHR1cmVkKSB7XHJcbiAgICAgICAgb25FcnJvckNhcHR1cmVkKGVycm9yQ2FwdHVyZWQuYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVuZGVyVHJhY2tlZCkge1xyXG4gICAgICAgIG9uUmVuZGVyVHJhY2tlZChyZW5kZXJUcmFja2VkLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlbmRlclRyaWdnZXJlZCkge1xyXG4gICAgICAgIG9uUmVuZGVyVHJpZ2dlcmVkKHJlbmRlclRyaWdnZXJlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYmVmb3JlRGVzdHJveSkge1xyXG4gICAgICAgIHdhcm4oYFxcYGJlZm9yZURlc3Ryb3lcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBiZWZvcmVVbm1vdW50XFxgLmApO1xyXG4gICAgfVxyXG4gICAgaWYgKGJlZm9yZVVubW91bnQpIHtcclxuICAgICAgICBvbkJlZm9yZVVubW91bnQoYmVmb3JlVW5tb3VudC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZGVzdHJveWVkKSB7XHJcbiAgICAgICAgd2FybihgXFxgZGVzdHJveWVkXFxgIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgdW5tb3VudGVkXFxgLmApO1xyXG4gICAgfVxyXG4gICAgaWYgKHVubW91bnRlZCkge1xyXG4gICAgICAgIG9uVW5tb3VudGVkKHVubW91bnRlZC5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcclxuICAgICAgICBpZiAoIWFzTWl4aW4pIHtcclxuICAgICAgICAgICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0gcHJveHlSZWZzKHt9KSk7XHJcbiAgICAgICAgICAgICAgICBleHBvc2UuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRba2V5XSA9IHRvUmVmKHB1YmxpY1RoaXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IEVNUFRZX09CSjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIFxcYGV4cG9zZVxcYCBvcHRpb24gaXMgaWdub3JlZCB3aGVuIHVzZWQgaW4gbWl4aW5zLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsU3luY0hvb2sobmFtZSwgdHlwZSwgb3B0aW9ucywgaW5zdGFuY2UsIGdsb2JhbE1peGlucykge1xyXG4gICAgY2FsbEhvb2tGcm9tTWl4aW5zKG5hbWUsIHR5cGUsIGdsb2JhbE1peGlucywgaW5zdGFuY2UpO1xyXG4gICAgY29uc3QgeyBleHRlbmRzOiBiYXNlLCBtaXhpbnMgfSA9IG9wdGlvbnM7XHJcbiAgICBpZiAoYmFzZSkge1xyXG4gICAgICAgIGNhbGxIb29rRnJvbUV4dGVuZHMobmFtZSwgdHlwZSwgYmFzZSwgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1peGlucykge1xyXG4gICAgICAgIGNhbGxIb29rRnJvbU1peGlucyhuYW1lLCB0eXBlLCBtaXhpbnMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGZIb29rID0gb3B0aW9uc1tuYW1lXTtcclxuICAgIGlmIChzZWxmSG9vaykge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHNlbGZIb29rLmJpbmQoaW5zdGFuY2UucHJveHkpLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbEhvb2tGcm9tRXh0ZW5kcyhuYW1lLCB0eXBlLCBiYXNlLCBpbnN0YW5jZSkge1xyXG4gICAgaWYgKGJhc2UuZXh0ZW5kcykge1xyXG4gICAgICAgIGNhbGxIb29rRnJvbUV4dGVuZHMobmFtZSwgdHlwZSwgYmFzZS5leHRlbmRzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBiYXNlSG9vayA9IGJhc2VbbmFtZV07XHJcbiAgICBpZiAoYmFzZUhvb2spIHtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhiYXNlSG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rRnJvbU1peGlucyhuYW1lLCB0eXBlLCBtaXhpbnMsIGluc3RhbmNlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoYWluZWRNaXhpbnMgPSBtaXhpbnNbaV0ubWl4aW5zO1xyXG4gICAgICAgIGlmIChjaGFpbmVkTWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNhbGxIb29rRnJvbU1peGlucyhuYW1lLCB0eXBlLCBjaGFpbmVkTWl4aW5zLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZuID0gbWl4aW5zW2ldW25hbWVdO1xyXG4gICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbi5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseU1peGlucyhpbnN0YW5jZSwgbWl4aW5zLCBkZWZlcnJlZERhdGEsIGRlZmVycmVkV2F0Y2gsIGRlZmVycmVkUHJvdmlkZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UsIG1peGluc1tpXSwgZGVmZXJyZWREYXRhLCBkZWZlcnJlZFdhdGNoLCBkZWZlcnJlZFByb3ZpZGUsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVEYXRhKGluc3RhbmNlLCBkYXRhRm4sIHB1YmxpY1RoaXMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oZGF0YUZuKSkge1xyXG4gICAgICAgIHdhcm4oYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIGAgK1xyXG4gICAgICAgICAgICBgUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gZGF0YUZuLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZShkYXRhKSkge1xyXG4gICAgICAgIHdhcm4oYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBgICtcclxuICAgICAgICAgICAgYGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYCArXHJcbiAgICAgICAgICAgIGBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gKTtcclxuICAgIH1cclxuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5zdGFuY2UuZGF0YSA9PT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZXhpc3RpbmcgZGF0YTogdGhpcyBpcyBhIG1peGluIG9yIGV4dGVuZHMuXHJcbiAgICAgICAgZXh0ZW5kKGluc3RhbmNlLmRhdGEsIGRhdGEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKCcuJylcclxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxyXG4gICAgICAgIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xyXG4gICAgaWYgKGlzU3RyaW5nKHJhdykpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcclxuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgICAgIHJhdy5mb3JFYWNoKHIgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcmF3ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGNvbnN0IHsgX19tZXJnZWQsIG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IHJhdztcclxuICAgIGlmIChfX21lcmdlZClcclxuICAgICAgICByZXR1cm4gX19tZXJnZWQ7XHJcbiAgICBjb25zdCBnbG9iYWxNaXhpbnMgPSBpbnN0YW5jZS5hcHBDb250ZXh0Lm1peGlucztcclxuICAgIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucylcclxuICAgICAgICByZXR1cm4gcmF3O1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgZ2xvYmFsTWl4aW5zLmZvckVhY2gobSA9PiBtZXJnZU9wdGlvbnMob3B0aW9ucywgbSwgaW5zdGFuY2UpKTtcclxuICAgIG1lcmdlT3B0aW9ucyhvcHRpb25zLCByYXcsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiAocmF3Ll9fbWVyZ2VkID0gb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3Qgc3RyYXRzID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xyXG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xyXG4gICAgZXh0ZW5kc09wdGlvbnMgJiYgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgaW5zdGFuY2UpO1xyXG4gICAgbWl4aW5zICYmXHJcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgaW5zdGFuY2UpKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcclxuICAgICAgICBpZiAoc3RyYXRzICYmIGhhc093bihzdHJhdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0c1trZXldKHRvW2tleV0sIGZyb21ba2V5XSwgaW5zdGFuY2UucHJveHksIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogIzI0MzcgSW4gVnVlIDMsIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3QgaGF2ZSBhIHB1YmxpYyBpbnN0YW5jZSBwcm94eSBidXRcclxuICogdGhleSBleGlzdCBpbiB0aGUgaW50ZXJuYWwgcGFyZW50IGNoYWluLiBGb3IgY29kZSB0aGF0IHJlbGllcyBvbiB0cmF2ZXJzaW5nXHJcbiAqIHB1YmxpYyAkcGFyZW50IGNoYWlucywgc2tpcCBmdW5jdGlvbmFsIG9uZXMgYW5kIGdvIHRvIHRoZSBwYXJlbnQgaW5zdGVhZC5cclxuICovXHJcbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcclxuICAgIGlmICghaSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKVxyXG4gICAgICAgIHJldHVybiBpLmV4cG9zZWQgPyBpLmV4cG9zZWQgOiBpLnByb3h5O1xyXG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcclxufTtcclxuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB7XHJcbiAgICAkOiBpID0+IGksXHJcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcclxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcclxuICAgICRwcm9wczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyksXHJcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxyXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzKSxcclxuICAgICRyZWZzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyksXHJcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcclxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXHJcbiAgICAkZW1pdDogaSA9PiBpLmVtaXQsXHJcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcclxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSksXHJcbiAgICAkbmV4dFRpY2s6IGkgPT4gbmV4dFRpY2suYmluZChpLnByb3h5KSxcclxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXHJcbn0pO1xyXG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBsZXQgQHZ1ZS9yZWFjdGl2aXR5IGtub3cgaXQgc2hvdWxkIG5ldmVyIG9ic2VydmUgVnVlIHB1YmxpYyBpbnN0YW5jZXMuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCBmb3JtYXR0ZXJzIHRvIGtub3cgdGhhdCB0aGlzIGlzIGEgVnVlIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XHJcbiAgICAgICAgLy8gVGhpcyBnZXR0ZXIgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVuZGVyIGNvbnRleHRcclxuICAgICAgICAvLyBkdXJpbmcgcmVuZGVyIGFuZCBpcyBhIG1ham9yIGhvdHNwb3QuIFRoZSBtb3N0IGV4cGVuc2l2ZSBwYXJ0IG9mIHRoaXNcclxuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcclxuICAgICAgICAvLyBhY2Nlc3Mgb24gYSBwbGFpbiBvYmplY3QsIHNvIHdlIHVzZSBhbiBhY2Nlc3NDYWNoZSBvYmplY3QgKHdpdGggbnVsbFxyXG4gICAgICAgIC8vIHByb3RvdHlwZSkgdG8gbWVtb2l6ZSB3aGF0IGFjY2VzcyB0eXBlIGEga2V5IGNvcnJlc3BvbmRzIHRvLlxyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogU0VUVVAgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIENPTlRFWFQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogUFJPUFMgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IGp1c3QgZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIFNFVFVQICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIERBVEEgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogUFJPUFMgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8ICFpc0luQmVmb3JlQ3JlYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBPVEhFUiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XHJcbiAgICAgICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcclxuICAgICAgICAvLyBwdWJsaWMgJHh4eCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJGF0dHJzJykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXHJcbiAgICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJlxyXG4gICAgICAgICAgICAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXHJcbiAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcclxuICAgICAgICAgICAgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiZcclxuICAgICAgICAgICAgKCFpc1N0cmluZyhrZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXHJcbiAgICAgICAgICAgICAgICBrZXkuaW5kZXhPZignX192JykgIT09IDApKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiZcclxuICAgICAgICAgICAgICAgIChrZXlbMF0gPT09ICckJyB8fCBrZXlbMF0gPT09ICdfJykgJiZcclxuICAgICAgICAgICAgICAgIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoYXMoeyBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9IH0sIGtleSkge1xyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIChhY2Nlc3NDYWNoZVtrZXldICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihjdHgsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSkpO1xyXG4gICAgfVxyXG59O1xyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xyXG4gICAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgd2FybihgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xyXG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoIGZvciB1bnNjb3BhYmxlcyB3aGVuIHVzaW5nIGB3aXRoYCBibG9ja1xyXG4gICAgICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xyXG4gICAgfSxcclxuICAgIGhhcyhfLCBrZXkpIHtcclxuICAgICAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09ICdfJyAmJiAhaXNHbG9iYWxseVdoaXRlbGlzdGVkKGtleSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzO1xyXG4gICAgfVxyXG59KTtcclxuLy8gSW4gZGV2IG1vZGUsIHRoZSBwcm94eSB0YXJnZXQgZXhwb3NlcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHNlZW4gb24gYHRoaXNgXHJcbi8vIGZvciBlYXNpZXIgY29uc29sZSBpbnNwZWN0aW9uLiBJbiBwcm9kIG1vZGUgaXQgd2lsbCBiZSBhbiBlbXB0eSBvYmplY3Qgc29cclxuLy8gdGhlc2UgcHJvcGVydGllcyBkZWZpbml0aW9ucyBjYW4gYmUgc2tpcHBlZC5cclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0ge307XHJcbiAgICAvLyBleHBvc2UgaW50ZXJuYWwgaW5zdGFuY2UgZm9yIHByb3h5IGhhbmRsZXJzXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxyXG4gICAgfSk7XHJcbiAgICAvLyBleHBvc2UgcHVibGljIHByb3BlcnRpZXNcclxuICAgIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXHJcbiAgICAgICAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXHJcbiAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBleHBvc2UgZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IHsgZ2xvYmFsUHJvcGVydGllcyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XHJcbiAgICBPYmplY3Qua2V5cyhnbG9iYWxQcm9wZXJ0aWVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gZ2xvYmFsUHJvcGVydGllc1trZXldLFxyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xyXG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpIHtcclxuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgYCArXHJcbiAgICAgICAgICAgICAgICBgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxubGV0IHVpZCQxID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xyXG4gICAgLy8gaW5oZXJpdCBwYXJlbnQgYXBwIGNvbnRleHQgLSBvciAtIGlmIHJvb3QsIGFkb3B0IGZyb20gcm9vdCB2bm9kZVxyXG4gICAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcclxuICAgIGNvbnN0IGluc3RhbmNlID0ge1xyXG4gICAgICAgIHVpZDogdWlkJDErKyxcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBhcHBDb250ZXh0LFxyXG4gICAgICAgIHJvb3Q6IG51bGwsXHJcbiAgICAgICAgbmV4dDogbnVsbCxcclxuICAgICAgICBzdWJUcmVlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZTogbnVsbCxcclxuICAgICAgICByZW5kZXI6IG51bGwsXHJcbiAgICAgICAgcHJveHk6IG51bGwsXHJcbiAgICAgICAgZXhwb3NlZDogbnVsbCxcclxuICAgICAgICB3aXRoUHJveHk6IG51bGwsXHJcbiAgICAgICAgZWZmZWN0czogbnVsbCxcclxuICAgICAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcclxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcclxuICAgICAgICByZW5kZXJDYWNoZTogW10sXHJcbiAgICAgICAgLy8gbG9jYWwgcmVzb3ZsZWQgYXNzZXRzXHJcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcclxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxyXG4gICAgICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXHJcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXHJcbiAgICAgICAgLy8gZW1pdFxyXG4gICAgICAgIGVtaXQ6IG51bGwsXHJcbiAgICAgICAgZW1pdHRlZDogbnVsbCxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIGN0eDogRU1QVFlfT0JKLFxyXG4gICAgICAgIGRhdGE6IEVNUFRZX09CSixcclxuICAgICAgICBwcm9wczogRU1QVFlfT0JKLFxyXG4gICAgICAgIGF0dHJzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2xvdHM6IEVNUFRZX09CSixcclxuICAgICAgICByZWZzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcclxuICAgICAgICAvLyBzdXNwZW5zZSByZWxhdGVkXHJcbiAgICAgICAgc3VzcGVuc2UsXHJcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxyXG4gICAgICAgIGFzeW5jRGVwOiBudWxsLFxyXG4gICAgICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxyXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXHJcbiAgICAgICAgYmM6IG51bGwsXHJcbiAgICAgICAgYzogbnVsbCxcclxuICAgICAgICBibTogbnVsbCxcclxuICAgICAgICBtOiBudWxsLFxyXG4gICAgICAgIGJ1OiBudWxsLFxyXG4gICAgICAgIHU6IG51bGwsXHJcbiAgICAgICAgdW06IG51bGwsXHJcbiAgICAgICAgYnVtOiBudWxsLFxyXG4gICAgICAgIGRhOiBudWxsLFxyXG4gICAgICAgIGE6IG51bGwsXHJcbiAgICAgICAgcnRnOiBudWxsLFxyXG4gICAgICAgIHJ0YzogbnVsbCxcclxuICAgICAgICBlYzogbnVsbFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xyXG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbn1cclxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xyXG4gICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbn07XHJcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnKTtcclxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xyXG4gICAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGFwcElzTmF0aXZlVGFnKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogJyArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLztcclxufVxyXG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XHJcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcclxuICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcclxuICAgIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsXHJcbiAgICAgICAgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUilcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHNldHVwUmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGlmIChDb21wb25lbnQubmFtZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAwLiBjcmVhdGUgcmVuZGVyIHByb3h5IHByb3BlcnR5IGFjY2VzcyBjYWNoZVxyXG4gICAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgLy8gMS4gY3JlYXRlIHB1YmxpYyBpbnN0YW5jZSAvIHJlbmRlciBwcm94eVxyXG4gICAgLy8gYWxzbyBtYXJrIGl0IHJhdyBzbyBpdCdzIG5ldmVyIG9ic2VydmVkXHJcbiAgICBpbnN0YW5jZS5wcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gY2FsbCBzZXR1cCgpXHJcbiAgICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XHJcbiAgICBpZiAoc2V0dXApIHtcclxuICAgICAgICBjb25zdCBzZXR1cENvbnRleHQgPSAoaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID1cclxuICAgICAgICAgICAgc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsKTtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNTU1IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIHNldHVwIHJldHVybmVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGhlcmUgYW5kIHdhaXQgZm9yIHJlLWVudHJ5LlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYW4gaW5saW5lIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xyXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBiaW5kaW5ncy5cclxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gKTtcclxuICAgIH1cclxuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlKTtcclxufVxyXG5sZXQgY29tcGlsZTtcclxuLy8gZGV2IG9ubHlcclxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xyXG4vKipcclxuICogRm9yIHJ1bnRpbWUtZG9tIHRvIHJlZ2lzdGVyIHRoZSBjb21waWxlci5cclxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xyXG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUikge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIC8vIHRlbXBsYXRlIC8gcmVuZGVyIGZ1bmN0aW9uIG5vcm1hbGl6YXRpb25cclxuICAgIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XHJcbiAgICAgICAgLy8gY291bGQgYmUgc2V0IGZyb20gc2V0dXAoKVxyXG4gICAgICAgIGlmIChjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUoQ29tcG9uZW50LnRlbXBsYXRlLCB7XHJcbiAgICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQ6IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIGRlbGltaXRlcnM6IENvbXBvbmVudC5kZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xyXG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXHJcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX3JjKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLndpdGhQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc3VwcG9ydCBmb3IgMi54IG9wdGlvbnNcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSwgQ29tcG9uZW50KTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIHdhcm4gbWlzc2luZyB0ZW1wbGF0ZS9yZW5kZXJcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXHJcbiAgICAgICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGF0dHJIYW5kbGVycyA9IHtcclxuICAgIGdldDogKHRhcmdldCwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICB9LFxyXG4gICAgc2V0OiAoKSA9PiB7XHJcbiAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgZXhwb3NlID0gZXhwb3NlZCA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gcHJveHlSZWZzKGV4cG9zZWQpO1xyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAvLyBXZSB1c2UgZ2V0dGVycyBpbiBkZXYgaW4gY2FzZSBsaWJzIGxpa2UgdGVzdC11dGlscyBvdmVyd3JpdGUgaW5zdGFuY2VcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIChvdmVyd3JpdGVzIHNob3VsZCBub3QgYmUgZG9uZSBpbiBwcm9kKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgZ2V0IHByb3BzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRySGFuZGxlcnMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgc2xvdHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnNsb3RzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IGVtaXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhdHRyczogaW5zdGFuY2UuYXR0cnMsXHJcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcclxuICAgICAgICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vLyByZWNvcmQgZWZmZWN0cyBjcmVhdGVkIGR1cmluZyBhIGNvbXBvbmVudCdzIHNldHVwKCkgc28gdGhhdCB0aGV5IGNhbiBiZVxyXG4vLyBzdG9wcGVkIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xyXG5mdW5jdGlvbiByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KGVmZmVjdCwgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIChpbnN0YW5jZS5lZmZlY3RzIHx8IChpbnN0YW5jZS5lZmZlY3RzID0gW10pKS5wdXNoKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcclxuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpXHJcbiAgICAgICAgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWVcclxuICAgICAgICA6IENvbXBvbmVudC5uYW1lO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcclxuICAgIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIG5hbWUgYmFzZWQgb24gcmV2ZXJzZSByZXNvbHV0aW9uXHJcbiAgICAgICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBuYW1lID1cclxuICAgICAgICAgICAgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuY29tcG9uZW50cyB8fFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50cykgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGMgPSBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucyk7XHJcbiAgICByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KGMuZWZmZWN0KTtcclxuICAgIHJldHVybiBjO1xyXG59XG5cbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYGRlZmluZVByb3BzKCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcclxuICAgICAgICAgICAgYDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBgICtcclxuICAgICAgICAgICAgYGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gZGVmaW5lRW1pdCgpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBkZWZpbmVFbWl0KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcclxuICAgICAgICAgICAgYDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBgICtcclxuICAgICAgICAgICAgYGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdXNlQ29udGV4dCgpIHtcclxuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWkpIHtcclxuICAgICAgICB3YXJuKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XHJcbn1cblxuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xyXG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICBpZiAobCA9PT0gMikge1xyXG4gICAgICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHZub2RlIHdpdGhvdXQgcHJvcHNcclxuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wcyB3aXRob3V0IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb21pdCBwcm9wc1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobCA+IDMpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNzckNvbnRleHRgIDogYGApO1xyXG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcclxuICAgICAgICBpZiAoIWN0eCkge1xyXG4gICAgICAgICAgICB3YXJuKGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzNiYTc3NicgfTtcclxuICAgIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMwYjFiYzknIH07XHJcbiAgICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojYjYyZTI0JyB9O1xyXG4gICAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiM5ZDI4OGMnIH07XHJcbiAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZvciBDaHJvbWVcclxuICAgIC8vIGh0dHBzOi8vd3d3Lm1hdHR6ZXVuZXJ0LmNvbS8yMDE2LzAyLzE5L2N1c3RvbS1jaHJvbWUtZGV2dG9vbHMtb2JqZWN0LWZvcm1hdHRlcnMuaHRtbFxyXG4gICAgY29uc3QgZm9ybWF0dGVyID0ge1xyXG4gICAgICAgIGhlYWRlcihvYmopIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBhbHNvIGZvcm1hdCBDb21wb25lbnRQdWJsaWNJbnN0YW5jZSAmIGN0eC5zbG90cy9hdHRycyBpbiBzZXR1cFxyXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iai52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgYD5gXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgJ1JlYWN0aXZlJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXHJcbiAgICAgICAgICAgICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhZG9ubHkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgJ1JlYWRvbmx5J10sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQm9keShvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgYmxvY2tzID0gW107XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygncHJvcHMnLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdzZXR1cCcsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdkYXRhJywgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2NvbXB1dGVkJyk7XHJcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2NvbXB1dGVkJywgY29tcHV0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2luamVjdCcpO1xyXG4gICAgICAgIGlmIChpbmplY3RlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdpbmplY3RlZCcsIGluamVjdGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJsb2Nrcy5wdXNoKFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnc3BhbicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArICc7b3BhY2l0eTowLjY2J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICckIChpbnRlcm5hbCk6ICdcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWydvYmplY3QnLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gYmxvY2tzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcclxuICAgICAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywge31dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgeyBzdHlsZTogJ2xpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtJyB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOiM0NzY1ODInXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3BhZGRpbmctbGVmdDoxLjI1ZW0nXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIGtleXdvcmRTdHlsZSwga2V5ICsgJzogJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBudW1iZXJTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywga2V5d29yZFN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnb2JqZWN0JywgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xyXG4gICAgICAgIGlmICgoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkpIHx8XHJcbiAgICAgICAgICAgIChpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZShtID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xyXG4gICAgICAgIGlmICh2Ll9zaGFsbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2LmVmZmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGBSZWZgO1xyXG4gICAgfVxyXG4gICAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSkge1xyXG4gICAgbGV0IHJldDtcclxuICAgIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2VbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gQXJyYXkuZnJvbShzb3VyY2UsIHJlbmRlckl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgcHJlZml4aW5nIGtleXMgaW4gdi1vbj1cIm9ialwiIHdpdGggXCJvblwiXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaikge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXRbdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcclxuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWwgc2luZ2xlIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWlmPVwiLi4uXCIgI2Zvbz5cclxuICAgICAgICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3QuZm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XG5cbi8vIENvcmUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5jb25zdCB2ZXJzaW9uID0gXCIzLjAuN1wiO1xyXG4vKipcclxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gY2pzIGJ1aWxkcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBzc3JVdGlscyA9IChudWxsKTtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIENvbW1lbnQsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXQsIGRlZmluZVByb3BzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGgsIGhhbmRsZUVycm9yLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUNvbnRleHQsIHVzZVNTUkNvbnRleHQsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3aXRoQ3R4LCB3aXRoRGlyZWN0aXZlcywgd2l0aFNjb3BlSWQgfTtcbiIsImltcG9ydCB7IGNhbWVsaXplLCB3YXJuLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZ2V0Q3VycmVudEluc3RhbmNlLCBvbk1vdW50ZWQsIHdhdGNoRWZmZWN0LCBvblVwZGF0ZWQsIEZyYWdtZW50LCBoLCBCYXNlVHJhbnNpdGlvbiwgdXNlVHJhbnNpdGlvblN0YXRlLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIGNyZWF0ZVZOb2RlLCBjcmVhdGVSZW5kZXJlciwgaXNSdW50aW1lT25seSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNBcnJheSwgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBpc0Z1bmN0aW9uLCBFTVBUWV9PQkosIGV4dGVuZCwgaXNPYmplY3QsIHRvTnVtYmVyLCBpbnZva2VBcnJheUZucywgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaXNIVE1MVGFnLCBpc1NWR1RhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5jb25zdCBkb2MgPSAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XHJcbmxldCB0ZW1wQ29udGFpbmVyO1xyXG5sZXQgdGVtcFNWR0NvbnRhaW5lcjtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzKSA9PiBpc1NWR1xyXG4gICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKVxyXG4gICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCksXHJcbiAgICBjcmVhdGVUZXh0OiB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcclxuICAgIGNyZWF0ZUNvbW1lbnQ6IHRleHQgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXHJcbiAgICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xyXG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XHJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG4gICAgfSxcclxuICAgIHBhcmVudE5vZGU6IG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlLFxyXG4gICAgbmV4dFNpYmxpbmc6IG5vZGUgPT4gbm9kZS5uZXh0U2libGluZyxcclxuICAgIHF1ZXJ5U2VsZWN0b3I6IHNlbGVjdG9yID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcclxuICAgIHNldFNjb3BlSWQoZWwsIGlkKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGlkLCAnJyk7XHJcbiAgICB9LFxyXG4gICAgY2xvbmVOb2RlKGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIH0sXHJcbiAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAvLyBSZWFzb246IGlubmVySFRNTC5cclxuICAgIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cclxuICAgIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXHJcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRykge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBpc1NWR1xyXG4gICAgICAgICAgICA/IHRlbXBTVkdDb250YWluZXIgfHxcclxuICAgICAgICAgICAgICAgICh0ZW1wU1ZHQ29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgJ3N2ZycpKVxyXG4gICAgICAgICAgICA6IHRlbXBDb250YWluZXIgfHwgKHRlbXBDb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xyXG4gICAgICAgIHRlbXAuaW5uZXJIVE1MID0gY29udGVudDtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHRlbXAuZmlyc3RDaGlsZDtcclxuICAgICAgICBsZXQgbm9kZSA9IGZpcnN0O1xyXG4gICAgICAgIGxldCBsYXN0ID0gbm9kZTtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0ID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnQobm9kZSwgcGFyZW50LCBhbmNob3IpO1xyXG4gICAgICAgICAgICBub2RlID0gdGVtcC5maXJzdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcclxuICAgIH1cclxufTtcblxuLy8gY29tcGlsZXIgc2hvdWxkIG5vcm1hbGl6ZSBjbGFzcyArIDpjbGFzcyBiaW5kaW5ncyBvbiB0aGUgc2FtZSBlbGVtZW50XHJcbi8vIGludG8gYSBzaW5nbGUgYmluZGluZyBbJ3N0YXRpY0NsYXNzJywgZHluYW1pY11cclxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkcpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcclxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGVsZW1lbnQgZHVyaW5nIGEgdHJhbnNpdGlvbiwgdGFrZSB0aGUgdGVtcG9yYXJ5IHRyYW5zaXRpb25cclxuICAgICAgICAvLyBjbGFzc2VzIGludG8gYWNjb3VudC5cclxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlXHJcbiAgICAgICAgICAgICAgICA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdXHJcbiAgICAgICAgICAgICAgICA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xyXG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgIGlmICghbmV4dCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKG5leHQpKSB7XHJcbiAgICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xyXG4gICAgICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0aGUgYGRpc3BsYXlgIG9mIHRoZSBlbGVtZW50IGlzIGNvbnRyb2xsZWQgYnkgYHYtc2hvd2AsXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGFsd2F5cyBrZWVwIHRoZSBjdXJyZW50IGBkaXNwbGF5YCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBgc3R5bGVgIHZhbHVlLFxyXG4gICAgICAgICAgICAvLyB0aHVzIGhhbmRpbmcgb3ZlciBjb250cm9sIHRvIGB2LXNob3dgLlxyXG4gICAgICAgICAgICBpZiAoJ192b2QnIGluIGVsKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gY3VycmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xyXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgdmFsLmZvckVhY2godiA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLS0nKSkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gcHJvcGVydHkgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gIWltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKHByZWZpeGVkKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbmNvbnN0IHByZWZpeENhY2hlID0ge307XHJcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xyXG4gICAgaWYgKG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgaW4gc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XHJcbiAgICB9XHJcbiAgICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcclxuICAgICAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3TmFtZTtcclxufVxuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoJ3hsaW5rOicpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vdGUgd2UgYXJlIG9ubHkgY2hlY2tpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgZG9uJ3QgaGF2ZSBhXHJcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkb20gcHJvcCBvZiB0aGUgc2FtZSBuYW1lIGhlcmUuXHJcbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaXNCb29sZWFuICYmIHZhbHVlID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cclxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycgJiYgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4gY29tcGlsZXMgdG8geyBtdWx0aXBsZTogJycgfVxyXG4gICAgICAgICAgICBlbFtrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGRpdiA6aWQ9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSAnJztcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8aW1nIDp3aWR0aD1cIm51bGxcIj5cclxuICAgICAgICAgICAgZWxba2V5XSA9IDA7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHBlcmZvcm0gdmFsdWUgdmFsaWRhdGlvbiBhbmQgdGhyb3dcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICBgdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cclxubGV0IF9nZXROb3cgPSBEYXRlLm5vdztcclxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXHJcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIF9nZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcclxuICAgIC8vICh3aGljaCBpcyBldmFsdWF0ZWQgQUZURVIpIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXHJcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cclxuICAgIF9nZXROb3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcclxufVxyXG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpLCB3ZSBjYWNoZVxyXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxyXG5sZXQgY2FjaGVkTm93ID0gMDtcclxuY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCByZXNldCA9ICgpID0+IHtcclxuICAgIGNhY2hlZE5vdyA9IDA7XHJcbn07XHJcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKHJlc2V0KSwgKGNhY2hlZE5vdyA9IF9nZXROb3coKSkpO1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcclxuICAgIC8vIHZlaSA9IHZ1ZSBldmVudCBpbnZva2Vyc1xyXG4gICAgY29uc3QgaW52b2tlcnMgPSBlbC5fdmVpIHx8IChlbC5fdmVpID0ge30pO1xyXG4gICAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XHJcbiAgICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgIC8vIHBhdGNoXHJcbiAgICAgICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xyXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gYWRkXHJcbiAgICAgICAgICAgIGNvbnN0IGludm9rZXIgPSAoaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgICAgICAvLyByZW1vdmVcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xyXG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xyXG4gICAgbGV0IG9wdGlvbnM7XHJcbiAgICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtoeXBoZW5hdGUobmFtZS5zbGljZSgyKSksIG9wdGlvbnNdO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XHJcbiAgICAgICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXHJcbiAgICAgICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXHJcbiAgICAgICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcclxuICAgICAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wID0gZS50aW1lU3RhbXAgfHwgX2dldE5vdygpO1xyXG4gICAgICAgIGlmICh0aW1lU3RhbXAgPj0gaW52b2tlci5hdHRhY2hlZCAtIDEpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcocGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksIGluc3RhbmNlLCA1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovLCBbZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xyXG4gICAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xyXG4gICAgcmV0dXJuIGludm9rZXI7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xyXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcclxuICAgICAgICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZuID0+IChlKSA9PiAhZS5fc3RvcHBlZCAmJiBmbihlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XHJcbmNvbnN0IGZvcmNlUGF0Y2hQcm9wID0gKF8sIGtleSkgPT4ga2V5ID09PSAndmFsdWUnO1xyXG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIC8vIHNwZWNpYWxcclxuICAgICAgICBjYXNlICdjbGFzcyc6XHJcbiAgICAgICAgICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzdHlsZSc6XHJcbiAgICAgICAgICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPGlucHV0IHYtbW9kZWwgdHlwZT1cImNoZWNrYm94XCI+IHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIDp0cnVlLXZhbHVlICYgOmZhbHNlLXZhbHVlXHJcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBkb20gcHJvcGVydGllcyBzaW5jZSBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlXHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd0cnVlLXZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdmYWxzZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xyXG4gICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgLy8gbW9zdCBrZXlzIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZSBvbiBzdmcgZWxlbWVudHMgdG8gd29ya1xyXG4gICAgICAgIC8vIC4uLmV4Y2VwdCBpbm5lckhUTUxcclxuICAgICAgICBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3IgbmF0aXZlIG9uY2xpY2sgd2l0aCBmdW5jdGlvbiB2YWx1ZXNcclxuICAgICAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBzcGVsbGNoZWNrIGFuZCBkcmFnZ2FibGUgYXJlIG51bWVyYXRlZCBhdHRycywgaG93ZXZlciB0aGVpclxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBET00gcHJvcGVydGllcyBhcmUgYWN0dWFsbHkgYm9vbGVhbnMgLSB0aGlzIGxlYWRzIHRvXHJcbiAgICAvLyBzZXR0aW5nIGl0IHdpdGggYSBzdHJpbmcgXCJmYWxzZVwiIHZhbHVlIGxlYWRpbmcgaXQgdG8gYmUgY29lcmNlZCB0b1xyXG4gICAgLy8gYHRydWVgLCBzbyB3ZSBuZWVkIHRvIGFsd2F5cyB0cmVhdCB0aGVtIGFzIGF0dHJpYnV0ZXMuXHJcbiAgICAvLyBOb3RlIHRoYXQgYGNvbnRlbnRFZGl0YWJsZWAgZG9lc24ndCBoYXZlIHRoaXMgcHJvYmxlbTogaXRzIERPTVxyXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBlbnVtZXJhdGVkIHN0cmluZyB2YWx1ZXMuXHJcbiAgICBpZiAoa2V5ID09PSAnc3BlbGxjaGVjaycgfHwga2V5ID09PSAnZHJhZ2dhYmxlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNzg3LCAjMjg0MCBmb3JtIHByb3BlcnR5IG9uIGZvcm0gZWxlbWVudHMgaXMgcmVhZG9ubHkgYW5kIG11c3QgYmUgc2V0IGFzXHJcbiAgICAvLyBhdHRyaWJ1dGUuXHJcbiAgICBpZiAoa2V5ID09PSAnZm9ybScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTUyNiA8aW5wdXQgbGlzdD4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAnbGlzdCcgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMyNzY2IDx0ZXh0YXJlYSB0eXBlPiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICd0eXBlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gbmF0aXZlIG9uY2xpY2sgd2l0aCBzdHJpbmcgdmFsdWUsIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXkgaW4gZWw7XHJcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XHJcbiAgICAgICAgaWYgKCFtb2R1bGVzKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XHJcbiAgICAgICAgaWYgKCFtb2QpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIGdldHRlcihpbnN0YW5jZS5wcm94eSkpO1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHdhdGNoRWZmZWN0KHNldFZhcnMsIHsgZmx1c2g6ICdwb3N0JyB9KSk7XHJcbiAgICBvblVwZGF0ZWQoc2V0VmFycyk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xyXG4gICAgICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xyXG4gICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZHJpbGwgZG93biBIT0NzIHVudGlsIGl0J3MgYSBub24tY29tcG9uZW50IHZub2RlXHJcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcclxuICAgIH1cclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgdm5vZGUuZWwpIHtcclxuICAgICAgICBjb25zdCBzdHlsZSA9IHZub2RlLmVsLnN0eWxlO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcclxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcclxuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XHJcbi8vIERPTSBUcmFuc2l0aW9uIGlzIGEgaGlnaGVyLW9yZGVyLWNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcGxhdGZvcm0tYWdub3N0aWNcclxuLy8gYmFzZSBUcmFuc2l0aW9uIGNvbXBvbmVudCwgd2l0aCBET00tc3BlY2lmaWMgbG9naWMuXHJcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcclxuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9ICdUcmFuc2l0aW9uJztcclxuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIGNzczoge1xyXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXHJcbiAgICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcclxufTtcclxuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IChUcmFuc2l0aW9uLnByb3BzID0gLyojX19QVVJFX18qLyBleHRlbmQoe30sIEJhc2VUcmFuc2l0aW9uLnByb3BzLCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSk7XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcclxuICAgIGxldCB7IG5hbWUgPSAndicsIHR5cGUsIGNzcyA9IHRydWUsIGR1cmF0aW9uLCBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLCBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCwgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLCBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLCBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLCBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLCBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCwgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gIH0gPSByYXdQcm9wcztcclxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcclxuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghY3NzKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VQcm9wcztcclxuICAgIH1cclxuICAgIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcclxuICAgIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xyXG4gICAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XHJcbiAgICBjb25zdCB7IG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlciwgb25BcHBlYXIgPSBvbkVudGVyLCBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWQgfSA9IGJhc2VQcm9wcztcclxuICAgIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBkb25lICYmIGRvbmUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcclxuICAgICAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XHJcbiAgICAgICAgICAgIGhvb2sgJiYgaG9vayhlbCwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoaG9vayAmJiBob29rLmxlbmd0aCA+IDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xyXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgb25CZWZvcmVFbnRlciAmJiBvbkJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xyXG4gICAgICAgICAgICBvbkJlZm9yZUFwcGVhciAmJiBvbkJlZm9yZUFwcGVhcihlbCk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcclxuICAgICAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcclxuICAgICAgICBvbkxlYXZlKGVsLCBkb25lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgc28gKi1sZWF2ZS1mcm9tIGNsYXNzZXMgaW1tZWRpYXRlbHkgdGFrZSBlZmZlY3QgKCMyNTkzKVxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShvbkxlYXZlICYmIG9uTGVhdmUubGVuZ3RoID4gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgb25MZWF2ZSAmJiBvbkxlYXZlKGVsLCByZXNvbHZlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgb25FbnRlckNhbmNlbGxlZCAmJiBvbkVudGVyQ2FuY2VsbGVkKGVsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQgJiYgb25BcHBlYXJDYW5jZWxsZWQoZWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XHJcbiAgICAgICAgICAgIG9uTGVhdmVDYW5jZWxsZWQgJiYgb25MZWF2ZUNhbmNlbGxlZChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcclxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIFtuLCBuXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcclxuICAgIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxyXG4gICAgICAgIHZhbGlkYXRlRHVyYXRpb24ocmVzKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbih2YWwpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICtcclxuICAgICAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBOYU4gLSBgICtcclxuICAgICAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xyXG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICAoZWwuX3Z0YyB8fFxyXG4gICAgICAgIChlbC5fdnRjID0gbmV3IFNldCgpKSkuYWRkKGNscyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgY29uc3QgeyBfdnRjIH0gPSBlbDtcclxuICAgIGlmIChfdnRjKSB7XHJcbiAgICAgICAgX3Z0Yy5kZWxldGUoY2xzKTtcclxuICAgICAgICBpZiAoIV92dGMuc2l6ZSkge1xyXG4gICAgICAgICAgICBlbC5fdnRjID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcclxuICAgIH0pO1xyXG59XHJcbmxldCBlbmRJZCA9IDA7XHJcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcclxuICAgIGNvbnN0IGlkID0gKGVsLl9lbmRJZCA9ICsrZW5kSWQpO1xyXG4gICAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgJ2VuZCc7XHJcbiAgICBsZXQgZW5kZWQgPSAwO1xyXG4gICAgY29uc3QgZW5kID0gKCkgPT4ge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxuICAgICAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGltZW91dCArIDEpO1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcclxuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCAnJykuc3BsaXQoJywgJyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoVFJBTlNJVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEZWxheScpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xyXG4gICAgbGV0IHR5cGUgPSBudWxsO1xyXG4gICAgbGV0IHRpbWVvdXQgPSAwO1xyXG4gICAgbGV0IHByb3BDb3VudCA9IDA7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBBTklNQVRJT047XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XHJcbiAgICAgICAgdHlwZSA9XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxyXG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxyXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgcHJvcENvdW50ID0gdHlwZVxyXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmXHJcbiAgICAgICAgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KHN0eWxlc1tUUkFOU0lUSU9OICsgJ1Byb3BlcnR5J10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHRpbWVvdXQsXHJcbiAgICAgICAgcHJvcENvdW50LFxyXG4gICAgICAgIGhhc1RyYW5zZm9ybVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xyXG59XHJcbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyXHJcbi8vIG51bWJlcnMgaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxyXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duXHJcbi8vIChpLmUuIGFjdGluZyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXHJcbmZ1bmN0aW9uIHRvTXMocykge1xyXG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwO1xyXG59XHJcbi8vIHN5bmNocm9ub3VzbHkgZm9yY2UgbGF5b3V0IHRvIHB1dCBlbGVtZW50cyBpbnRvIGEgY2VydGFpbiBzdGF0ZVxyXG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcclxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcclxuICAgIG5hbWU6ICdUcmFuc2l0aW9uR3JvdXAnLFxyXG4gICAgcHJvcHM6IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XHJcbiAgICAgICAgdGFnOiBTdHJpbmcsXHJcbiAgICAgICAgbW92ZUNsYXNzOiBTdHJpbmdcclxuICAgIH0pLFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldkNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbjtcclxuICAgICAgICBvblVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjaGlsZHJlbiBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IGFmdGVyIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8ICd2J30tbW92ZWA7XHJcbiAgICAgICAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKHByZXZDaGlsZHJlblswXS5lbCwgaW5zdGFuY2Uudm5vZGUuZWwsIG1vdmVDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcclxuICAgICAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XHJcbiAgICAgICAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaChjID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gKGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGNoaWxkLCBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XHJcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcclxuICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgIGlmIChlbC5fbW92ZUNiKSB7XHJcbiAgICAgICAgZWwuX21vdmVDYigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XHJcbiAgICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XHJcbiAgICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xyXG4gICAgaWYgKGR4IHx8IGR5KSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XHJcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XHJcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XHJcbiAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcclxuICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xyXG4gICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxyXG4gICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXHJcbiAgICAvLyBpcyBhcHBsaWVkLlxyXG4gICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcclxuICAgIGlmIChlbC5fdnRjKSB7XHJcbiAgICAgICAgZWwuX3Z0Yy5mb3JFYWNoKGNscyA9PiB7XHJcbiAgICAgICAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gKHJvb3Qubm9kZVR5cGUgPT09IDFcclxuICAgICAgICA/IHJvb3RcclxuICAgICAgICA6IHJvb3QucGFyZW50Tm9kZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcclxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICByZXR1cm4gaGFzVHJhbnNmb3JtO1xyXG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbJ29uVXBkYXRlOm1vZGVsVmFsdWUnXTtcclxuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcclxufTtcclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcclxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XHJcbiAgICAgICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCAnaW5wdXQnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKGVsLCB0eXBlKSB7XHJcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG4vLyBXZSBhcmUgZXhwb3J0aW5nIHRoZSB2LW1vZGVsIHJ1bnRpbWUgZGlyZWN0bHkgYXMgdm5vZGUgaG9va3Mgc28gdGhhdCBpdCBjYW5cclxuLy8gYmUgdHJlZS1zaGFrZW4gaW4gY2FzZSB2LW1vZGVsIGlzIG5ldmVyIHVzZWQuXHJcbmNvbnN0IHZNb2RlbFRleHQgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcic7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2FzdFRvTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IHRvTnVtYmVyKGRvbVZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGRvbVZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWxhenkpIHtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXHJcbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcclxuICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICAvLyBhdm9pZCBjbGVhcmluZyB1bnJlc29sdmVkIHRleHQuICMyMzAyXHJcbiAgICAgICAgaWYgKGVsLmNvbXBvc2luZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xyXG4gICAgICAgICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcicpICYmIHRvTnVtYmVyKGVsLnZhbHVlKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xyXG4gICAgICAgICAgICBjb25zdCBhc3NpZ24gPSBlbC5fYXNzaWduO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoZWNrZWQgJiYgZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihmaWx0ZXJlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXQobW9kZWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2lnbihjbG9uZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxyXG4gICAgbW91bnRlZDogc2V0Q2hlY2tlZCxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZ2V0VmFsdWUoZWwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcclxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXHJcbiAgICAvLyA8b3B0aW9uPnMuXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xyXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIHNldCB2aWEgOnZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcclxuICAgIGNvbnN0IGtleSA9IGNoZWNrZWQgPyAnX3RydWVWYWx1ZScgOiAnX2ZhbHNlVmFsdWUnO1xyXG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xyXG59XHJcbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnY3JlYXRlZCcpO1xyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdtb3VudGVkJyk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAndXBkYXRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XHJcbiAgICBsZXQgbW9kZWxUb1VzZTtcclxuICAgIHN3aXRjaCAoZWwudGFnTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XHJcbiAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxTZWxlY3Q7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN3aXRjaCAodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxDaGVja2JveDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsUmFkaW87XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XHJcbiAgICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XHJcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ107XHJcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xyXG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgcHJldmVudDogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXHJcbiAgICBzZWxmOiBlID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXHJcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXHJcbiAgICBzaGlmdDogZSA9PiAhZS5zaGlmdEtleSxcclxuICAgIGFsdDogZSA9PiAhZS5hbHRLZXksXHJcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXHJcbiAgICBsZWZ0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDAsXHJcbiAgICBtaWRkbGU6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcclxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXHJcbiAgICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUobSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XHJcbiAgICAgICAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH07XHJcbn07XHJcbi8vIEtlcHQgZm9yIDIueCBjb21wYXQuXHJcbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXHJcbmNvbnN0IGtleU5hbWVzID0ge1xyXG4gICAgZXNjOiAnZXNjYXBlJyxcclxuICAgIHNwYWNlOiAnICcsXHJcbiAgICB1cDogJ2Fycm93LXVwJyxcclxuICAgIGxlZnQ6ICdhcnJvdy1sZWZ0JyxcclxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxyXG4gICAgZG93bjogJ2Fycm93LWRvd24nLFxyXG4gICAgZGVsZXRlOiAnYmFja3NwYWNlJ1xyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvLyBOb25lIG9mIHRoZSBwcm92aWRlZCBrZXkgbW9kaWZpZXJzIG1hdGNoIHRoZSBjdXJyZW50IGV2ZW50IGtleVxyXG4gICAgICAgICFtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm4oZXZlbnQpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgdlNob3cgPSB7XHJcbiAgICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGVsLl92b2QgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XHJcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fdm9kIDogJ25vbmUnO1xyXG59XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7IHBhdGNoUHJvcCwgZm9yY2VQYXRjaFByb3AgfSwgbm9kZU9wcyk7XHJcbi8vIGxhenkgY3JlYXRlIHRoZSByZW5kZXJlciAtIHRoaXMgbWFrZXMgY29yZSByZW5kZXJlciBsb2dpYyB0cmVlLXNoYWthYmxlXHJcbi8vIGluIGNhc2UgdGhlIHVzZXIgb25seSBpbXBvcnRzIHJlYWN0aXZpdHkgdXRpbGl0aWVzIGZyb20gVnVlLlxyXG5sZXQgcmVuZGVyZXI7XHJcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xyXG4gICAgcmV0dXJuIHJlbmRlcmVyIHx8IChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xyXG4gICAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uXHJcbiAgICAgICAgPyByZW5kZXJlclxyXG4gICAgICAgIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcclxuICAgIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVyO1xyXG59XHJcbi8vIHVzZSBleHBsaWNpdCB0eXBlIGNhc3RzIGhlcmUgdG8gYXZvaWQgaW1wb3J0KCkgY2FsbHMgaW4gcm9sbGVkLXVwIGQudHNcclxuY29uc3QgcmVuZGVyID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGh5ZHJhdGUgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZUFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDdXN0b21FbGVtZW50Q2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbGVhciBjb250ZW50IGJlZm9yZSBtb3VudGluZ1xyXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLXYtYXBwJywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDdXN0b21FbGVtZW50Q2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcclxuICAgIC8vIEluamVjdCBgaXNOYXRpdmVUYWdgXHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgZm9yIGNvbXBvbmVudCBuYW1lIHZhbGlkYXRpb24gKGRldiBvbmx5KVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc05hdGl2ZVRhZycsIHtcclxuICAgICAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGluamVjdEN1c3RvbUVsZW1lbnRDaGVjayhhcHApIHtcclxuICAgIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNDdXN0b21FbGVtZW50Jywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBydW50aW1lIGNvbXBpbGVyLmAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAtIGZvciBleGFtcGxlLCB2aWEgdGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBvcHRpb24gaW4gdnVlLWxvYWRlcjogaHR0cHM6Ly92dWUtbG9hZGVyLnZ1ZWpzLm9yZy9vcHRpb25zLmh0bWwjY29tcGlsZXJvcHRpb25zLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiZcclxuICAgICAgICBjb250YWluZXIubW9kZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICB3YXJuKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG59XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGh5ZHJhdGUsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKiBJTVBPUlRBTlQ6IGFsbCBjYWxscyBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxyXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xyXG4gKiBTbyB0aGF0IHJvbGx1cCBjYW4gdHJlZS1zaGFrZSB0aGVtIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XHJcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xyXG59XG5cbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIC0+IG5hbWUgbWFwcGluZ1xyXG4gKi9cclxuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XHJcbiAgICBbMSAvKiBURVhUICovXTogYFRFWFRgLFxyXG4gICAgWzIgLyogQ0xBU1MgKi9dOiBgQ0xBU1NgLFxyXG4gICAgWzQgLyogU1RZTEUgKi9dOiBgU1RZTEVgLFxyXG4gICAgWzggLyogUFJPUFMgKi9dOiBgUFJPUFNgLFxyXG4gICAgWzE2IC8qIEZVTExfUFJPUFMgKi9dOiBgRlVMTF9QUk9QU2AsXHJcbiAgICBbMzIgLyogSFlEUkFURV9FVkVOVFMgKi9dOiBgSFlEUkFURV9FVkVOVFNgLFxyXG4gICAgWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL106IGBTVEFCTEVfRlJBR01FTlRgLFxyXG4gICAgWzEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqL106IGBLRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi9dOiBgVU5LRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbNTEyIC8qIE5FRURfUEFUQ0ggKi9dOiBgTkVFRF9QQVRDSGAsXHJcbiAgICBbMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovXTogYERZTkFNSUNfU0xPVFNgLFxyXG4gICAgWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dOiBgREVWX1JPT1RfRlJBR01FTlRgLFxyXG4gICAgWy0xIC8qIEhPSVNURUQgKi9dOiBgSE9JU1RFRGAsXHJcbiAgICBbLTIgLyogQkFJTCAqL106IGBCQUlMYFxyXG59O1xuXG4vKipcclxuICogRGV2IG9ubHlcclxuICovXHJcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XHJcbiAgICBbMSAvKiBTVEFCTEUgKi9dOiAnU1RBQkxFJyxcclxuICAgIFsyIC8qIERZTkFNSUMgKi9dOiAnRFlOQU1JQycsXHJcbiAgICBbMyAvKiBGT1JXQVJERUQgKi9dOiAnRk9SV0FSREVEJ1xyXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9ICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLCcgK1xyXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksJyArXHJcbiAgICAnT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQnO1xyXG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJyAnLnJlcGVhdChwYWQpICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKTtcclxufVxuXG4vKipcclxuICogT24gdGhlIGNsaWVudCB3ZSBvbmx5IG5lZWQgdG8gb2ZmZXIgc3BlY2lhbCBjYXNlcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXRcclxuICogaGF2ZSBkaWZmZXJlbnQgbmFtZXMgZnJvbSB0aGVpciBjb3JyZXNwb25kaW5nIGRvbSBwcm9wZXJ0aWVzOlxyXG4gKiAtIGl0ZW1zY29wZSAtPiBOL0FcclxuICogLSBhbGxvd2Z1bGxzY3JlZW4gLT4gYWxsb3dGdWxsc2NyZWVuXHJcbiAqIC0gZm9ybW5vdmFsaWRhdGUgLT4gZm9ybU5vVmFsaWRhdGVcclxuICogLSBpc21hcCAtPiBpc01hcFxyXG4gKiAtIG5vbW9kdWxlIC0+IG5vTW9kdWxlXHJcbiAqIC0gbm92YWxpZGF0ZSAtPiBub1ZhbGlkYXRlXHJcbiAqIC0gcmVhZG9ubHkgLT4gcmVhZE9ubHlcclxuICovXHJcbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcclxuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XHJcbi8qKlxyXG4gKiBUaGUgZnVsbCBsaXN0IGlzIG5lZWRlZCBkdXJpbmcgU1NSIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgaW5pdGlhbCBtYXJrdXAuXHJcbiAqL1xyXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgK1xyXG4gICAgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sYCArXHJcbiAgICBgbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxgICtcclxuICAgIGBjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XHJcbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcclxuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XHJcbiAgICBpZiAoaXNVbnNhZmUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZSk7XHJcbn1cclxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XHJcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxyXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxyXG4gICAgaHRtbEZvcjogJ2ZvcicsXHJcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xyXG59O1xyXG4vKipcclxuICogQ1NTIHByb3BlcnRpZXMgdGhhdCBhY2NlcHQgcGxhaW4gbnVtYmVyc1xyXG4gKi9cclxuY29uc3QgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LGJvcmRlci1pbWFnZS1vdXRzZXQsYm9yZGVyLWltYWdlLXNsaWNlLGAgK1xyXG4gICAgYGJvcmRlci1pbWFnZS13aWR0aCxib3gtZmxleCxib3gtZmxleC1ncm91cCxib3gtb3JkaW5hbC1ncm91cCxjb2x1bW4tY291bnQsYCArXHJcbiAgICBgY29sdW1ucyxmbGV4LGZsZXgtZ3JvdyxmbGV4LXBvc2l0aXZlLGZsZXgtc2hyaW5rLGZsZXgtbmVnYXRpdmUsZmxleC1vcmRlcixgICtcclxuICAgIGBncmlkLXJvdyxncmlkLXJvdy1lbmQsZ3JpZC1yb3ctc3BhbixncmlkLXJvdy1zdGFydCxncmlkLWNvbHVtbixgICtcclxuICAgIGBncmlkLWNvbHVtbi1lbmQsZ3JpZC1jb2x1bW4tc3BhbixncmlkLWNvbHVtbi1zdGFydCxmb250LXdlaWdodCxsaW5lLWNsYW1wLGAgK1xyXG4gICAgYGxpbmUtaGVpZ2h0LG9wYWNpdHksb3JkZXIsb3JwaGFucyx0YWItc2l6ZSx3aWRvd3Msei1pbmRleCx6b29tLGAgK1xyXG4gICAgLy8gU1ZHXHJcbiAgICBgZmlsbC1vcGFjaXR5LGZsb29kLW9wYWNpdHksc3RvcC1vcGFjaXR5LHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsYCArXHJcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoYCk7XHJcbi8qKlxyXG4gKiBLbm93biBhdHRyaWJ1dGVzLCB0aGlzIGlzIHVzZWQgZm9yIHN0cmluZ2lmaWNhdGlvbiBvZiBydW50aW1lIHN0YXRpYyBub2Rlc1xyXG4gKiBzbyB0aGF0IHdlIGRvbid0IHN0cmluZ2lmeSBiaW5kaW5ncyB0aGF0IGNhbm5vdCBiZSBzZXQgZnJvbSBIVE1MLlxyXG4gKiBEb24ndCBhbHNvIGZvcmdldCB0byBhbGxvdyBgZGF0YS0qYCBhbmQgYGFyaWEtKmAhXHJcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlc1xyXG4gKi9cclxuY29uc3QgaXNLbm93bkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcclxuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcclxuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcclxuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXHJcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXHJcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xyXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXHJcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xyXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcclxuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xyXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcclxuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xyXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcclxuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcclxuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVN0eWxlKGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IGl0ZW0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcclxuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KC4rKS87XHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xyXG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xyXG4gICAgbGV0IHJldCA9ICcnO1xyXG4gICAgaWYgKCFzdHlsZXMpIHtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcChub3JtYWxpemVkS2V5KSkpIHtcclxuICAgICAgICAgICAgLy8gb25seSByZW5kZXIgdmFsaWQgdmFsdWVzXHJcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcclxuICAgIGxldCByZXMgPSAnJztcclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMudHJpbSgpO1xyXG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxyXG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcclxuICAgICdoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xyXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xyXG4gICAgJ2RhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcclxuICAgICd0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLCcgK1xyXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcclxuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXHJcbiAgICAnb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSwnICtcclxuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290JztcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcclxuY29uc3QgU1ZHX1RBR1MgPSAnc3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLCcgK1xyXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXHJcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcclxuICAgICdmZURpc3RhbmNlTGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcclxuICAgICdmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LCcgK1xyXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXHJcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xyXG4gICAgJ21lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybiwnICtcclxuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xyXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XHJcbmNvbnN0IFZPSURfVEFHUyA9ICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicic7XHJcbmNvbnN0IGlzSFRNTFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xyXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XHJcbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzdHIgPSAnJyArIHN0cmluZztcclxuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICBsZXQgaHRtbCA9ICcnO1xyXG4gICAgbGV0IGVzY2FwZWQ7XHJcbiAgICBsZXQgaW5kZXg7XHJcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcclxuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcclxuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJnF1b3Q7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZhbXA7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyYjMzk7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZsdDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmd0Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xyXG4gICAgICAgICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcclxufVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUyL3N5bnRheC5odG1sI2NvbW1lbnRzXHJcbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xyXG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCAnJyk7XHJcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcclxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlcXVhbDtcclxufVxyXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XHJcbiAgICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRoaXMgaWYgd2lsbCBwcm9iYWJseSBuZXZlciBiZSBjYWxsZWQgKi9cclxuICAgICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGlmICgoYUhhc0tleSAmJiAhYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICghYUhhc0tleSAmJiBiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XHJcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChpdGVtID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XHJcbn1cblxuLyoqXHJcbiAqIEZvciBjb252ZXJ0aW5nIHt7IGludGVycG9sYXRpb24gfX0gdmFsdWVzIHRvIGRpc3BsYXllZCBzdHJpbmdzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXHJcbiAgICAgICAgPyAnJ1xyXG4gICAgICAgIDogaXNPYmplY3QodmFsKVxyXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXHJcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XHJcbn07XHJcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xyXG4gICAgaWYgKGlzTWFwKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgICAgICAgICAgfSwge30pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59O1xuXG4vKipcclxuICogTGlzdCBvZiBAYmFiZWwvcGFyc2VyIHBsdWdpbnMgdGhhdCBhcmUgdXNlZCBmb3IgdGVtcGxhdGUgZXhwcmVzc2lvblxyXG4gKiB0cmFuc2Zvcm1zIGFuZCBTRkMgc2NyaXB0IHRyYW5zZm9ybXMuIEJ5IGRlZmF1bHQgd2UgZW5hYmxlIHByb3Bvc2FscyBzbGF0ZWRcclxuICogZm9yIEVTMjAyMC4gVGhpcyB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZCBhcyB0aGUgc3BlYyBtb3ZlcyBmb3J3YXJkLlxyXG4gKiBGdWxsIGxpc3QgYXQgaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vbmV4dC9iYWJlbC1wYXJzZXIjcGx1Z2luc1xyXG4gKi9cclxuY29uc3QgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyA9IFtcclxuICAgICdiaWdJbnQnLFxyXG4gICAgJ29wdGlvbmFsQ2hhaW5pbmcnLFxyXG4gICAgJ251bGxpc2hDb2FsZXNjaW5nT3BlcmF0b3InXHJcbl07XHJcbmNvbnN0IEVNUFRZX09CSiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxyXG4gICAgOiB7fTtcclxuY29uc3QgRU1QVFlfQVJSID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcclxuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcclxuLyoqXHJcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xyXG5jb25zdCBvblJFID0gL15vblteYS16XS87XHJcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcclxuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJ29uVXBkYXRlOicpO1xyXG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xyXG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xyXG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcclxuICAgIGlmIChpID4gLTEpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XHJcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBNYXBdJztcclxuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgU2V0XSc7XHJcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIERhdGU7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xyXG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xyXG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnO1xyXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcclxuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xyXG59O1xyXG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgLy8gZXh0cmFjdCBcIlJhd1R5cGVcIiBmcm9tIHN0cmluZ3MgbGlrZSBcIltvYmplY3QgUmF3VHlwZV1cIlxyXG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG59O1xyXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmXHJcbiAgICBrZXkgIT09ICdOYU4nICYmXHJcbiAgICBrZXlbMF0gIT09ICctJyAmJlxyXG4gICAgJycgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xyXG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcclxuLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxyXG4nLGtleSxyZWYsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XHJcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IChzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApKTtcclxuLy8gY29tcGFyZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQsIGFjY291bnRpbmcgZm9yIE5hTi5cclxuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+IHZhbHVlICE9PSBvbGRWYWx1ZSAmJiAodmFsdWUgPT09IHZhbHVlIHx8IG9sZFZhbHVlID09PSBvbGRWYWx1ZSk7XHJcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZuc1tpXShhcmcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWVcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcclxuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xyXG59O1xyXG5sZXQgX2dsb2JhbFRoaXM7XHJcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKF9nbG9iYWxUaGlzIHx8XHJcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cclxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcclxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdsb2JhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xyXG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25BdHRyLCBpc01hcCwgaXNNb2RlbExpc3RlbmVyLCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIjx0ZW1wbGF0ZT5cclxuICAgIDxzZWFyY2ggLz5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBTZWFyY2ggZnJvbSBcIi4vU2VhcmNoLnZ1ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgY29tcG9uZW50czogeyBTZWFyY2ggfSxcclxufTtcclxuPC9zY3JpcHQ+IiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJTZWFyY2hcIj5cbiAgICAgICAgPGlucHV0IHYtbW9kZWw9XCJxdWVyeVwiIC8+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICAgIDxsaSB2LWZvcj1cIihhbGJ1bSwgaSkgaW4gYWxidW1zXCIgOmtleT1cImlcIj5cbiAgICAgICAgICAgICAgICB7eyBhbGJ1bS50aXRsZSB9fSBieSB7eyBhbGJ1bS5hcnRpc3QgfX1cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgcmVmLCB3YXRjaCB9IGZyb20gXCJ2dWVcIjtcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSBcImRlYm91bmNlXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBzZXR1cCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gcmVmKFwiXCIpO1xuICAgICAgICBsZXQgYWxidW1zID0gcmVmKFtdKTtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcIi9hcGkvYWxidW1zXCIsIHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHsgcXVlcnkgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB3YXRjaChcbiAgICAgICAgICAgICgpID0+IHF1ZXJ5LnZhbHVlLFxuICAgICAgICAgICAgZGVib3VuY2UoYXN5bmMgKHF1ZXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHNlYXJjaChxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIGFsYnVtcy52YWx1ZSA9IFsuLi5yZXN1bHQuZGF0YV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGF0ZXZlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDI1MClcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhbGJ1bXMsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG48L3NjcmlwdD4iLCJpbXBvcnQgJy4vYm9vdHN0cmFwLmpzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZUFwcCB9IGZyb20gJ3Z1ZSdcclxuaW1wb3J0IEFwcCBmcm9tICcuL2NvbXBvbmVudHMvQXBwLnZ1ZSc7XHJcblxyXG5jcmVhdGVBcHAoe30pXHJcbiAgICAuY29tcG9uZW50KCdhcHAnLCBBcHApXHJcbiAgICAubW91bnQoJyNhcHAnKTsiLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuLyoqXHJcbiAqIFdlJ2xsIGxvYWQgdGhlIGF4aW9zIEhUVFAgbGlicmFyeSB3aGljaCBhbGxvd3MgdXMgdG8gZWFzaWx5IGlzc3VlIHJlcXVlc3RzXHJcbiAqIHRvIG91ciBMYXJhdmVsIGJhY2stZW5kLiBUaGlzIGxpYnJhcnkgYXV0b21hdGljYWxseSBoYW5kbGVzIHNlbmRpbmcgdGhlXHJcbiAqIENTUkYgdG9rZW4gYXMgYSBoZWFkZXIgYmFzZWQgb24gdGhlIHZhbHVlIG9mIHRoZSBcIlhTUkZcIiB0b2tlbiBjb29raWUuXHJcbiAqL1xyXG5cclxuYXhpb3MuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XHJcbiIsIi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICogYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICogTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gKiBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLiBUaGUgZnVuY3Rpb24gYWxzbyBoYXMgYSBwcm9wZXJ0eSAnY2xlYXInIFxuICogdGhhdCBpcyBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgY2xlYXIgdGhlIHRpbWVyIHRvIHByZXZlbnQgcHJldmlvdXNseSBzY2hlZHVsZWQgZXhlY3V0aW9ucy4gXG4gKlxuICogQHNvdXJjZSB1bmRlcnNjb3JlLmpzXG4gKiBAc2VlIGh0dHA6Ly91bnNjcmlwdGFibGUuY29tLzIwMDkvMDMvMjAvZGVib3VuY2luZy1qYXZhc2NyaXB0LW1ldGhvZHMvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiB0byB3cmFwXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBpbiBtcyAoYDEwMGApXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgdG8gZXhlY3V0ZSBhdCB0aGUgYmVnaW5uaW5nIChgZmFsc2VgKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKXtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICBpZiAobnVsbCA9PSB3YWl0KSB3YWl0ID0gMTAwO1xuXG4gIGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGVib3VuY2VkID0gZnVuY3Rpb24oKXtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBkZWJvdW5jZWQuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuICBcbiAgZGVib3VuY2VkLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICBcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVib3VuY2VkO1xufTtcblxuLy8gQWRkcyBjb21wYXRpYmlsaXR5IGZvciBFUyBtb2R1bGVzXG5kZWJvdW5jZS5kZWJvdW5jZSA9IGRlYm91bmNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zMzJmY2NmNFwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBzY3JpcHQuX19obXJJZCA9IFwiMzMyZmNjZjRcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCczMzJmY2NmNCcsIHNjcmlwdCkpIHtcbiAgICBhcGkucmVsb2FkKCczMzJmY2NmNCcsIHNjcmlwdClcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0FwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzMyZmNjZjRcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignMzMyZmNjZjQnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuc2NyaXB0Ll9fZmlsZSA9IFwicmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQXBwLnZ1ZVwiXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1NlYXJjaC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTAyNmZmZDNcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TZWFyY2gudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1NlYXJjaC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgc2NyaXB0Ll9faG1ySWQgPSBcIjUwMjZmZmQzXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNTAyNmZmZDMnLCBzY3JpcHQpKSB7XG4gICAgYXBpLnJlbG9hZCgnNTAyNmZmZDMnLCBzY3JpcHQpXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9TZWFyY2gudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTUwMjZmZmQzXCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJzUwMjZmZmQzJywgcmVuZGVyKVxuICB9KVxuXG59XG5cbnNjcmlwdC5fX2ZpbGUgPSBcInJlc291cmNlcy9qcy9jb21wb25lbnRzL1NlYXJjaC52dWVcIlxuXG5leHBvcnQgZGVmYXVsdCBzY3JpcHQiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vU2VhcmNoLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL1NlYXJjaC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiJdLCJzb3VyY2VSb290IjoiIn0=